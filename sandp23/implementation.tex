\section{Implementation} \label{sec:implementation}
As mentioned in~\sect{sec:overview}, our implementation of~\systemname{} has two main components,~\ie source level program partitioner (\sourcerewriter) and compiler.
Given a well-typed~\systemname{} program and a sandbox configuration,~\sourcerewriter performs source-to-source transformation and splits the program into two parts (\ie two sets of source files) -- checked and tainted source files corresponding to~\cregion and~\ucregion respectively.
Our compiler will compile the checked source files and adds the necessary dynamic instruction.
The tainted source files need to be compiled with the target sandbox compiler.
Finally, these two sets of object files will be linked along with any sandbox library to produce the final executable that enforces our security guarantees.

We created the sandbox library once and for all for each sandbox.
This library abstracts the sandbox-specific details and exposes a uniform interface (header file) to be used in~\cregion.
For instance,~\code{_SBX_()} gets an opaque pointer to the target sandbox.
We will present our implementation using WebAssembly (WASM~\cite{bosamiya2020webassembly}) as our target sandbox.
%However, as we discuss in~\sect{}, our implementation can be easily extended to other sandbox mechanisms.

\subsection{\sourcerewriter} \label{subsec:checkmate}
The~\sourcerewriter is primarily implemented in C++ as a~\clang frontend tool (\numcheckmatelines{}).
However, we use a small OCAML program (\numocamllines{}) to remove annotations and make the code compilable with the sandbox compiler (\sect{subsubsec:genucregion}).
\aravind{Arun, please fix the number of lines you changed for clang frontend and ocaml program}

\subsubsection{Additional Function Qualifiers}
\label{subsubsec:addfuncqual}
In addition to the~\code{_Tainted} qualifier that marks functions to be in~\ucregion, we provide a few other qualifiers that enable developers to provide additional information and ease the partitioning process.
Specifically, we provide three additional qualifiers:~\code{_Callback},~\code{_Mirror}, and~\code{_TLIB}.

\noindent\emph{\_Callback}:
Developers should use this qualifier to mark callback functions,~\ie functions in~\cregion, that can be called from the tainted region. 
The~\sourcerewriter inserts appropriate sandbox-dependent mechanisms to enable this (\sect{subsub:gencregion}).

\noindent\emph{\_Mirror}: 
This qualifier copies the corresponding function both into~\cregion and~\ucregion code. Such that callers from each region will invoke the corresponding copy.
This helps handle certain simple utility functions that might be called from both~\cregion and~\ucregion code.
\aravind{Give an example from our evaluation program. (E.g., function foo in program1)}.

Placing such common functions in either of the regions restricts their usage from the other region. For instance, if we place~\code{foo} in~\ucregion, then all parameters of it should be tainted. Consequently, callers from~\cregion should use tainted pointers to invoke~\code{foo}, making the arguments and other dependent pointers tainted, leading to over-tainting.
Similarly, placing~\code{foo} in~\cregion will make it hard for the callers in~\ucregion as they should now use the callback mechanism to invoke~\code{foo}.

Developers can use the~\code{_Mirror} qualifier, which copies the function into both the region so that callers in each region will invoke the corresponding copy avoiding unnecessary tainting. 

\noindent\emph{\_TLIB}:
This qualifier relaxes type-checking rules on library functions avoiding unnecessary copying of tainted data.
Specifically, this annotation enables developers to pass tainted pointers as arguments to library functions in~\cregion.

For instance, consider that in~\cregion, we want to string concat~\code{n} characters from tainted pointer~\code{t_str} to~\code{dst} (a checked pointer).
We cannot use~\code{strncat} because our type-checker restricts this as it expects both the pointers to be non-tainted as we are in~\cregion.
We need to either implement the logic for string concatenation in~\cregion or first copy the contents of~\code{t_str} into a~\cregion temporary buffer (sat~\code{tmp}) and then invoke~\code{strncat(dst, tmp, n);}.
Both of these approaches are inefficient and, if not done correctly, might result in security bugs.
If the developer knows that~\code{strncat} accesses only~\code{n} bytes from the source buffer, she would like to directly use~\code{strncat} with tainted source pointer in~\cregion.
The~\code{_TLIB} qualifier enables this as shown below:
\begin{minted}[mathescape, escapeinside=||, fontsize=\footnotesize]{c}
// Put your example annotation here.
// First, manually check the memory is in tainted region.
// if yes, then call strncpy.
if (!is_mem_in_range(t_str, t_str + n, SBX_LOW(), SBX_HIGH()))
  handle_violation();
// our type checker ignores this because 
// the above _TLIB annotation.
strncat(dst, t_str, n);
\end{minted}
\aravind{Arun, Fix the above code. i.e., Add \_TLIB annotation to strncpy }
The above qualifier relaxes type-checking for all the arguments to the calls to~\code{strncat}, enabling the developer to use the function freely in~\cregion.
Note that developer needs to manually add the check before calling~\code{strcat}.

\subsubsection{Generating~\cregion Source Partition}
\label{subsub:gencregion}
We copy all non-tainted functions into~\cregion source files and make the following modifications to enable interaction with~\ucregion (\ie sandboxed code).

We created a library once and for all for each sandbox.
This library abstracts the sandbox-specific details and exposes a uniform interface (header file) to be used in~\cregion.
For instance,~\code{_SBX_()} gets an opaque pointer to the target sandbox.

\iffalse
\noindent\emph{Handling Tainted Buffers in~\cregion}:
All buffers that are marked as tainted in~\cregion should be allocated in the sandbox. For instance,~\code{buff} in function~\code{handle_request} of~\lst{lst:final}.
We perform source rewriting and make the buffer into a pointer variable and allocate the corresponding number of bytes using the sandbox-specific allocator. For instance, we perform the following rewriting for~\code{buff} in~\lst{lst:final} with WASM sandbox.
\begin{minted}[mathescape, escapeinside=||, fontsize=\footnotesize]{diff}
- char buff[MAX_MSG_SIZE] __Tainted;
+ char *buff = ....
\end{minted}
\aravind{Arun, please fix the above example on how exactly we replace it with WASM allocator.}
Note that we also add the necessary deallocator calls at function exit points.
\fi

\noindent\emph{Handling Calls to Tainted Functions}:
In~\cregion, we also need to modify calls to tainted functions as they execute inside the sandbox (separate address space) and thus cannot be invoked as regular functions.
However, modifying every call site of tainted functions is tedious and also requires precise pointer analysis~\cite{milanova2002precise} to handle indirect calls through function pointers.

We handle this by~\emph{indirection}: Instead of modifying the call sites, we modify the body of tainted functions to invoke the corresponding function in the sandbox.
For instance, we modify the body of tainted function~\code{process_req1} (\lst{lst:final}) in~\cregion as below:
\begin{minted}[mathescape, escapeinside=||, fontsize=\footnotesize]{diff}
int process_req1(char *msg, size_t m_l) _Tainted {
- int rc = -1, i;
- if (m_l > MIN_SIZE) {
- ...
+ HOW DO WE HANDLE SANDBOX CALL.
}
\end{minted}
This ensures that all calls (even through function pointers) to the tainted function~\code{process_req1} are redirected to the sandbox.
\aravind{Arun, add the call on how to call sandbox function.}

\noindent\emph{Handling~\texttt{\_Callback} Qualifiers}:
As mentioned in~\sect{subsubsec:addfuncqual}, functions with these qualifiers can be called from~\ucregion.
Consider the following~\code{StringAuth} function that checks whether the provided user is authenticated and needs to be invoked from~\ucregion and hence a callback.
\begin{minted}[mathescape, escapeinside=||, fontsize=\footnotesize]{c}
_Callback _TPtr<char> StringAuth(
               _T_Array_Ptr<const char> usertoken : count(len),
               size_t len) {
...
// Checks whether usertoken is authenticated
/*
 These functions will be restricted to only accept
 tainted parameters.
*/
...
}
\end{minted}
These callback functions are only allowed to use tainted parameters as they will be called from a tainted region.


For each such function, we create a corresponding trampoline function that serves as the entry point for the callback function, as shown below:
\begin{minted}[mathescape, escapeinside=||, fontsize=\footnotesize]{diff}
+ unsigned int _T_StringAuth(unsigned sandbox,
+               unsigned int arg_1,
+               unsigned long int arg_2) {
+   // Perform necessary conversion of arguments.
+   // uname <- conver arg_1
+   // len <- arg_2
+   ret = StringAuth(uname, len);
+   // ret_val <- ret
+   return ret_val;
+ }
\end{minted}
The trampoline function handles the invocations from sandbox (and hence the extra parameter~\code{sandbox}), performs the necessary conversion of pointer arguments, and eventually invokes the callback.

We also add the code to register this trampoline function with the sandbox. The registration function for WASM sandbox is as shown below:
\begin{minted}[mathescape, escapeinside=||, fontsize=\tiny]{diff}
+ void registerCallback_StringAuth(void){
+ //callback function signature {ret <- int, arg_1 <- int, arg_2 <- long}
+ int ret_param_types[] = {0, 0, 1};
+ // 2 <- arg count, 1 <- ret count
+ __StringAuth__C_ = _SBXREG_((void*)_T_StringAuth,2,1, ret_param_types);
+ }
\end{minted}
This registration function creates an opaque handle for the trampoline function and enables~\ucregion to call the trampoline using the corresponding handle.

Lastly, we change all instances where the callback function pointer is given to tainted functions to use the handle for the corresponding trampoline a shown below:
\begin{minted}[mathescape, escapeinside=||, fontsize=\tiny]{c}
// How do we change the call-sites where the function pointer is passed
// as the call-back.
\end{minted}
\aravind{Arun, please check above code example to see if they make sense.}

\subsubsection{Generating~\ucregion Source Partition}
\label{subsubsec:genucregion}
We create~\ucregion partition by first copying all functions marked as~\code{_Tained} and~\code{_Mirror}.
Next, we convert the partition into regular C by replacing all~\systemname{} tainted types with the corresponding C types.
For instance:~\code{_T_Array_ptr<char>} will be replaced with~\code{char *}.
The~\code{read_msg} function signature in~\lst{lst:final} will be modified as shown below:
\begin{minted}[mathescape, escapeinside=||, fontsize=\tiny]{diff}
size_t read_msg(int sock_fd, char *msg,
-                             size_t sz) _Tainted {
+                             size_t sz) {
\end{minted}

Finally, we convert all calls to~\cregion callbacks with sandbox-specific invocations. For instance, for the~\code{StringAuth} call back (\sect{subsub:gencregion}), we modify~\code{...UNCHECKED FUNC..} as shown below:
\begin{minted}[mathescape, escapeinside=||, fontsize=\tiny]{c}
SAY HOW WE MODIFY UNCHECKED CODE
TO INVOKE CALLBACK FUNCTIONS.
\end{minted}
\aravind{Arun, please fix the above example}

\subsection{Compiler}
\label{subsec:compilerimple}
The~\systemname compiler includes the type checker (\sect{sec:typechecking}) and necessary instrumentation to handle tainted pointers (\ie from sandbox) and perform runtime checks.
We implemented the compiler (\numcompilerlines{}) on top of the existing~\checkedc compiler.
\aravind{Arun, please fix the number of changes you made for the compiler}

Our type checker verifies the constraints (\fig{fig:type-system-1}) and displays violations as errors, enabling developers to make additional annotations.
For instance, for the code in~\lst{lst:final}, our type checker emits an error saying that ``~\emph{buffer~\code{buff} is tainted, but it is allocated in~\cregion}''.
Consequently, the developer has to make the following changes to allocate~\code{buff} in the sandbox:
\begin{minted}[mathescape, escapeinside=||, fontsize=\tiny]{diff}
- char buff[MAX_MSG_SIZE] _Tainted;
+ _t_Array_ptr<char> buff: count(MAX_MSG_SIZE)
+    = sbx_allocate(MAX_MSG_SIZE);
...
+ sbx_free(buff)
return rc;
\end{minted}

For all tainted pointer access, our instrumentation adds a check (executed at runtime) to see we check if the address is within the valid range for the sandbox. An example of the check is shown below:
\begin{minted}[mathescape, escapeinside=||, fontsize=\tiny]{diff}
_TPtr<int> t = ...
+ if (!is_in_range(t, SBX_LOW(), SBX_HIGH()))
+  handle_violation();
*t = 1;
\end{minted}
We show the added check in C for clarify. However, our instrumentation works on LLVM IR.

The~\ucregion source files will be compiled with sandbox compiler,~\ie NAMEOFSANDBOXCOMPILER (CITATION).
Given that WASM sandbox uses 32-bit addresses (v/s 64-bit for~
\cregion), our instrumentation also adds necessary pointer swizzling to have transparent access to composite data types,~\ie~\code{struct}'s with pointers. 
\aravind{Arun, please fill up the name of the sandbox compiler and add citation.}

\subsection{Supporting General Partioning Use Case}
\input{figures/newusecase}

Tainting all functions that are not checked may lead to a large number of transitions to the sandbox, which could add unnecessary overhead. In our example, in~\lst{lst:final}, marking~\code{read_msg} function as tainted would cause the system to transition to and from the sandbox every time a message is read, which could be inefficient. 

However, as mentioned in~\sect{subsec:checkedc}, checked pointers can be used alongside regular pointers, so the~\cregion{}~\emph{can} contain regular (unchecked) pointers as well.
%
This allows for flexibility in how the program is partitioned, such as only tainting a few high-risk unchecked functions rather than all of them. In this way, the system can be used as a generic program partitioning technique that balances the trade-off between overhead and security assurance.

For our example in~\lst{lst:final}, we can make only the function \code{process_req1} as tainted, thereby transitioning into a sandbox only when the corresponding (high-risk) request is received.

The general guidelines for this alternative use case are shown in~\fig{fig:mixedmodesupport}.
It is best to annotate all functions with checked types for security purposes. However, if it is difficult to convert all functions, it may be more practical to only mark certain high-risk functions with a high probability of vulnerabilities as tainted. This allows for a flexible partitioning system that balances the need for security assurance with the overhead of converting to~\checkedc.
We add the additional constraint of not allowing casting from taint types to generic types to enable this generic use case without violating the safety guarantees of~\systemname.
Specifically, we disallow the following casting in~\cregion:
\begin{minted}[mathescape, escapeinside=||, fontsize=\tiny]{diff}
//_t_Ptr<int> y; int *z;
|\faRemove| z = (int *)y; // Not allowed.
\end{minted}
\iffalse

%\subsection{Overview}
%\systemname is implemented as a \systemname compiler and a \systemname source-level partitioning assistant (CheckMate). Given a well-typed \systemname program as an input, CheckMate performs the automation of moving the \systemname qualified function definitions to new "unchecked" source files, whilst inserting STD library headers needed for the successful compilation of these "unchecked" sources to an object file with a Sandbox-specific compiler. Since \systemname is irrelevant to the Sandbox-specific compiler, CheckMate internally runs an OCAML translator to cleanse away the \systemname annotations by converting these tainted definitions to generic-C. Now with the \systemname qualified functions and variables re-defined under the "unchecked" library object, the \systemname qualified functions definitions in the "checked" region are modified by the CheckMate accordingly to allow communication between the two regions. 
%\subsection{\systemname Function Qualifiers}
%\systemname function qualifiers are introduced with a purpose of semantic policing to allow the developer to perform dependency-resolved program partitioning into checked and unchecked regions from within the checked sources. Each of the newly introduced qualifiers "\_Tainted", "\_Mirror", "\_TLIB" and "\_Callback" enforce different semantic-ruling at compile time to allow "unchecked" and "checked" functions to communicate and access global data in a region-exclusive manner. Although checked functions are allowed to call and access "unchecked" data within the checked region, "unchecked" region can only access checked data through a specialized callback mechanism. Each of these function qualifiers differently control casting, caller, callee and data-access rules within its qualifier-scope. For example, \_TLIB qualifier allows tainted pointer parameters to be cast to non-tainted pointer arguments at the call-site of a qualified function with developer's discretion that the qualified function does not leak tainted addresses. This type-checker relaxation is granted to enable developer to avoid marshalling costs when passing tainted pointers to external library functions.     

%\subsection{CheckMate S2S transformation}
%\subsubsection{\textbf{Need for Callback}}
%Here, we use the example of a simple \systemname annotated string authentication program snippet in ~\lst{lst:callbackBefore} with~\code{StringProc} as its entry point (\entrypoint). ~\code{StringProc} was found to internally perform a lot of unsafe string parsing and manipulation on the user input and thereby has been marked \_Tainted. However, ~\code{StringProc} internally calls ~\code{StringAuth} that performs final authentication on user input by referencing classified global checked data. In interests of maintaining confidentiality of global checked data from the unchecked region whilst satisfying this control and data dependency, ~\code{StringAuth} has been qualified as a \_Callback, thereby bestowing it with WASM Sandbox's addition sanity checks at its call-sites within the unchecked region.
%
%\subsubsection{\textbf{CheckMate S2S transformation on Checked Sources}}
%\myparagraph{WebAssembly Sandbox:}
%Unchecked region implemented as a WebAssembly sandbox requires registering ~\code{StringAuth} with its expected WebAssembly callee signature as a requirement to safeguard the control-flow between the two regions.
%Within the WebAssembly sandbox, all functions are defined with an extra sandbox pointer argument and all pointer members are unsigned integers. 
%
%\myparagraph{CheckMate Instrumentation: }
%Consequently, ~\code{StringAuth}'s corresponding call-site signature in the tainted region would be 
%\newline
%~\code{_T_StringAuth}, which is an indirected trampoline call to the actual callback function. CheckMate identifies ~\code{StringAuth} to be a \_Callback qualified callee and correspondingly generates callback trampoline ~\code{StringAuth} and callback registration code 
%\newline
%~\code{registerCallback_StringAuth} within the checked region as show in ~\lst{lst:callbackAfter}. 
%~\code{registerCallback_StringAuth} registers the WebAssembly-specific callback function ~\code{_T_StringAuth} by calling ~\code{\_SBXREG\_} with callback-specific argument count and argument signature. 
%CheckMate replaces \_Tainted qualified ~\code{StringProc}'s definition with an indirect call to sandbox specific implementation ~\code{w2c_StringProc}. The \_Mirror qualifier is used mark a function in checked region as a local to both the checked and the unchecked regions. Consequently, CheckMate does not modify \_Mirror qualified ~\code{isStringMatching} and simply duplicates this function in the unchecked region.
%
%\subsubsection{\textbf{CheckMate S2S generation of Tainted Sources}}
%Implementing \systemname's unchecked region as a WebAssembly sandbox requires compiling unchecked functions and unchecked variables checked-region-exclusively with a sandbox-specific compiler (WebAssembly). Consequently, CheckMate copies each of the \_Mirror and \_Tainted qualified function definitions to a new source file and runs an OCAML parser to convert \systemname code to generic-C as shown in ~\lst{lst:callbackAfterTainted} which shows the CheckMate generated code for ~\code{StringProc}.
%After running CheckMate, each of newly generated tainted sources can be compiled to an "unchecked" static library using a sandbox-specific compiler.
%CheckMate's OCAML parser also modifies each of the tainted STDLIB functions from ~\code{t_strncpy} under ~\lst{lst:callbackBefore} to ~\code{strncpy} under ~\lst{lst:callbackAfterTainted}
%
%\begin{listing}
%\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/callback_mechanism_sample_before_checkmate.c}
%\caption{Callback Annotations before running CheckMate}
%\label{lst:callbackBefore}
%\end{listing}
%\begin{listing}[t!]
%\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/callback_mechanism_sample_after_checkmate.c}
%\caption{CheckMate generated Callback Annotations in Checked Sources }
%\label{lst:callbackAfter}
%\end{listing}
%\begin{listing}[t!]
%\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/callback_mechanism_sample_after_checkmate_tainted.c}
%\caption{CheckMate generated Unchecked Sources }
%\label{lst:callbackAfterTainted}
%\end{listing}

\subsection{\systemname Dynamic Instrumentation}
\systemname compiler is implemented to be sandbox-agnostic and differs in inserted instrumentation based on the sandbox type specified by a compiler flag. However, the scope of this paper restricts discussion to the 32-Bit WebAssembly sandbox wherein which pointers are represented as 4-Byte offsets from a base sandbox heap. Similar analogy has been applied in \systemname for WebAssembly wherein all tainted pointers in the checked region store zero-extended offsets, that upon access, are transformed to full addresses by the function \ref{O2P}.   
\subsubsection{\textbf{Overview}}
\systemname compiler inserts run-time instrumentation on every access to a tainted pointer to assert pointer taintedness and to generate dereferencible address from the pointer offset. Pointer taintedness is an invariant that prevents checked memory addresses from leaking into the tainted region by establishing the tainted pointer to only point into the Sandbox memory.
Since WebAssembly sandbox is implemented in 32-Bit, specialized struct type is created and instrumentation is inserted by the \systemname compiler at every pointer access to account for pointer-swizzling across different pointer representations.

\subsubsection{\textbf{Pointer-swizzling}}
WebAssmebly implementation of \systemname motivates Tainted pointers in checked region to implemented as a zero-extended 32-bit offset into the Sandbox. Every access to the tainted pointer calls for a pointer generation mechanism that generates a fully de-referencible pointer address as    
shown by the equation\ref{O2P}.

Since \systemname does not require qualified functions to mandatorily execute in the unchecked region, tainted pointers may never have to cross into the sandbox. In such cases, we need not swizzle and the tainted pointers are implemented as 64-Bit pointers that contain zero extended 4-Byte pointer offsets into the Sandbox memory.
However, Need for swizzling emerges when indexing into multi-level tainted pointers or tainted pointers to structures that are passed into the sandbox region. “\_Decoy” is a pointer variable qualifier that informs the compiler to enforce 64-Bit to 32-bit pointer swizzling throughout the qualified variable's lifetime in the checked region. 
Pointer-Swizzling is implemented in Clang-CodeGen as a modified GEP-instruction that considers \_Decoy when generating swizzled addresses causing \_Decoy qualified variables to be accessed as 32-bit pointers in the checked region.
\begin{equation}
  \_T\_ptr\_ADDR = \_T\_ptr\_OFFSET + SBX\_HEAP\_BASE
\label{O2P}
\end{equation}

\subsubsection{\textbf{Tainted Structures}}
Tainted Pointers to structures crossing into the sandbox are expected to only allow encapsulation of pointer members that are of the tainted type. Consequently, Tstructs have been introduced as a specialized struct type that enforces compile-time semantics to allow prevent its pointer members from being of non-tainted type. \systemname also restricts tainted pointers to only point to structures of Tstruct type. These semantic restrictions of Tstructs are put in place to prevent checked pointer from leaking into the unchecked regions as members of pointer structures. Tstruct variables follow the conventional layout unless qualified as a \_Decoy variable, in which case, the Tstruct's pointer member accesses follow a 32-Bit layout. 
\fi
