\section{Implementation} \label{sec:implementation}
As mentioned in~\Cref{sec:overview}, our implementation of~\systemname{} has two main components,~\ie source level program partitioner (\sourcerewriter) and compiler.
Given a well-typed~\systemname{} program and a sandbox configuration,~\sourcerewriter performs source-to-source transformation and splits the program into two parts (\ie two sets of source files) -- checked and tainted source files corresponding to~$\cmode$ and~\ucregion respectively.
Our compiler translates the checked source files and adds the necessary dynamic instruction.
The tainted source files need to be compiled with the target sandbox compiler.
Finally, these two sets of object files will be linked along with any sandbox library to produce the final executable that enforces our security guarantees.

We created the sandbox library once and for all for each sandbox.
This library abstracts the sandbox-specific details and exposes a uniform interface (header file) to be used in~\cregion.
For instance,~\code{_SBX_()} gets an opaque pointer to the target sandbox.
We will present our implementation using WebAssembly (WASM~\cite{bosamiya2020webassembly}) as our target sandbox.
We also formalize the implementation and show a simulation theorem in \Cref{appx:comp1}.

\subsection{\sourcerewriter} \label{subsec:checkmate}
The~\sourcerewriter is primarily implemented in C++ as a~\clang frontend tool (3K SLoc).
However, we use a small OCAML program (680 SLoc) to remove annotations and make the code compilable with the sandbox compiler (\sect{subsubsec:genucregion}).

\subsubsection{Additional Function Qualifiers}
\label{subsubsec:addfuncqual}
In addition to the~\code{_Tainted} qualifier that marks functions to be in~\ucregion, we provide a few other qualifiers that enable developers to provide additional information and ease the partitioning process.
Specifically, we provide three additional qualifiers:~\code{_Callback},~\code{_Mirror}, and~\code{_TLIB}.

\noindent\emph{\_Callback}:
Developers should use this qualifier to mark callback functions,~\ie functions in~\cregion, that can be called from the tainted region. 
The~\sourcerewriter inserts appropriate sandbox dependent mechanisms to enable this (\ref{subsub:gencregion}).

\noindent\emph{\_Mirror}: 
This qualifier permits copying the corresponding function into both ~\cregion and~\ucregion, which permits the handling of certain simple utility functions that are called from both regions. For example, ~\code{append_string} in our evaluation of parsons\_wasm has callers from both the regions. 
\begin{minted}[mathescape, escapeinside=||, fontsize=\footnotesize]{c}
_Mirror int append_string(_TPtr<char> buf,
const char* appendStr : itype(_Nt_array_ptr<const char>),
_TPtr<char> buf_start, size_t buf_len) {
/* Qualifier Rules:
1.) No access to global data NOT marked "const"
2.) Callees must be _Tainted or _Mirror
*/
...
}

\end{minted}
Qualifying ~\code{append_string} with~\code{_Mirror} duplicates the function in both regions, allowing calls to \code{append_string} with parameter to \code{appendStr} as an unchecked or checked pointer within $\umode$ and $\cmode$ regions, respectively. Consequently complexity from over-tainting is avoided as ~\code {appendStr} need not be tainted in ~\cregion and neither are callbacks required to access ~\code{append_string} from ~\ucregion.   
"\_Mirror" enforces control-flow and data-flow compile-time semantic rules to ensure all variable and function call dependencies of mirrored functions required for ~\ucregion's compilation are resolved. 

\noindent\emph{\_TLIB}:
This qualifier relaxes type-checking rules on library functions, allowing developers to use the function freely in ~\cregion.
\begin{minted}[mathescape, escapeinside=||, fontsize=\footnotesize]{c}
// First, manually check the memory is in tainted region.
// if yes, then call strncpy.
if (!is_mem_in_range(t_str, t_str + n, SBX_LOW(), SBX_HIGH()))
  handle_violation();
// our type checker ignores this because 
// the _TLIB annotation below.
strncat(dst, t_str, n);
\end{minted}

\begin{minted}[mathescape, escapeinside=||, fontsize=\footnotesize]{diff}
- extern char *strncat (char *__restrict __dest,
+ _TLIB extern char *strncat (char *__restrict __dest,
const char *__restrict __src, size_t __n); // In the header file
}
\end{minted}

Passing tainted pointer \code{t_str} to unqualified ~\code{strncat} above is disallowed without having additional ~\ucregion implementation for \code{strncat}. If a user ascertains that \code{t_str} has the right buffer size for \code{strncat}, she might label \code{strncat} with \code{\_TLIB}, so that \code{t_str} can be treated as an checked pointer parameter; such annotation relaxes type-checking for all the arguments to its calls. It is worth noting that \systemname does not enforce any semantics to ensure ~\code{\_TLIB} functions implemented in ~\cregion are non memory-modifying; therefore, using \code{\_TLIB} requires users' awareness of memory address leaks.

\subsubsection{Generating~\cregion Source Partition}
\label{subsub:gencregion}
We copy all non-tainted functions into~\cregion source files and make the following modifications to enable interaction with~\ucregion (\ie sandboxed code).
We created a library once and for all for each sandbox.
This library abstracts the sandbox-specific details and exposes a uniform interface (header file) to be used in~\cregion.
For instance,~\code{_SBX_()} gets an opaque pointer to the target sandbox.

\iffalse
\noindent\emph{Handling Tainted Buffers in~\cregion}:
All buffers that are marked as tainted in~\cregion should be manually allocated in the sandbox. For instance,~\code{buff} in function~\code{handle_request} of~\lst{lst:final}.
We perform source rewriting and make the buffer into a pointer variable and allocate the corresponding number of bytes using the sandbox-specific allocator. For instance, we perform the following rewriting for~\code{buff} in~\lst{lst:final} with WASM sandbox.
\begin{minted}[mathescape, escapeinside=||, fontsize=\footnotesize]{diff}
- char buff[MAX_MSG_SIZE] __Tainted;
+ _TPtr<char> buff = (_TPtr<char>)t_malloc(MAX_MSG_SIZE);  
\end{minted}
Note that we also add the necessary deallocator calls at function exit points.
\fi

\noindent\emph{Handling Calls to Tainted Functions}:
In~\cregion, we also need to modify calls to tainted functions as they execute inside the sandbox (separate address space) and thus cannot be invoked as regular functions.
However, modifying every call site of tainted functions is tedious and also requires precise pointer analysis~\cite{milanova2002precise} to handle indirect calls through function pointers.

We handle this by~\emph{indirection}: Instead of modifying the call sites, we modify the body of tainted functions to invoke the corresponding function in the sandbox.
For instance, we modify the body of tainted function~\code{process_req1} (\lst{lst:final}) in~\cregion as below:
\begin{minted}[mathescape, escapeinside=||, fontsize=\footnotesize]{diff}
int process_req1(char *msg, size_t m_l) _Tainted {
- int rc = -1, i;
- if (m_l > MIN_SIZE) {
- ...
+ return w2c_process_req1(msg, m_l);
}
\end{minted}
This ensures that all calls (even through function pointers) to the tainted function~\code{process_req1} are redirected to the sandbox.

\noindent\emph{Handling~\texttt{\_Callback} Qualifiers}:
As mentioned in~\sect{subsubsec:addfuncqual}, functions with these qualifiers can be called from~\ucregion.
Consider the following~\code{StringAuth} function that checks whether the provided user input ~\code{usertoken} is authenticated by accessing checked data. Since this needs to be invoked from ~\ucregion it is annotated as a ~\code{\_Callback}.
\begin{minted}[mathescape, escapeinside=||, fontsize=\footnotesize]{c}
_Callback _TPtr<char> StringAuth(
               _T_Array_Ptr<const char> usertoken : count(len),
               size_t len) {
...
// Checks whether usertoken is authenticated
/*
 These functions will be restricted to only accept
 tainted parameters.
*/
...
}
\end{minted}
These callback functions are only allowed to use tainted parameters as they will be called from a tainted region.


For each such function, we create a corresponding trampoline function that serves as the entry point for the callback function, as shown below:
\begin{minted}[mathescape, escapeinside=||, fontsize=\footnotesize]{diff}
+ unsigned int _T_StringAuth(void* sandbox,
+               unsigned int arg_1,
+               unsigned long int arg_2) {
+   // Perform necessary Type-conversion of arguments.
+   // uname <- conver arg_1
+   // len <- arg_2
+   ret = StringAuth(uname, len);
+   // ret_val <- ret
+   return ret_val;
+ }
\end{minted}

The trampoline function handles the invocations from sandbox (and hence the extra parameter~\code{sandbox}), performs necessary pointer argument conversion, and eventually invokes the callback.

We also add the code to register this trampoline function with the sandbox. The registration function for WASM sandbox is as shown below:
\begin{minted}[mathescape, escapeinside=||, fontsize=\tiny]{diff}
+ void registerCallback_StringAuth(void){
+ //callback function signature {ret <- int, arg_1 <- int, arg_2 <- long}
+ int ret_param_types[] = {0, 0, 1};
+ // 2 <- arg count, 1 <- ret count
+ __StringAuth__C_ = _SBXREG_((void*)_T_StringAuth,2,1, ret_param_types);
+ }
\end{minted}
This registration function creates an opaque handle for the trampoline function and enables~\ucregion to call the trampoline using the corresponding handle.

Lastly, we change the tainted function's body to include an indirect call to the sandbox's implementation of the tainted function. However, instead of passing the callback function pointer directly from the argument list, we pass the generated trampoline handle ~\code{__StringAuth__C_} as shown below:
\begin{minted}[mathescape, escapeinside=||, fontsize=\tiny]{diff}
_Tainted _TPtr<char> StringProc(_TPtr<_TPtr<const char>> user_input,
_TPtr<_TPtr<char>(_TPtr<const char> input, size_t len)>StringAuth) {
-  ...
-  //complex Function Body       
- return StringAuth(one_past_start, string_len);
+ return w2c_StringProc(_SBX_(), (unsigned int)string, __StringAuth__C_);

}
\end{minted}

\subsubsection{Generating~\ucregion Source Partition}
\label{subsubsec:genucregion}
We create~\ucregion partition by first copying all functions and variables marked as~\code{_Tained} and~\code{_Mirror}.
Next, we convert the partition into regular C by replacing all tainted types with the corresponding C types.
\newline
For instance:~\code{_T_Array_ptr<char>} will be replaced with~\code{char *}.

The~\code{read_msg} function signature in \lst{lst:final} will be modified in the ~\ucregion as shown below:
\begin{minted}[mathescape, escapeinside=||, fontsize=\tiny]{diff}
size_t read_msg(int sock_fd, char* msg,
-                             size_t sz) _Tainted {
+                             size_t sz) {
\end{minted}

% ** We Do NOT modify callback function in checked sources **
% Finally, we convert all calls to~\cregion callbacks with sandbox-specific invocations. For instance, for the~\code{StringAuth} call back (\sect{subsub:gencregion}), we modify~\code{...UNCHECKED FUNC..} as shown below:
% \begin{minted}[mathescape, escapeinside=||, fontsize=\tiny]{c}
% SAY HOW WE MODIFY UNCHECKED CODE
% TO INVOKE CALLBACK FUNCTIONS.
% \end{minted}
% \aravind{Arun, please fix the above example}

\subsection{Compiler}
\label{subsec:compilerimple}
The~\systemname compiler includes the type checker (\sect{sec:typechecking}) and necessary instrumentation to handle tainted pointers (\ie from sandbox) and perform runtime checks.
We implemented the compiler as a library (1.8K SLoc) on top of the existing~\checkedc compiler.
Our type checker verifies the constraints (\fig{fig:type-system-1}) and displays violations as errors, enabling developers to make additional annotations.
For instance, for the code in~\lst{lst:final}, our type checker emits an error saying that ``~\emph{buffer~\code{buff} is tainted, but it is allocated in~\cregion}''.
Consequently, the developer has to make the following changes to allocate~\code{buff} in the sandbox:
\begin{minted}[mathescape, escapeinside=||, fontsize=\tiny]{diff}
- char buff[MAX_MSG_SIZE] _Tainted;
+ _T_Array_ptr<char> buff: count(MAX_MSG_SIZE)
+    = sbx_allocate(MAX_MSG_SIZE);
...
+ sbx_free(buff)
return rc;
\end{minted}

For all tainted pointer access, our instrumentation adds a check (executed at runtime) to see we check if the address is within the valid range for the sandbox. An example of the check is shown below:
\begin{minted}[mathescape, escapeinside=||, fontsize=\tiny]{diff}
_TPtr<int> t = ...
+ if (!is_in_range(t, SBX_LOW(), SBX_HIGH()))
+  handle_violation();
*t = 1;
\end{minted}
We show the added check in C for clarify. However, our instrumentation works on LLVM IR.

The~\ucregion source files will be compiled with sandbox compiler,~\ie WASI-SDK (~\cite{wasi-clang}).
Given that WASM sandbox uses 32-bit addresses (v/s 64-bit for~
\cregion), our instrumentation also adds necessary pointer swizzling to have transparent access to composite data types,~\ie~\code{struct}'s with pointers. 

\subsection{Balance Assurance and Overhead}
\label{subsec:otherusecases}
\input{figures/newusecase}

Tainting all functions that are not checked may lead to a large number of transitions to the sandbox, which could add unnecessary overhead. In our example, in~\lst{lst:final}, marking~\code{read_msg} function as tainted would cause the system to transition to and from the sandbox every time a message is read, which could be inefficient. 

However, as mentioned in~\sect{subsec:checkedc}, checked pointers can be used alongside regular pointers, so the~\cregion{}~\emph{can} contain regular (unchecked) pointers as well.
This allows for flexibility in how the program is partitioned, such as only tainting a few high-risk unchecked functions rather than all of them. 
For our example in~\lst{lst:final}, we can make only the function \code{process_req1} as tainted, thereby transitioning into a sandbox only when the corresponding (high-risk) request is received.


In this way, the system can be used as a generic program partitioning technique that balances the trade-off between overhead and security assurance.
The general guidelines for this alternative use case are shown in~\fig{fig:mixedmodesupport}.
It is best to annotate all functions with checked types for security purposes. However, if it is difficult to convert all functions, it may be more practical to only mark certain high-risk functions with a high probability of vulnerabilities as tainted,
which maintains the assurance and overhead balance.
We add the additional constraint of not allowing casting from taint types to generic types to enable this generic use case without violating the safety guarantees of~\systemname.
Specifically, we disallow the following casting in~\cregion:
\begin{minted}[mathescape, escapeinside=||, fontsize=\tiny]{diff}
//_t_Ptr<int> y; int *z;
|\faRemove| z = (int *)y; // Not allowed.
\end{minted}
\iffalse

%\subsection{Overview}
%\systemname is implemented as a \systemname compiler and a \systemname source-level partitioning assistant (CheckMate). Given a well-typed \systemname program as an input, CheckMate performs the automation of moving the \systemname qualified function definitions to new "unchecked" source files, whilst inserting STD library headers needed for the successful compilation of these "unchecked" sources to an object file with a Sandbox-specific compiler. Since \systemname is irrelevant to the Sandbox-specific compiler, CheckMate internally runs an OCAML translator to cleanse away the \systemname annotations by converting these tainted definitions to generic-C. Now with the \systemname qualified functions and variables re-defined under the "unchecked" library object, the \systemname qualified functions definitions in the "checked" region are modified by the CheckMate accordingly to allow communication between the two regions. 
%\subsection{\systemname Function Qualifiers}
%\systemname function qualifiers are introduced with a purpose of semantic policing to allow the developer to perform dependency-resolved program partitioning into checked and unchecked regions from within the checked sources. Each of the newly introduced qualifiers "\_Tainted", "\_Mirror", "\_TLIB" and "\_Callback" enforce different semantic-ruling at compile time to allow "unchecked" and "checked" functions to communicate and access global data in a region-exclusive manner. Although checked functions are allowed to call and access "unchecked" data within the checked region, "unchecked" region can only access checked data through a specialized callback mechanism. Each of these function qualifiers differently control casting, caller, callee and data-access rules within its qualifier-scope. For example, \_TLIB qualifier allows tainted pointer parameters to be cast to non-tainted pointer arguments at the call-site of a qualified function with developer's discretion that the qualified function does not leak tainted addresses. This type-checker relaxation is granted to enable developer to avoid marshalling costs when passing tainted pointers to external library functions.     

%\subsection{CheckMate S2S transformation}
%\subsubsection{\textbf{Need for Callback}}
%Here, we use the example of a simple \systemname annotated string authentication program snippet in ~\lst{lst:callbackBefore} with~\code{StringProc} as its entry point (\entrypoint). ~\code{StringProc} was found to internally perform a lot of unsafe string parsing and manipulation on the user input and thereby has been marked \_Tainted. However, ~\code{StringProc} internally calls ~\code{StringAuth} that performs final authentication on user input by referencing classified global checked data. In interests of maintaining confidentiality of global checked data from the unchecked region whilst satisfying this control and data dependency, ~\code{StringAuth} has been qualified as a \_Callback, thereby bestowing it with WASM Sandbox's addition sanity checks at its call-sites within the unchecked region.
%
%\subsubsection{\textbf{CheckMate S2S transformation on Checked Sources}}
%\myparagraph{WebAssembly Sandbox:}
%Unchecked region implemented as a WebAssembly sandbox requires registering ~\code{StringAuth} with its expected WebAssembly callee signature as a requirement to safeguard the control-flow between the two regions.
%Within the WebAssembly sandbox, all functions are defined with an extra sandbox pointer argument and all pointer members are unsigned integers. 
%
%\myparagraph{CheckMate Instrumentation: }
%Consequently, ~\code{StringAuth}'s corresponding call-site signature in the tainted region would be 
%\newline
%~\code{_T_StringAuth}, which is an indirected trampoline call to the actual callback function. CheckMate identifies ~\code{StringAuth} to be a \_Callback qualified callee and correspondingly generates callback trampoline ~\code{StringAuth} and callback registration code 
%\newline
%~\code{registerCallback_StringAuth} within the checked region as show in ~\lst{lst:callbackAfter}. 
%~\code{registerCallback_StringAuth} registers the WebAssembly-specific callback function ~\code{_T_StringAuth} by calling ~\code{\_SBXREG\_} with callback-specific argument count and argument signature. 
%CheckMate replaces \_Tainted qualified ~\code{StringProc}'s definition with an indirect call to sandbox specific implementation ~\code{w2c_StringProc}. The \_Mirror qualifier is used mark a function in checked region as a local to both the checked and the unchecked regions. Consequently, CheckMate does not modify \_Mirror qualified ~\code{isStringMatching} and simply duplicates this function in the unchecked region.
%
%\subsubsection{\textbf{CheckMate S2S generation of Tainted Sources}}
%Implementing \systemname's unchecked region as a WebAssembly sandbox requires compiling unchecked functions and unchecked variables checked-region-exclusively with a sandbox-specific compiler (WebAssembly). Consequently, CheckMate copies each of the \_Mirror and \_Tainted qualified function definitions to a new source file and runs an OCAML parser to convert \systemname code to generic-C as shown in ~\lst{lst:callbackAfterTainted} which shows the CheckMate generated code for ~\code{StringProc}.
%After running CheckMate, each of newly generated tainted sources can be compiled to an "unchecked" static library using a sandbox-specific compiler.
%CheckMate's OCAML parser also modifies each of the tainted STDLIB functions from ~\code{t_strncpy} under ~\lst{lst:callbackBefore} to ~\code{strncpy} under ~\lst{lst:callbackAfterTainted}
%
%\begin{listing}
%\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/callback_mechanism_sample_before_checkmate.c}
%\caption{Callback Annotations before running CheckMate}
%\label{lst:callbackBefore}
%\end{listing}
%\begin{listing}[t!]
%\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/callback_mechanism_sample_after_checkmate.c}
%\caption{CheckMate generated Callback Annotations in Checked Sources }
%\label{lst:callbackAfter}
%\end{listing}
%\begin{listing}[t!]
%\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/callback_mechanism_sample_after_checkmate_tainted.c}
%\caption{CheckMate generated Unchecked Sources }
%\label{lst:callbackAfterTainted}
%\end{listing}

\subsection{\systemname Dynamic Instrumentation}
\systemname compiler is implemented to be sandbox-agnostic and differs in inserted instrumentation based on the sandbox type specified by a compiler flag. However, the scope of this paper restricts discussion to the 32-Bit WebAssembly sandbox wherein which pointers are represented as 4-Byte offsets from a base sandbox heap. Similar analogy has been applied in \systemname for WebAssembly wherein all tainted pointers in the checked region store zero-extended offsets, that upon access, are transformed to full addresses by the function \ref{O2P}.   
\subsubsection{\textbf{Overview}}
\systemname compiler inserts run-time instrumentation on every access to a tainted pointer to assert pointer taintedness and to generate dereferencible address from the pointer offset. Pointer taintedness is an invariant that prevents checked memory addresses from leaking into the tainted region by establishing the tainted pointer to only point into the Sandbox memory.
Since WebAssembly sandbox is implemented in 32-Bit, specialized struct type is created and instrumentation is inserted by the \systemname compiler at every pointer access to account for pointer-swizzling across different pointer representations.

\subsubsection{\textbf{Pointer-swizzling}}
WebAssmebly implementation of \systemname motivates Tainted pointers in checked region to implemented as a zero-extended 32-bit offset into the Sandbox. Every access to the tainted pointer calls for a pointer generation mechanism that generates a fully de-referencible pointer address as    
shown by the equation\ref{O2P}.

Since \systemname does not require qualified functions to mandatorily execute in the unchecked region, tainted pointers may never have to cross into the sandbox. In such cases, we need not swizzle and the tainted pointers are implemented as 64-Bit pointers that contain zero extended 4-Byte pointer offsets into the Sandbox memory.
However, Need for swizzling emerges when indexing into multi-level tainted pointers or tainted pointers to structures that are passed into the sandbox region. “\_Decoy” is a pointer variable qualifier that informs the compiler to enforce 64-Bit to 32-bit pointer swizzling throughout the qualified variable's lifetime in the checked region. 
Pointer-Swizzling is implemented in Clang-CodeGen as a modified GEP-instruction that considers \_Decoy when generating swizzled addresses causing \_Decoy qualified variables to be accessed as 32-bit pointers in the checked region.
\begin{equation}
  \_T\_ptr\_ADDR = \_T\_ptr\_OFFSET + SBX\_HEAP\_BASE
\label{O2P}
\end{equation}

\subsubsection{\textbf{Tainted Structures}}
Tainted Pointers to structures crossing into the sandbox are expected to only allow encapsulation of pointer members that are of the tainted type. Consequently, Tstructs have been introduced as a specialized struct type that enforces compile-time semantics to allow prevent its pointer members from being of non-tainted type. \systemname also restricts tainted pointers to only point to structures of Tstruct type. These semantic restrictions of Tstructs are put in place to prevent checked pointer from leaking into the unchecked regions as members of pointer structures. Tstruct variables follow the conventional layout unless qualified as a \_Decoy variable, in which case, the Tstruct's pointer member accesses follow a 32-Bit layout. 
\fi
