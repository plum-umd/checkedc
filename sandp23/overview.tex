\section{Overview}
\label{sec:overview}

\begin{listing}[t!]
  \begin{tabular}{c c}
    \begin{minipage}[b]{.22\textwidth}
\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/orig1.c}
    \end{minipage} &
    \begin{minipage}[b]{.22\textwidth}
\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/orig2.c}
    \end{minipage} %\\
   %(a) Original C code & (b) After initial conversion.\\
  \end{tabular}
\caption{C program snippet of a simple network server with an arbitrary memory write vulnerability indicated by~\realbug.}
\label{lst:comb}
\end{listing}

\begin{listing}[t!]
\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/firstrun.c}
\caption{Pointers in~\lst{lst:comb} annotated (manually or through automated tools like~\threec) with Checked Types.}
\label{lst:initialconv}
\end{listing}

\begin{listing}[t!]
\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/humanannotations.c}
\caption{Initial annotations of tainted functions in~\lst{lst:comb}.}
\label{lst:humantaint}
\end{listing}

\begin{listing}[t!]
\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/humanadjustments.c}
\caption{Additional tainted pointers annotations to~\lst{lst:comb} according to typing rules.}
\label{lst:humanadjust}
\end{listing}

\begin{listing}[t!]
  \begin{tabular}{c c}
    \begin{minipage}[b]{.22\textwidth}
\inputminted[mathescape, escapeinside=||, fontsize=\tiny{}]{c}{examples/conv1.c}
    \end{minipage} &
    \begin{minipage}[b]{.22\textwidth}
\inputminted[mathescape, highlightlines={1-19}, highlightcolor=taintcolor, escapeinside=||, fontsize=\tiny{}]{c}{examples/conv2.c}
    \end{minipage} %\\
   %(a) Original C code & (b) After initial conversion.\\
  \end{tabular}
\caption{Final annotated program of~\lst{lst:comb} with~\textcolor{taintcolor}{tainted} and~\textcolor{checkcolor}{checked} types. The~\colorbox{taintcolor}{highlighted} functions will be executed in a sandbox.}
\label{lst:final}
\end{listing}

\input{figures/overview}

\Cref{fig:overview} shows the interaction between various components of~\systemname{}.
Given an appropriately annotated source program and a sandbox configuration, \systemname{} creates an executable such that all tainted functions and data reside in a sandbox and the~\cregion (non-sandboxed) is not affected by the code in the sandbox.
Here, we brief \systemname{} from a developer perspective and the details of individual components in the later sections.

%\Cref{fig:overview} provides the compiler structure of \systemname. The \systemname type checker compiles a \systemname program by partitioning the different program regions, i.e., $c$ and $uc$ regions, as well as different pointers, i.e., checked, unchecked and tainted pointers. Any $uc$ region pointers are executed within a sandbox, while checked pointers are executed via the \checkedc compiler within the checked region.

%\Cref{sec:formal} provides the formalism of the different compiler components.
%Converting a C/checked-c program to \systemname is a two-step process that involves identifying unsafe/unchecked regions described in \Cref{subsec:identifyregionstosbx} followed by making the \systemname changes described in \Cref{subsec:moveregionstosbx}.  
\subsection{Running Example}
\label{subsec:identifyregionstosbx}

To explain changes required by the \systemname compiler, \Cref{lst:comb} shows the C code of the redacted version of a simple network server with~\code{server_loop} as its entry point (\entrypoint).
The server runs in a loop and calls~\code{handle_request}, which handles a network request.
The function~\code{handle_request} reads data from the socket through~\code{read_msg} and based on the first byte, either~\code{process_req1} or~\code{process_req2} is called to handle the request.

\myparagraph{The Vulnerability}
There is an arbitrary memory write vulnerability (indicated by~\realbug) in~\code{process_req1} because of using~\code{i} as an index into the array~\code{msg} without any sanity check.
The variable~\code{i} can take any integer value as it is parsed from~\code{msg}, whose content is read from socket in~\code{read_msg} indicated by~\rootcause.

\myparagraph{Goal} 
The developer's goal is to partition the code in~\lst{lst:comb} so that spatial memory vulnerabilities do not affect the other part of the program.
Ideally, the developer can convert the entire code to \checkedc so that we achieve full spatial memory safety.
However, there might be considerable conversion efforts in \checkedc.
For instance,~\code{void*} pointers are not directly supported by \checkedc.
Consequently, the developer needs to convert functions using~\code{void*} pointers into generic versions -- this could be tedious.
To handle this, the developer can do a best-effort conversion and annotate only a few pointers~\eg by using an automated conversion tool such as~\threec{} which annotates few pointers as shown in~\lst{lst:initialconv}.
However, as shown in~\sect{subsec:nosafetyagsintuncheckedcode}, $\umode$ region code can also affect the safety of checked pointers.
%\aravind{Fix the running example code with the annotations according to the implementation.}

\subsection{\systemname Annotations}
\label{subsec:moveregionstosbx}
%\myparagraph{Using tainted types}
To overcome the above difficulty, The developer marks risky functions with unchecked pointers,~\ie~\code{read_msg} and~\code{process_req1} as~\code{tainted} as shown in~\lst{lst:humantaint} indicated by~\useradded by using with \systemname{},
 and results in the partially annotated program with checked and tainted types~\ie~\Cref{lst:initialconv,lst:humantaint} atop of~\lst{lst:comb}.
The initial tainted functions might require other pointers to be marked as tainted according to our typing rules (\sect{sec:typechecking}).
The developer uses our type checker to identify the additional required annotations (\usermods) and adds them as shown in~\lst{lst:humanadjust}.
The resulting well-typed program as shown in~\lst{lst:final} is passed to our source level program partitioner along with certain configuration parameters of the target sandbox.

\subsection{Partitioning}
Our partitioner splits the provided program into two sets of source files with the necessary source changes required to communicate with sandboxed code.
These sets of source files are compiled with the corresponding compilers to get the corresponding object files.
The \cregion object file has the necessary runtime checks enforcing~\systemname{} guarantees.
The~\ucregion object file is produced according to the corresponding sandbox mechanism.
Finally, these two object files are linked along with the necessary sandbox libraries to produce the final executable such that all the tainted functions are executed in a sandbox (\ucregion) and the rest of the functions as regular code (\cregion).

%newusecase.tex


