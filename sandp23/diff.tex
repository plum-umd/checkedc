%DIF 1a1-3
%DIF LATEXDIFF DIFFERENCE FILE
%DIF DEL old.tex   Mon Jan 17 08:18:37 2022
%DIF ADD new.tex   Mon Jan 17 08:22:48 2022
\newif\iftr\trfalse %DIF > 
 %DIF > 
 %DIF > 
%DIF -------
\documentclass[conference]{IEEEtran}

\makeatletter
\def\endthebibliography{\def\@noitemerr{\@latex@warning{Empty `thebibliography' environment}}\endlist
}
\makeatother

\IEEEpeerreviewmaketitle

\usepackage{filecontents}
\usepackage[noadjust]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{ebproof}
\usepackage{todonotes}
\usepackage{amsfonts}
\usepackage{algorithmic}
\usepackage{textcomp}
\usepackage{mathpartir}
\usepackage{color}
\usepackage{xcolor}
\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}

\usepackage{subcaption} \usepackage{epsfig}
\usepackage{listings}
\usepackage[override]{cmtt}
\usepackage{graphicx}
\usepackage{balance}
\usepackage{xspace}
\usepackage{booktabs}
\usepackage{url}
\usepackage{xparse}
\usepackage{enumitem}
\usepackage{tikz}
\usetikzlibrary{chains,fit,shapes,positioning,calc,arrows.meta,shapes.arrows}

\usepackage[numbers]{natbib}
\bibliographystyle{plainnat}


\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
%DIF 44c47
%DIF <   numbers=left,
%DIF -------
  breakatwhitespace, numbers=left, %DIF > 
%DIF -------
  xleftmargin=\parindent,
  language=C,
  columns=flexible,      
  showstringspaces=false,
  basicstyle=\small\sffamily,
%DIF 50c53
%DIF <   otherkeywords={uint},
%DIF -------
  otherkeywords={uint,uintptr_t,let,assert}, %DIF > 
%DIF -------
  literate={{<-}{{$\leftarrow\,$}}2
            {->}{{$\rightarrow\,$}}2
            {<=}{{$\leq\,$}}2},
  numberstyle=\tiny\rmfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue!80!black},
}
\lstset{language=C,style=customc}

\newenvironment{DIFnomarkup}{}{}
\newcommand{\myparagraph}[1]{\textbf{#1}.\xspace}

\newcommand{\code}[1]{\lstinline|#1|}
%DIF 65d68
%DIF < %\newcommand{\ignore}[1]{{}}
%DIF -------
\newcommand{\kwchecked}{\lstinline|\_Checked|}
\newcommand{\kwunchecked}{\lstinline|\_Unchecked|}
\newcommand{\kwdynamiccheck}{\lstinline|\_Dynamic\_check|}

\newcommand{\var}[1]{#1}
\newcommand{\Arrayptr}[1]{\lstinline|_Array_ptr<|{#1}\lstinline|>|}
\newcommand{\ArrayptrT}{\Arrayptr{$\tau$}}
\newcommand{\Ptr}[1]{\lstinline|_Ptr<|{#1}\lstinline|>|}
\newcommand{\PtrName}{\lstinline|_Ptr|}
\newcommand{\PtrT}{\Ptr{$\tau$}}
\newcommand{\Ntarrayptr}[1]{\lstinline|_Nt_array_ptr<|{#1}\lstinline|>|}
\newcommand{\NtarrayptrT}{\Ntarrayptr{$\tau$}}
\newcommand{\Checkedarr}[2]{{#1}~\lstinline|_Checked[|{#2}\lstinline|]|}
\newcommand{\CheckedarrT}[1]{\Checkedarr{$\tau$}{#1}}

\newif\ifsubmit\submitfalse

\ifsubmit
\newcommand{\mwh}[1]{}
\newcommand{\ashe}[1]{}
\newcommand{\dtarditi}[1]{}
\newcommand{\dvh}[1]{}
\newcommand{\leo}[1]{}
\newcommand{\liyi}[1]{}
\newcommand{\yiyun}[1]{}
%DIF 91a93-94
\newcommand{\review}[1]{} %DIF > 
 %DIF > 
%DIF -------
\else
\newcommand{\mwh}[1]{\textcolor{red}{Mike: #1}}
\newcommand{\dtarditi}[1]{\textcolor{purple}{David: #1}}
\newcommand{\leo}[1]{\textcolor{green!80!blue}{Leo: #1}}
%DIF 95c99
%DIF < \newcommand{\liyi}[1]{\textbf{\textcolor{orange}{[ Liyi: #1 ]}}}
%DIF -------
\newcommand{\liyi}[1]{\textbf{\textcolor{orange}{Liyi: #1}}} %DIF > 
%DIF -------
\newcommand{\yiyun}[1]{\textcolor{cyan}{Yiyun: #1}}
\newcommand{\dvh}[1]{\textcolor{magenta}{DVH: #1}}
%DIF 98a102-103
\newcommand{\review}[1]{\textbf{\textcolor{blue}{Review: #1}}} %DIF > 
 %DIF > 
%DIF -------
\fi

\newcommand{\lang}{\textsc{CoreChkC}\xspace}
\newcommand{\elang}{\textsc{CoreC}\xspace}

\newtheorem{defi}{Definition}
\newtheorem{thm}{Theorem}
\newtheorem{prop}{Proposition}


%DIF 108c114-115
%DIF < \newcommand{\CoreChkC}{\textsc{CoreChkC}\xspace}
%DIF -------
\newcommand{\CoreC}{\elang} %DIF > 
\newcommand{\CoreChkC}{\lang} %DIF > 
%DIF -------
\newcommand{\checkedc}{\text{Checked C}\xspace}

 \newcommand{\rulelab}[1]{{\small \textsc{#1}}}
\newcommand{\steps}{\ensuremath{\longrightarrow}}
\newcommand{\tbool}{\texttt{bool}}
\newcommand{\tsizeof}{\texttt{sizeof}}
\newcommand{\vbool}{\texttt{Bool}}
\newcommand{\verror}{\texttt{Error}}
\newcommand{\vval}{\mathpzc{val}}
\newcommand{\tfixed}{\texttt{fixedp}}
\newcommand{\tnat}{\texttt{nat}}
\newcommand{\tarr}[2]{\texttt{array}~{#1}~{#2}}
\newcommand{\econst}[2]{({#1}){#2}}
\newcommand{\eindex}[2]{{#1}\texttt{[}{#2}\texttt{]}}
\newcommand{\sassign}[4]{{#1} \leftarrow {#3}~{#2}~{#4}}
\newcommand{\ssassign}[3]{{#1} \xleftarrow{#2} {#3}}
\newcommand{\sif}[3]{\texttt{if}~{#1}~{#2}~{#3}}
\newcommand{\sfor}[3]{\texttt{for}~{#1}~{#2}~{#3}}
\newcommand{\scall}[3]{{#1}\leftarrow {#2}~{#3}}
\newcommand{\sseq}[2]{{#1}\,\texttt{;}\,{#2}}
\newcommand{\sinv}[1]{\texttt{inv}~{#1}}
\newcommand{\inst}[3][ ]{\texttt{#2}^{#1}~{#3}}
\newcommand{\insttwo}[4][ ]{\texttt{#2}^{#1}~{#3}~{#4}}
\newcommand{\instthree}[5][ ]{\texttt{#2}^{#1}~{#3}~{#4}~{#5}}
\newcommand{\iskip}[1]{\inst{ID}{#1}}
\newcommand{\inot}[1]{\inst{X}{#1}}
\newcommand{\ictrl}[2]{\insttwo{CU}{#1}{#2}}
\newcommand{\irz}[3][ ]{\insttwo[#1]{RZ}{#2}{#3}}
\newcommand{\isr}[3][ ]{\insttwo[#1]{SR}{#2}{#3}}
\newcommand{\icnot}[2]{\insttwo{CNOT}{#1}{#2}}
\newcommand{\ilshift}[1]{\inst{Lshift}{#1}}
\newcommand{\irshift}[1]{\inst{Rshift}{#1}}
\newcommand{\irev}[1]{\inst{Rev}{#1}}
\newcommand{\iqft}[2][ ]{\inst[#1]{QFT}{#2}}
\newcommand{\ihad}[1]{\inst{H}{#1}}

\newcommand{\iseq}[2]{{#1}\,\texttt{;}\,{#2}}
\newcommand{\inval}[2]{\insttwo{Nval}{#1}{#2}}
\newcommand{\ihval}[3]{\instthree{Hval}{#1}{#2}{#3}}
\newcommand{\iqval}[2]{\insttwo{Qval}{#1}{#2}}

\newcommand{\instr}{\iota}

\newcommand{\kw}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\subtype}[2]{\ensuremath{\vdash{#1}\prec{#2}}}
\newcommand{\estrlen}[1]{\ensuremath{\kw{strlen}({#1})}}
\newcommand{\estrlentext}{\ensuremath{\kw{strlen}}}

\newcommand{\tarray}[3]{\tarrayb{({#1},{#2})}{#3}}
\newcommand{\tarrayb}[2]{\ensuremath{[{#1}~{#2}]}}
\newcommand{\tntarray}[3]{\tntarrayb{({#1},{#2})}{#3}}
\newcommand{\tntarrayb}[2]{\tarrayb{#1}{#2}_{nt}}
\newcommand{\tallarrayb}[2]{\ensuremath{[{#1}~{#2}]_{\kappa}}}
\newcommand{\tallarraybc}[2]{\ensuremath{[{#1}~{#2}]_{\textcolor{cyan}{\kappa}}}}

\newcommand{\tallarray}[3]{\tallarrayb{({#1},{#2})}{#3}}

\newcommand{\tptr}[2]{\ensuremath{\mathtt{ptr}^{#2}~{#1}}}
\newcommand{\tntptr}[4]{\ensuremath{[({#1},{#2})~{#3}]^{#4}_{nt}*}}


\newcommand{\tarrayptr}[4]{{\tptr{\tarray{#1}{#2}{#3}}{#4}}}
\newcommand{\tntarrayptr}[4]{{\tptr{\tntarray{#1}{#2}{#3}}{#4}}}
\newcommand{\tallarrayptr}[4]{{\tptr{\tallarray{#1}{#2}{#3}}{#4}}}


\newcommand{\tgarray}[4]{\ensuremath{\mathtt{#1}~{#2}~{#3}~{#4}}}
\newcommand{\tstruct}[1]{\ensuremath{\kw{struct}~{#1}}}

\newcommand{\evalue}[2]{\ensuremath{{#1}\!:\!{#2}}}

\newcommand{\emalloc}[1]{\ensuremath{\kw{malloc}({#1})}}
\newcommand{\emalloctext}{\ensuremath{\kw{malloc}}}
\newcommand{\ecall}[2]{\ensuremath{{#1}({#2})}}
\newcommand{\ret}[3]{\ensuremath{\kw{ret}({#1},{#2},{#3})}}
\newcommand{\rettext}{\ensuremath{\kw{ret}}}
\newcommand{\ecast}[2]{\ensuremath{\kw{(}{#1}\kw{)}{#2}}}
\newcommand{\edyncast}[2]{\ensuremath{\langle{#1}\rangle{#2}}}
\newcommand{\edcast}[2]{\ensuremath{\kw{(D},{#1}\kw{)}{#2}}}
\newcommand{\elet}[3]{\ensuremath{\kw{let}~#1\, \texttt{=}\, #2~\kw{in}\;{#3}}}
\newcommand{\elettext}{\ensuremath{\kw{let}}}
\newcommand{\ebinop}[2]{\ensuremath{#1 \plus #2}}
\newcommand{\eassign}[2]{\ensuremath{\texttt{*}{#1}\,\texttt{=}\, {#2}}}
\newcommand{\eassignstack}[2]{\ensuremath{{#1}\,\texttt{=}\, {#2}}}
\newcommand{\efield}[2]{\ensuremath{{#1}\kw{\rightarrow}{#2}}}
\newcommand{\estar}[1]{\ensuremath{\texttt{*}{#1}}}
\newcommand{\eamper}[2]{\ensuremath{\kw{\&}{#1}\kw{\rightarrow}{#2}}}
\newcommand{\eunchecked}[1]{\ensuremath{\kw{unchecked}\;{#1}}}
\newcommand{\euncheckedtext}{\ensuremath{\kw{unchecked}}}
\newcommand{\eif}[3]{\ensuremath{\kw{if\;}(#1)\;{#2}\;\kw{else}\;{#3}}}
\newcommand{\eifa}[3]{\ensuremath{\kw{IF\;}(#1)\;{#2}\;\kw{ELSE}\;{#3}}}
\newcommand{\eifatext}{\ensuremath{\kw{IF}}}

\newcommand{\eiftext}{\ensuremath{\kw{if}}}
\newcommand{\ethentext}{\ensuremath{\kw{then}}}
\newcommand{\eelse}{\ensuremath{\kw{else}}}
\newcommand{\ebreak}{\ensuremath{\kw{break}}}
\newcommand{\ebounds}{\ensuremath{\kw{bounds}}}
\newcommand{\enull}{\ensuremath{\kw{null}}}
\newcommand{\hole}{\ensuremath{\Box}}
\newcommand{\defscope}{\sigma}
\newcommand{\wf}[1]{wf \, #1}
\newcommand{\tint}{\ensuremath{\mathtt{int}}}
\newcommand{\efor}{\ensuremath{\mathtt{for}}}
\newcommand{\ewhile}{\ensuremath{\mathtt{while}}}
\newcommand{\etrue}{\ensuremath{\mathtt{true}}}
\newcommand{\efalse}{\ensuremath{\mathtt{false}}}
\newcommand{\edplus}{\ensuremath{\texttt{++}}}
\newcommand{\edminus}{\ensuremath{\texttt{--}}}

\newcommand{\ememcpy}{\ensuremath{\mathtt{memcpy}}}
\newcommand{\ereturn}{\ensuremath{\mathtt{return}}}
\newcommand{\emain}{\ensuremath{\mathtt{main}}}
\newcommand{\estrcat}{\ensuremath{\mathtt{strcat}}}
\newcommand{\estrcatbad}{\ensuremath{\mathtt{strcat\_b}}}
\newcommand{\heap}{\ensuremath{\mathpzc{H}}}
\newcommand{\eret}[3]{\ensuremath{\kw{ret}({#1},{#2},{#3})}}
\newcommand{\erettext}{\ensuremath{\kw{ret}}}

\newcommand{\plus}{\mathbin{\texttt{+}}}

\newcommand{\fv}{\mathit{FV}}
\newcommand{\dom}{\mathit{dom}}

\newcommand{\fm}{\mathit{FM}}
\newcommand{\size}{\mathit{size}}

\newcommand{\cmode}{\texttt{c}}
\newcommand{\umode}{\texttt{u}}
\newcommand{\bvar}{\ensuremath{\beta}}
\newcommand{\mode}{\textit{mode}}

\newcommand{\cextend}[4]{\ensuremath{#4 = ~ \vdash_{extend} #1, #2, #3}}
\newcommand{\fresh}{\ensuremath{\kw{fresh}}}
\newcommand{\echecknull}[3]{\ensuremath{#3 = ~\vdash_{null}#1, #2}}
\newcommand{\echeckboundsdyn}[5]{\ensuremath{#5 = ~ \vdash_{boundsD}#1, #2, #3, #4}}
\newcommand{\echeckbounds}[5]{\ensuremath{#5 = ~ \vdash_{boundsR}#1, #2, #3, #4}}
\newcommand{\echeckboundsw}[5]{\ensuremath{#5 = ~ \vdash_{boundsW}#1, #2, #3, #4}}
\newcommand{\esizeof}[1]{\ensuremath{\kw{sizeof}(#1)}}
\newcommand{\ewidenstrlen}[5]{\ensuremath{#5 = ~ \vdash_{widenstr}#1, #2, #3, #4}}
\newcommand{\ewidenderef}[4]{\ensuremath{#4 = ~ \vdash_{widenderef}#1, #2, #3}}
\newcommand{\eleq}[2]{\ensuremath{#1 \leq #2}}




\newcommand{\rboundle}[2]{\ensuremath{\vdash_{bounds}#1 \leq #2}}








\def\codesize{\normalsize}
\definecolor{programs}{gray}{0.1}

\lstset{
  basicstyle=\ttfamily,  
}

\makeatletter
\lst@CCPutMacro
    \lst@ProcessOther {"22}{\lst@ifupquote \textquotedbl
                                     \else \char34\relax \fi}
    \@empty\z@\@empty
\makeatother

\lstloadlanguages{C}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
%DIF PREAMBLE EXTENSION ADDED BY LATEXDIFF
%DIF UNDERLINE PREAMBLE %DIF PREAMBLE
\RequirePackage[normalem]{ulem} %DIF PREAMBLE
\RequirePackage{color}\definecolor{RED}{rgb}{1,0,0}\definecolor{BLUE}{rgb}{0,0,1} %DIF PREAMBLE
\providecommand{\DIFadd}[1]{{\protect\color{blue}\uwave{#1}}} %DIF PREAMBLE
\providecommand{\DIFdel}[1]{{\protect\color{red}\sout{#1}}}                      %DIF PREAMBLE
%DIF SAFE PREAMBLE %DIF PREAMBLE
\providecommand{\DIFaddbegin}{} %DIF PREAMBLE
\providecommand{\DIFaddend}{} %DIF PREAMBLE
\providecommand{\DIFdelbegin}{} %DIF PREAMBLE
\providecommand{\DIFdelend}{} %DIF PREAMBLE
\providecommand{\DIFmodbegin}{} %DIF PREAMBLE
\providecommand{\DIFmodend}{} %DIF PREAMBLE
%DIF FLOATSAFE PREAMBLE %DIF PREAMBLE
\providecommand{\DIFaddFL}[1]{\DIFadd{#1}} %DIF PREAMBLE
\providecommand{\DIFdelFL}[1]{\DIFdel{#1}} %DIF PREAMBLE
\providecommand{\DIFaddbeginFL}{} %DIF PREAMBLE
\providecommand{\DIFaddendFL}{} %DIF PREAMBLE
\providecommand{\DIFdelbeginFL}{} %DIF PREAMBLE
\providecommand{\DIFdelendFL}{} %DIF PREAMBLE
\newcommand{\DIFscaledelfig}{0.5}
%DIF HIGHLIGHTGRAPHICS PREAMBLE %DIF PREAMBLE
\RequirePackage{settobox} %DIF PREAMBLE
\RequirePackage{letltxmacro} %DIF PREAMBLE
\newsavebox{\DIFdelgraphicsbox} %DIF PREAMBLE
\newlength{\DIFdelgraphicswidth} %DIF PREAMBLE
\newlength{\DIFdelgraphicsheight} %DIF PREAMBLE
% store original definition of \includegraphics %DIF PREAMBLE
\LetLtxMacro{\DIFOincludegraphics}{\includegraphics} %DIF PREAMBLE
\newcommand{\DIFaddincludegraphics}[2][]{{\color{blue}\fbox{\DIFOincludegraphics[#1]{#2}}}} %DIF PREAMBLE
\newcommand{\DIFdelincludegraphics}[2][]{% %DIF PREAMBLE
\sbox{\DIFdelgraphicsbox}{\DIFOincludegraphics[#1]{#2}}% %DIF PREAMBLE
\settoboxwidth{\DIFdelgraphicswidth}{\DIFdelgraphicsbox} %DIF PREAMBLE
\settoboxtotalheight{\DIFdelgraphicsheight}{\DIFdelgraphicsbox} %DIF PREAMBLE
\scalebox{\DIFscaledelfig}{% %DIF PREAMBLE
\parbox[b]{\DIFdelgraphicswidth}{\usebox{\DIFdelgraphicsbox}\\[-\baselineskip] \rule{\DIFdelgraphicswidth}{0em}}\llap{\resizebox{\DIFdelgraphicswidth}{\DIFdelgraphicsheight}{% %DIF PREAMBLE
\setlength{\unitlength}{\DIFdelgraphicswidth}% %DIF PREAMBLE
\begin{picture}(1,1)% %DIF PREAMBLE
\thicklines\linethickness{2pt} %DIF PREAMBLE
{\color[rgb]{1,0,0}\put(0,0){\framebox(1,1){}}}% %DIF PREAMBLE
{\color[rgb]{1,0,0}\put(0,0){\line( 1,1){1}}}% %DIF PREAMBLE
{\color[rgb]{1,0,0}\put(0,1){\line(1,-1){1}}}% %DIF PREAMBLE
\end{picture}% %DIF PREAMBLE
}\hspace*{3pt}}} %DIF PREAMBLE
} %DIF PREAMBLE
\LetLtxMacro{\DIFOaddbegin}{\DIFaddbegin} %DIF PREAMBLE
\LetLtxMacro{\DIFOaddend}{\DIFaddend} %DIF PREAMBLE
\LetLtxMacro{\DIFOdelbegin}{\DIFdelbegin} %DIF PREAMBLE
\LetLtxMacro{\DIFOdelend}{\DIFdelend} %DIF PREAMBLE
\DeclareRobustCommand{\DIFaddbegin}{\DIFOaddbegin \let\includegraphics\DIFaddincludegraphics} %DIF PREAMBLE
\DeclareRobustCommand{\DIFaddend}{\DIFOaddend \let\includegraphics\DIFOincludegraphics} %DIF PREAMBLE
\DeclareRobustCommand{\DIFdelbegin}{\DIFOdelbegin \let\includegraphics\DIFdelincludegraphics} %DIF PREAMBLE
\DeclareRobustCommand{\DIFdelend}{\DIFOaddend \let\includegraphics\DIFOincludegraphics} %DIF PREAMBLE
\LetLtxMacro{\DIFOaddbeginFL}{\DIFaddbeginFL} %DIF PREAMBLE
\LetLtxMacro{\DIFOaddendFL}{\DIFaddendFL} %DIF PREAMBLE
\LetLtxMacro{\DIFOdelbeginFL}{\DIFdelbeginFL} %DIF PREAMBLE
\LetLtxMacro{\DIFOdelendFL}{\DIFdelendFL} %DIF PREAMBLE
\DeclareRobustCommand{\DIFaddbeginFL}{\DIFOaddbeginFL \let\includegraphics\DIFaddincludegraphics} %DIF PREAMBLE
\DeclareRobustCommand{\DIFaddendFL}{\DIFOaddendFL \let\includegraphics\DIFOincludegraphics} %DIF PREAMBLE
\DeclareRobustCommand{\DIFdelbeginFL}{\DIFOdelbeginFL \let\includegraphics\DIFdelincludegraphics} %DIF PREAMBLE
\DeclareRobustCommand{\DIFdelendFL}{\DIFOaddendFL \let\includegraphics\DIFOincludegraphics} %DIF PREAMBLE
%DIF LISTINGS PREAMBLE %DIF PREAMBLE
\RequirePackage{listings} %DIF PREAMBLE
\RequirePackage{color} %DIF PREAMBLE
\lstdefinelanguage{DIFcode}{ %DIF PREAMBLE
%DIF DIFCODE_UNDERLINE %DIF PREAMBLE
  moredelim=[il][\color{red}\sout]{\%DIF\ <\ }, %DIF PREAMBLE
  moredelim=[il][\color{blue}\uwave]{\%DIF\ >\ } %DIF PREAMBLE
} %DIF PREAMBLE
\lstdefinestyle{DIFverbatimstyle}{ %DIF PREAMBLE
	language=DIFcode, %DIF PREAMBLE
	basicstyle=\ttfamily, %DIF PREAMBLE
	columns=fullflexible, %DIF PREAMBLE
	keepspaces=true %DIF PREAMBLE
} %DIF PREAMBLE
\lstnewenvironment{DIFverbatim}{\lstset{style=DIFverbatimstyle}}{} %DIF PREAMBLE
\lstnewenvironment{DIFverbatim*}{\lstset{style=DIFverbatimstyle,showspaces=true}}{} %DIF PREAMBLE
%DIF END PREAMBLE EXTENSION ADDED BY LATEXDIFF

\begin{document}

\DIFaddbegin \iftr
\title{\DIFadd{A Formal Model of Checked C }{\large \DIFadd{(Extended Version)}}}
\else
\DIFaddend \title{A Formal Model of Checked C}
\DIFaddbegin \fi
\DIFaddend 





%DIF <  \ignore{
%DIF <  \author{\IEEEauthorblockN{1\textsuperscript{st} Leonidas Lampropoulos}
%DIF <  \IEEEauthorblockA{\textit{Department of Computer Science} \\
%DIF <  \textit{University of Maryland}\\
%DIF <  llampro@cs.umd.edu}
%DIF <  \and
%DIF <  \IEEEauthorblockN{1\textsuperscript{st} Michael Hicks}
%DIF <  \IEEEauthorblockA{\textit{Department of Computer Science} \\
%DIF <  \textit{University of Maryland}\\
%DIF <  llampro@cs.umd.edu}
%DIF <  }
%DIF <  \author{Leonidas Lampropoulos \and
%DIF <  Michael Hicks}
%DIF <  }
\DIFaddbegin \author{\DIFadd{Liyi Li, Yiyun Liu$^\dagger$, Deena L. Postol, Leonidas
  Lampropoulos, David Van Horn, and Michael Hicks}\\
  \DIFadd{University of Maryland $\quad\quad ~^\dagger$University of Pennsylvania}}





\DIFaddend \maketitle

\begin{abstract}


  We present a formal model of Checked C, a dialect of C
  that aims to enforce spatial memory safety. Our model pays particular
  attention to the semantics of dynamically sized, potentially null-terminated
  arrays.
We formalize this model in Coq, and prove that any spatial memory
  safety errors can be \emph{blamed} on portions of the program
  labeled \emph{unchecked}; this is a Checked C feature that supports
  incremental porting and backward compatibility.
\DIFdelbegin \DIFdel{Our modeldevelops an operational semantics that uses fat pointers to
  guarantee spatial
  safety. However, we formalize a compilation scheme
  that can yield thin pointers, with bounds information managed using
  inserted code. We show that the }\DIFdelend \DIFaddbegin \DIFadd{While our model's operational semantics uses annotated
  (``fat'') pointers to enforce spatial
  safety, we show that such annotations can be safely erased:
    Using PLT Redex we formalize an executable
    version of our model and a compilation procedure from it to an untyped C-like
    language, and use randomized testing to
    validate that }\DIFaddend generated code faithfully simulates the original.
Finally, we \DIFdelbegin \DIFdel{build an executable version of our model in PLT Redex, 
  and use }\DIFdelend \DIFaddbegin \DIFadd{develop }\DIFaddend a custom random generator 
  for well-typed and almost-well-typed terms \DIFdelbegin \DIFdel{to find
  }\DIFdelend \DIFaddbegin \DIFadd{in our Redex model, and
  use it to search for
  }\DIFaddend inconsistencies between our model and the Clang Checked C
  implementation. We find these steps to be a useful way to co-develop a language
  (Checked C is still in development) and a core model of it.
\end{abstract}

\DIFaddbegin \iftr
\bigskip
\begin{small}
 \DIFadd{This is an extended version of a paper that
  appears at the 2022 Computer Security Foundations Symposium.
}\end{small}
\fi









\DIFaddend \section{Introduction}\label{sec:intros}





The C programming language remains extremely popular despite the
emergence of new, modern languages. Unfortunately, C programs lack
spatial memory safety, which makes them susceptible to a host
of devastating vulnerabilities, including buffer overflows and
out-of-bounds reads/writes. Despite their long history, buffer
overflows and other spatial safety violations are among the most
prevalent and dangerous vulnerabilities on the Internet today \cite{Zeng:2013:SRF:2534766.2534798}.



Several industrial and research efforts---including CCured~\cite{Necula2005},
Softbound~\cite{softbound}, and ASAN~\cite{Serebryany2012}---have
explored means to compile C programs 
to automatically enforce spatial safety. These
approaches all impose performance overheads that are deemed too high for
use in deployment. Recently, Microsoft introduced \checkedc, an
open-source extension to C with new types and
annotations whose use can ensure a program’s spatial
safety~\cite{Elliott2018}. Importantly, \checkedc supports development that is
incremental and compositional. Code regions (e.g.,
functions or whole files) designated as \emph{checked} are sure to enforce
spatial safety, a property which is preserved via composition with
other checked regions. But not all regions must be checked: Checked
C's annotated \emph{checked pointers} are binary-compatible with legacy pointers, and
may coexist in the same code, which permits a deliberate (and
semi-automated) refactoring process. Parts of the FreeBSD kernel have
been successfully ported to \checkedc~\cite{duanrefactoring}, and overall, performance
overhead seems low enough for practical deployment.

While \checkedc promises to enforce spatial safety, we might wonder
whether its design and implementation deliver on this promise, or even
what ``spatial safety'' means when a program contains both checked and
unchecked code. In prior work, \citet{ruef18checkedc-incr} developed a core
formalization of \checkedc and with it proved \DIFdelbegin \DIFdel{that }\DIFdelend \DIFaddbegin \DIFadd{a }\DIFaddend \emph{\DIFdelbegin \DIFdel{checked code cannot 
  be blamed}%DIFDELCMD < \MBLOCKRIGHTBRACE%%%
\DIFdel{: any }\DIFdelend \DIFaddbegin \DIFadd{soundness}} \DIFadd{theorem for
checked code: any stuck (i.e., ill-defined)
state reached by a well-typed program amounts to a }\DIFaddend spatial safety
violation\DIFdelbegin \DIFdel{can only }\DIFdelend \DIFaddbegin \DIFadd{; such a state can always }\DIFaddend be attributed to\DIFaddbegin \DIFadd{, i.e., 
}\emph{\DIFadd{blamed on}}\DIFadd{, the execution of }\DIFaddend code that is not in a checked
region. While their work is a good start, 
it fails to model important aspects of \checkedc's functionality,
particularly those involving pointers to arrays. In this paper, we
cover this gap, making three main contributions.

\myparagraph{Dynamically bounded and null-terminated arrays}
Our first contribution is a core formalism called \lang, which extends
\citet{ruef18checkedc-incr} with several new features, most notably 
\emph{dynamically bounded arrays} (Section~\ref{sec:formal}). 
Dynamically bounded arrays are those whose size is
known only at run time, as designated by in-scope variables using
dependent types. A pointer's accessible memory is bounded both above
and below, to admit arbitrary pointer arithmetic.

\lang also models
\emph{null-terminated} arrays, a kind of dynamically bounded array
whose upper bound
defines the array's \emph{minimum} length---additional space is available 
up to a null terminator. For example, the \checkedc type
\lstinline{nt_array_ptr<char> p:count(n)} says that
\lstinline{p} has length \emph{at least} \lstinline{n} (excluding the
null terminator), but further capacity is present if \lstinline|p[n]| is not null. \checkedc (and \lang) supports flow-sensitive
\emph{bounds widening}: statements of the form \lstinline|if (*p) | $s$,
where \lstinline{p}'s type is \lstinline{nt_array_ptr<T> count(0)},
typecheck statement $s$ under the assumption that \lstinline{p} has
type \lstinline{nt_array_ptr<T> count(1)}, 
 i.e., one more than it was,
since the character at the current-known length is
non-null. Similarly, the call \lstinline|n = strlen(p)| will widen
\lstinline|p|'s bounds to \lstinline|n|. Subtyping permits treating
null-terminated arrays as normal arrays of the same size (which
does not include, and thereby protects, the null
terminator).\DIFaddbegin \footnote{
    \DIFadd{See Sec.~\ref{sec:related} for a careful comparison of
    }\citet{ruef18checkedc-incr} \DIFadd{and }\lang\DIFadd{.
}}
\DIFaddend 

We prove, in Coq, a blame theorem for \lang.  As far as we are aware,
ours is the first formalized type system and proof of soundness for
pointers to null-terminated arrays with expandable bounds.



\myparagraph{Sound compilation of checked pointers} Our second
contribution is a formalization of bounds-check insertion for array
accesses (Section~\ref{sec:compilation}). Our operational semantics
annotates each pointer with metadata that describes its bounds, and
the assignment and dereference rules have premises to confirm the
access is in bounds. An obvious compilation scheme (taken by
Cyclone~\cite{Jim2002,GrossmanMJHWC02}, CCured~\cite{Necula2005}, and
earlier works) would be to translate annotated pointers to multi-word
objects: one word for the pointer, and 1-2 words to describe its lower
and upper bounds. Inserted checks reference these bounds. While
convenient, such ``fat'' pointers are expensive, and break backward
binary compatibility with legacy pointers.
\DIFdelbegin \DIFdel{We formalize }%DIFDELCMD < \checkedc%%%
\DIFdel{'s
compilation approach, which uses a single machine word for the
pointer, and
  adds checks involving the declared bounds (e. g.,
  in a
dependent type) or additional stack-allocated }\emph{\DIFdel{ghost variables}}
%DIFAUXCMD
\DIFdel{to accommodate bounds widening. We show that the compiled program
}\emph{\DIFdel{simulates}} %DIFAUXCMD
\DIFdel{the original by mechanizing }\DIFdelend \DIFaddbegin 

  \DIFadd{To show that pointer annotations can be safely
  erased, and thus fat pointers are not needed, we formalize a
  translation of }\DIFaddend \lang \DIFdelbegin \DIFdel{and the compilation judgment in }\DIFdelend \DIFaddbegin \DIFadd{to }\elang\DIFadd{, which is an 
  untyped version of }\lang \DIFadd{that drops metadata annotations, and
  lacks bounds/null checks in the semantics rules. Instead,
  the compilation process inserts null/bounds checks explicitly, leveraging
  compile-time type information. While we do not definitively prove
  it, we provide strong evidence that compilation is correct. We use }\DIFaddend PLT
  Redex~\cite{pltredex} \DIFdelbegin \DIFdel{, and use its random testing 
feature to give confidence that simulation holds. }\DIFdelend \DIFaddbegin \DIFadd{to mechanize (a generalization of) }\lang\DIFadd{, 
  }\elang\DIFadd{, and compilation between the two, and we use randomized testing 
to validate that the compiled program }\emph{\DIFadd{simulates}} \DIFadd{the
original. In addition to demonstrating the technical point that metadata
annotations in the }\lang \DIFadd{formalism do not necessitate fat pointers,
compilation also sheds light on the actual Checked C compilation
process. 
}\DIFaddend 


As far as we are aware, \lang is the first formalism to cleanly
separate bounds-checking compilation from the core semantics; prior
work\DIFaddbegin \DIFadd{~}\cite{Feng2006,Condit2007} \DIFaddend merged the two, conflating
\emph{meaning} with \emph{mechanism}\DIFdelbegin \DIFdel{~}%DIFDELCMD < \cite{Feng2006,Condit2007}%%%
\DIFdelend . In carrying out the
formalization, we discovered that our compilation approach \DIFaddbegin \DIFadd{for
null-terminated array pointers }\DIFaddend is more expressive than that proposed
in the Checked C specification~\cite{checkedc}
(Section~\ref{sec:disc}); we would not have discovered this
improvement had we not separated checks from semantics.






\myparagraph{Model-based randomized testing} Our third and final
contribution is a strategy and implementation of model-based
randomized testing (Section~\ref{sec:evaluation}).  To check the
correctness of our formal model, we compare the behavior between the
existing Clang \checkedc implementation and our own model. This is
done by a conversion tool that converts expressions from \lang into
actual \checkedc code that can be compiled by the Clang \checkedc
compiler. We build a random generator of programs largely based on the
typing rules of \lang and make sure that, both statically and
dynamically, \lang and Clang Checked C are consistent after
conversion.  This helped rapidly prototype the model and uncovered
several issues in the Checked C compiler.

\DIFaddbegin \begin{figure}
\includegraphics[width=0.5\textwidth]{relationship.pdf}
\caption{
    \lang \DIFaddFL{models' relationship to }\checkedc
}
  \label{fig:model-relation}
\end{figure}

  \myparagraph{Summary Visualization} \DIFadd{The
  relationship among our contributions is visualized in
  Fig.~\ref{fig:model-relation}. With the Coq model of }\lang \DIFadd{we prove
  soundness (and with it, }\emph{\DIFadd{blame}}\DIFadd{) of the }\checkedc \DIFadd{type system
  and semantics. With the Redex model, we use randomized testing to
  validate both type soundness and compilation correctness, where the
  latter shows how compilation need not output fat pointers despite
  the use of pointer annotations in the }\lang \DIFadd{model. The Redex }\lang
  \DIFadd{model is also the basis of randomized testing of the correctness of
  the }\checkedc \DIFadd{compiler implementation, both its type checker and the
  semantics of its emitted code, at least for the subset of the
  language in the Redex model. The Redex model's syntax
  is slightly richer than the Coq version: conditional guards and
  function arguments may be arbitrary expressions, where the Coq
  version limits them to constants and variables, making handling of
  dependent types a bit simpler. We find a useful synergy between the
  Coq and Redex models for carrying out a language development. The
  richer, executable Redex model is useful for quickly modeling and
  testing new features, both formally and against a real
  implementation. Once solidified, new features can be added to the
  Coq model (perhaps somewhat simplified) for final proofs of
  correctness.
}

\DIFaddend We begin with a review of \checkedc (Section~\ref{sec:overview}),
present our main contributions
(Sections~\ref{sec:formal}--\ref{sec:evaluation}), and conclude with a
discussion of 
related and future work (Sections~\ref{sec:related},
\ref{sec:conclude}). \DIFaddbegin \DIFadd{All code and proof artifacts (both for Coq and
Redex) can be found at }\url{https://github.com/plum-umd/checkedc}\DIFadd{. 
}\DIFaddend 







 
\section{\checkedc Overview}\label{sec:overview}

This section describes Checked C, which extends C with new pointer
types and annotations that ensure spatial safety. More
details can be found in a prior overview~\cite{Elliott2018} or the
full specification~\cite{checkedc}.
Checked C is implemented as a fork of Clang/LLVM and is freely
available.\footnote{\url{https://github.com/Microsoft/checkedc-clang}}

\begin{figure}[t]
{\small
  \begin{lstlisting}[xleftmargin=4 mm]
nt_array_ptr<const char>
parse_utf16_hex(nt_array_ptr<const char> s,
                  ptr<uint> result) {
 int x1, x2, x3, x4;
 if (s[0] != 0) { x1 = hex_char_to_int(s[0]);
 if (s[1] != 0) { x2 = hex_char_to_int(s[1]);
 if (s[2] != 0) { x3 = hex_char_to_int(s[2]);
 if (s[3] != 0) { x4 = hex_char_to_int(s[3]);
 if (x1 != -1 && x2 != -1 && x3 != -1 && x4 != -1){
   *result = (uint)((x1<<12)|(x2<<8)|(x3<<4)|x4);
   return s+4;
  ...// several } braces
 } 
 return 0;
}
void parse(nt_array_ptr<const char> s,
            array_ptr<uint> p : count(n), 
            int n) {
 array_ptr<uint> q : bounds(p,p+n) = p;
 while (s && q < p+n) {
   array_ptr<uint> r : count(1) =
     dyn_bounds_cast<array_ptr<uint>>(q,count(1));
   s = parse_utf16_hex(s,r);
   q++;
 }
}
  
\end{lstlisting}

}

\caption{Parsing a string of UTF16 hex characters in \checkedc}
\label{fig:checkedc-example}
\end{figure}





\subsection{Checked Pointer Types}
\checkedc introduces three varieties of \emph{checked pointer}:
\begin{itemize}
\item \code{ptr<}$T$\code{>} types a pointer that is either null or
  points to a single object of type $T$.
\item \code{array_ptr<}$T$\code{>} types a pointer that is either null
  or points to an array of $T$ objects. The array width is defined
  by a \emph{bounds} expression, discussed below.
\item \code{nt_array_ptr<}$T$\code{>} is like
  \code{array_ptr<}$T$\code{>} except that the bounds expression
  defines the \emph{minimum} array width---additional objects may
  be available past the upper bound, up to a null terminator.
\end{itemize}
A bounds expression used with the latter two pointer types has three
forms:
\begin{itemize}
\item \code{count(}$e$\code{)} where $e$ defines the array's
  length. Thus, if pointer $p$ has bounds \code{count(n)} then the
  accessible memory is in the range $[p,p+$\code{n}$]$. Bounds
  expression $e$ must be side-effect free and may only refer to
  variables whose addresses are not taken, or adjacent \code{struct}
  fields.
\item \code{byte_count(}$e$\code{)} is like \code{count}, but
  expresses arithmetic using bytes, no objects; i.e.,
  \code{count(}$e$\code{)} used for \code{array_ptr<}$T$\code{>} is
  equivalent to \code{byte_count(}$e\times\texttt{sizeof}(T)$\code{)}
\item \code{bounds(}$e_l$,$e_h$\code{)} where $e_l$ and $e_h$ are
  pointers that bound the accessible region $[e_l,e_h)$ (the
  expressions are similarly restricted). Bounds
  \code{count(}$e$\code{)} is shorthand for
  \code{bounds(}$p, p + e$\code{)}. This most general form of bounds
  expression is useful for supporting pointer arithmetic.
\end{itemize}
  \DIFaddbegin \DIFadd{Dropping the bounds expression on an }\code{nt_array_ptr} \DIFadd{is equivalent
  to the bounds being }\code{count(0)}\DIFadd{.
}

\DIFaddend The \checkedc compiler will instrument loads and stores of checked
pointers to confirm the pointer is non-null, and the access is within
the specified bounds. For pointers $p$ of type
\code{nt_array_ptr<}$T$\code{>}, such a check could spuriously fail if
the index is past $p$'s specified upper bound, but before the null
terminator. To address this problem, Checked C supports \emph{bounds
  widening}.
If $p$\DIFdelbegin \DIFdel{has bounds expression }%DIFDELCMD < \code{bounds(}%%%
\DIFdel{$e_l$,$e_h$}%DIFDELCMD < \code{)} %%%
\DIFdelend \DIFaddbegin \DIFadd{'s bounds expression is }\code{bounds}\DIFadd{$(e_l$,$e_h)$ }\DIFaddend a program may read from (but not
write to) $e_h$; when the compiler notices that a non-null character
is read at the upper bound, it will extend that bound to $e_h+1$.


\subsection{Example}
\DIFaddbegin \label{sec:example}
\DIFaddend 

Fig.~\ref{fig:checkedc-example} gives an example \checkedc
program.\footnote{Ported from the Parson JSON
parser, \url{https://github.com/kgabis/parson}} 
The function \code{parse_utf16_hex} on lines 1-17 takes \DIFdelbegin \DIFdel{as its argument
}\DIFdelend \DIFaddbegin \DIFadd{a 
}\DIFaddend null-terminated pointer \code{s} \DIFaddbegin \DIFadd{as its argument, }\DIFaddend from which it attempts to read four
characters. These are interpreted as hex digits and converted to an
\code{uint} returned via parameter \code{result}. At first,
\code{s}\DIFaddbegin \DIFadd{~}\DIFaddend has no specific bounds annotation, which we can interpret as
\code{count(0)}; this means that \code{s[0]} may be read on line
5. The true branch of the conditional (which extends all the way to
the brace on line 15) is thus typechecked with \code{s} given a
\emph{widened} bound of \code{count(1)}. Likewise, the conditionals on
lines 6-8 each widen it one further; the widened pointer
(\code{s+4}) is returned on success.

The \code{parse} function on lines 18-26 repeatedly invokes
\code{parse_utf16_hex} with its parameter \code{s}, and fills out
array \code{p} whose declared length is the parameter \code{n}. Writes
happen via pointer \code{q}, which is updated using pointer
arithmetic. We specify its bounds as
\code{bounds(p,p+n)} to support this: even as \code{q} changes, variables \code{p} and \code{n} \DIFaddbegin \DIFadd{(and therefore also }\code{q}\DIFadd{'s bounds) }\DIFaddend do not. Converting from an
\code{array_ptr<uint>} to a \code{ptr<uint>}, done for the call on
line 25, requires proving the array has size at least 1. While this is true
because of the loop condition \code{q < p+n}, which is \code{q}'s
upper bound,  the compiler is not smart enough to figure this
out. To convince it, we manually insert a \DIFdelbegin \DIFdel{bounds check using
}\DIFdelend \DIFaddbegin \emph{\DIFadd{dynamic cast}} \DIFadd{via
}\DIFaddend \code{dyn_bounds_cast}\DIFaddbegin \DIFadd{, which is trusted at compile-time but confirmed
with a dynamic check at run-time}\DIFaddend .

While bounds checks are \emph{conceptually} inserted on every array
load and store, many of these are eliminated by LLVM\@. For example,
all of the pointer accesses to \code{s} on lines 5-8 are proved safe
at compile-time, so no bounds checks are inserted for
them. \citet{Elliott2018}
reported average run-time overheads of 8.6\% on a pointer-intensive
benchmark suite (49.3\% in one case); \citet{duanrefactoring} measured
no overhead at all on a port of FreeBSD's UDP and IP stacks to \checkedc.



\subsection{Other features}

\checkedc has other features not modeled in this paper. Two in regular
use are \emph{interop types}, which ascribe checked pointer types to
unported legacy code, notably in libraries; and \emph{generic types}
on both functions and \code{struct}s, for type-safe polymorphism. More
details about these can be found in the language specification.

\subsection{Spatial Safety and Backward Compatibility}
\checkedc is backward compatible with legacy C in the sense that all
legacy code will typecheck and compile. However, only code that
appears in \emph{checked regions}, which we call \emph{checked code},
is spatially safe. Checked regions can be designated at the level of
files, functions, or individual code blocks, the first with a
\code{#pragma} and the latter two using the \code{checked}
keyword.\footnote{You can also designate \emph{unchecked} regions
  within checked ones.}  Within checked regions, both
legacy pointers and certain unsafe idioms (e.g., variadic function
calls) are disallowed. The code in Fig.~\ref{fig:checkedc-example}
satisfies these conditions, and will typecheck in a checked region.

How should we think about code that contains both checked and legacy
components? \citet{ruef18checkedc-incr} proved, for a simple
formalization of \checkedc, that \emph{checked code cannot be blamed}:
Any spatial safety violation owes to the execution of unchecked
code. In this paper we extend that result to a richer formalization of
\checkedc. 




















 






%DIF <  \ignore{
%DIF <  \liyi{Good information about pointer types here:
%DIF <  https://github.com/microsoft/checkedc/wiki/New-pointer-and-array-types}
\DIFdelbegin %DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  This code creates an array pointer of length $10$, and reads the pointer $(x+y)$. 
%DIF <  If the integer value $y$ is greater than $10$, executing the program in C results in undefined behavior. 
%DIF <  In \checkedc, however, we links every pointer in a program with their bound information statically, and inserts checks to dynamically verify if the usage of the pointer violates the spatial safety. For example, In compiling the above fragment, we inserts the bound's check for $x$ in the read operation $(x+y)$, and if $y$ results in a value $11$, the execution of the read operation $(x+y)$ results in an dynamic error. 
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  There are many existing language development trying to guarantee the C spatial safety property through different approaches. For example, Cyclone \cite{Jim2002} and Cerberus \cite{cerberus} are the fat pointer approaches for guaranteeing the spatial safety and eliminating undefined behaviors in C. Rust \cite{Rust2016}, on the other hand, tries to restrict the possible way of writing programs to guarantee such property statically.
%DIF <  The problem of these two approaches are effectiveness of executing programs and user practicality of writing programs. The fat-pointer approach completely relies on dynamic checks to guarantee the safety properties but it might pay a huge price on execution efficiency. In our experiment (Sec.\ref{sec:evaluation}), we found that the execution of fat pointer approaches cost the speed a 50\% overhead. 
%DIF <  On the other hand, Rust uses a static approach by restricting the usage of pointers to guarantee the properties, which results in a user UN-friendly system.  
%DIF <  The development of \checkedc is an investigation on keeping the balance between execution efficiency and user-friendly systems. We develop a system to utilize static type systems to allow the \checkedc compiler to insert dynamic checks to guarantee the safety property. The efficiency of \checkedc is in the same level of Rust while we maintain a user-friendly system and inherited most of the operation features from C.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Another feature of \checkedc is the division of the checked and unchecked blocks. When users try to rewrite their C programs into \checkedc programs, they can develop the code incrementally by rewriting sub-parts of their programs to \checkedc code fragments and placing them as the checked blocks, while keeping the rest C programs as unchecked C programs. \checkedc guarantees that if there is any safety violation, this comes from the unchecked blocks (the blame theory). 
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Here is the contributions of the paper. First, we develop the code formalization of \checkedc and show that the type system in \checkedc is type-sound and satisfies the blame theory with respect to the \checkedc semantics. Specifically, we formalize null-terminated array pointers. To our best knowledge, this is the first work defining such feature in C-related languages. 
%DIF <  Second, in formalizing the \checkedc language, we investigate the balance between program execution efficiency and user practicality. We re-investigate the \checkedc type system with subtyping relations to make it more efficient and user-friendly.
%DIF <  Second, we also develop random testing tools in Redex \cite{pltredex} to test the \checkedc compiler and make sure it is properly developed. We are able to find and reproduce many bugs/faults in the \checkedc compiler \liyi{numbers?}. The random testing tool is able to generate tens of thousands of programs to properly validate the \checkedc compiler. Third, we also spent a great amount of work in developing experiments to compare \checkedc and other existing C-like languages that guarantee the spatial safety and eliminating undefined behaviors. We found that \checkedc keeps the best balance between execution efficiency and user practicality.
%DIF <  }
%DIFDELCMD < 

%DIFDELCMD <  
%DIFDELCMD < %%%
%DIF <  \ignore{
%DIF <  \section{Null-Terminated Array Pointers}
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Key ideas, formalized:
%DIF <  \begin{itemize}
%DIF <  \item Can read one past the end: x[N] can be read, but only written if
%DIF <    the value being written is 0.
%DIF <  \item NT arrays are a refinement of normal arrays: Can convert
%DIF <    x:(ntarray N t) to (array N t).
%DIF <  \item NT arrays can expand their length flow sensitively: Can convert
%DIF <    x:(ntarray N t) to (ntarray N+1 t) assuming x[N] != 0.
%DIF <  \item In general unsafe to convert x:(array N t) to (ntarray N-1 t)
%DIF <    even if x[N-1] == 0 because aliases of x could eliminate the NULL
%DIF <    terminator. Would need some sort of linearity/alias tracking to
%DIF <    support this idea.
%DIF <  \item Question? What is the syntax of doing a malloc on a NT-array?
%DIF <    Should we just do malloc(NT-array l h type) as the malloc of a
%DIF <    normal array or should we also include something like int [] nt =
%DIF <    “abcd”, where the bound size is not specified?
%DIF <  \end{itemize}
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  See also the Checked C specification
%DIF <  \ignore{
%DIF <  https://github.com/microsoft/checkedc/tree/master/spec/bounds\_safety}
%DIF <  }
%DIFDELCMD < 

%DIFDELCMD < %%%
\DIFdelend \section{Formalization}\label{sec:formal}























%DIF <  \ignore{
%DIF <  \begin{figure}
%DIF <    \begin{center}
%DIF <      \includegraphics[height=6in]{syntax.pdf}
%DIF <    \end{center}
%DIF <    \caption{\lang: Syntax}
%DIF <  \end{figure}
\DIFdelbegin %DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  \begin{figure}
%DIF <    \begin{center}
%DIF <      \includegraphics[height=6in]{types.pdf}
%DIF <    \end{center}
%DIF <    \caption{\lang: Typing}
%DIF <  \end{figure}
%DIF <  }
%DIFDELCMD < 

%DIFDELCMD < %%%
\DIFdelend \begin{figure}
  \small \centering
  $\begin{array}{l}
\begin{array}{lll}
\text{Function names:}~f&
       \text{Variables:}~ x
& \text{Integers:}~n::=\mathbb{Z} 
\end{array}
\\[0.5em]

\begin{array}{llcllcl}

\text{Mode:} & m & ::= & \cmode \mid \umode \\[0.5em]

\text{Bound:} & b & ::= & n \mid x \plus n \\
              & \bvar & ::= & (b,b) \\[0.5em]

     \text{Word Type:}& \tau &::=& \tint\mid \tptr{\omega}{m}
\\[0.5em]

\text{Type Flag:}&\kappa &::=& nt \mid \cdot
\\[0.5em]

\text{Type:}&\omega &::=& \tau \mid \tallarrayb{\bvar}{\tau}
\\[0.5em]

\text{Expression:}& e & ::= & 
\evalue{n}{\tau} \mid x \mid \emalloc{\omega} \mid\elet{x}{e}{e} \\[0.2em]
&&\mid&
\ecast{\tau}{e} \mid \edyncast{\tau}{e}\mid \ecall{f}{\overline{e}} \mid \estrlen{x} \\[0.2em]
&&\mid&
\ebinop{e}{e} \mid\estar{e}\mid\eassign{e}{e}\mid\eunchecked{e}
\\[0.2em]
&&\mid&\eif{e}{e}{e}
\end{array}
    \end{array}
  $
  \caption{\lang Syntax}
  \label{fig:checkc-syn}
\end{figure}





This section describes our formal model of \checkedc, called
\lang, making precise its syntax, semantics, and type system. It also
develops \lang's metatheory, including type soundness and the blame
theorem.

\subsection{Syntax}\label{sec:syntax}

The syntax of \lang is given by the expression-based
language presented in Fig.~\ref{fig:checkc-syn}.

There are two notions of type in \lang.  Types $\tau$ classify
word-sized values including the integers and pointers, while types
$\omega$ classify multi-word values such as arrays, null-terminated
arrays, and single-word-size values.
Pointer types ($\tptr{\omega}{m}$) include a mode annotation ($m$)
which is either checked (\cmode) or unchecked (\umode) and a type
($\omega$) denoting the type of value to which is pointed. Array types include both the type of
elements ($\tau$) and a bound ($\bvar$) comprised of an upper and
lower bound on the size of the array ($(b_l,b_h)$). Bounds $b$ are
limited to integer literals $n$ and expressions $x + n$.
Whether an array pointer is null terminated or not is determined by annotation
$\kappa$, which is $nt$ for null-terminated arrays, and $\cdot$
otherwise (we elide the $\cdot$ when writing the type). Here is the
corresponding \checkedc syntax for these types:
\[
\begin{array}{rcl}
$\code{array_ptr<}$\tau$\code{> : count(}$n$\code{)}$
&\Leftrightarrow& \tarrayptr{0}{n}{\tau}{\cmode}
\\[0.2em]
$\code{nt_array_ptr<}$\tau$\code{> : count(}$n$\code{)}$
&\Leftrightarrow& \tntarrayptr{0}{n}{\tau}{\cmode}
\end{array}
\]
As a convention we write $\tptr{\tarrayb{b}{\tau}}{\cmode}$ to mean
$\tptr{\tarray{0}{b}{\tau}}{\cmode}$, so the above examples could
be rewritten $\tptr{\tarrayb{n}{\tau}}{\cmode}$ and
$\tptr{\tntarrayb{n}{\tau}}{\cmode}$, respectively.

\lang expressions include literals ($n\!:\!\tau$), variables ($x$), memory
allocation ($\emalloc{\omega}$), let binding ($\elet{x}{e_1}{e_2}$),
static \DIFdelbegin \DIFdel{and dynamic }\DIFdelend casts ($\ecast{\tau}{e}$\DIFdelbegin \DIFdel{and }\DIFdelend \DIFaddbegin \DIFadd{), dynamic casts }\DIFaddend $\edyncast{\tau}{e}$
\DIFdelbegin \DIFdel{,
resp.}\DIFdelend \DIFaddbegin \DIFadd{(assumed at compile-time and verified at run-time, see Sec.~\ref{sec:example}}\DIFaddend ),
function calls ($\ecall{f}{\overline{e}}$), addition
($\ebinop{e_1}{e_2}$), pointer dereference and assignment ($\estar{e}$
and $\eassign{e_1}{e_2}$, resp.), unchecked blocks ($\eunchecked{e}$),
the \texttt{strlen} operation ($\estrlen{x}$), and conditionals $\eif{e}{e_1}{e_2}$.


Integer literals $n$ are annotated with a type $\tau$ which can be either
$\tint$, or $\tptr{\omega}{m}$ in the case $n$ is being used as
a heap address (this is useful for the semantics)\DIFaddbegin \DIFadd{;
$\evalue{0}{\tptr{\omega}{m}}$ (for any $m$ and $\omega$) represents
the $\enull$ pointer, as usual}\DIFaddend . 
The
$\texttt{strlen}$ expression operates on variables $x$
rather than arbitrary expressions to simplify managing
bounds information in the type system; the more general case can be
encoded with a \code{let}. We use a less verbose syntax for dynamic bounds
casts; e.g., the following 

\code{dyn_bounds_cast<array_ptr<}$\tau$\code{>>(}$e$\code{, count(}$n$\code{))}

\noindent
becomes \DIFdelbegin \DIFdel{$\edyncast{\tptr{\tntarrayb{n}{\tau}}{\cmode}}{e}$}\DIFdelend \DIFaddbegin \DIFadd{$\edyncast{\tptr{\tarrayb{n}{\tau}}{\cmode}}{e}$}\DIFaddend . 

\lang aims to be simple enough to work with, but powerful enough to
encode realistic \checkedc idioms. For example\DIFdelbegin \DIFdel{: }\DIFdelend \DIFaddbegin \DIFadd{, }\DIFaddend mutable local
variables can be encoded as immutable locals that point to the heap;
the use of \code{&} can be simulated with \code{malloc};
and loops can be encoded as recursive function calls. \code{struct}s are
not in Fig.~\ref{fig:checkc-syn} for space reasons, but they are
actually in our model, and developed in
\DIFaddbegin \iftr
\DIFaddend Appendix~\ref{appx:struct}.
\DIFaddbegin \else
\DIFadd{the supplemental report~}\cite{checkedc-tech-report}\DIFadd{.
}\fi
\DIFaddend C-style \code{union}s have no safe typing
in \checkedc, so we elide them. By default, functions are assumed to
be within checked regions; placing the body in an \code{unchecked}
expression relaxes this, and within that, checked regions can be
nested within via function calls. Bounds are restricted slightly:
rather than allowing arbitrary subexpressions, bounds must be either
integer literals or variables plus an integer offset, which accounts
for most uses of \code{bounds} in \checkedc programs. \lang bounds are
defined as relative offsets, not absolute ones, as in the second part
of Fig.~\ref{fig:checkedc-example}. We see no technical problem to
modeling absolute bounds, but it would be a pervasive change so we
have not done so.

  \DIFaddbegin \DIFadd{We have mechanized two models of }\lang\DIFadd{, one in Coq
  and one in PLT Redex~}\cite{pltredex}\DIFadd{, which is a semantic
  engineering framework implemented in Racket. Redex provides direct
  support for specifying the operational semantics and typing with logical
  rules, but then automatically makes them executable and subject to
  randomized testing, which is very useful during development.
  The model we present in the paper faithfully
  represents both mechanizations, but there are some differences for
  presentation purposes. For example, the paper and the Coq model use an explicit
  stack, whereas the Redex model uses }\code{let} \DIFadd{bindings to simulate
  one (simplifying term generation for randomized
  testing).
}\iftr
  \DIFadd{Appendix~\ref{app:model-diffs} 
}\else
  \DIFadd{The supplemental report~}\cite{checkedc-tech-report}
\fi
  \DIFadd{outlines the differences
  between the two models and the paper formalism.
}



\DIFaddend \begin{figure}
{\small
$    \begin{array}{l}
    \begin{array}{lll}
\mu & ::= & \evalue{n}{\tau} \mid \bot\\
e & ::= & \ldots \mid \ret{x}{\mu}{e}\\
r & ::= & e \mid \enull \mid \ebounds\\
E &::=& \Box \mid \elet{x}{E}{e} \mid \ecall{f}{\overline{E}}\mid\ecast{\tau}{E} \mid \edyncast{\tau}{E} \\[0.2em]
&&\mid \ret{x}{\evalue{n}{\tau}}{E}\mid\ebinop{E}{e} \mid \ebinop{\evalue{n}{\tau}}{E}\mid\estar{E}\mid\eassign{E}{e} \\[0.2em]
&&\mid\eassign{\evalue{n}{\tau}}{E}\mid\eunchecked{E}\mid\eif{E}{e}{e}\\[0.2em]
\overline{E} &::=& E \mid  \evalue{n}{\tau},\overline{E} \mid \overline{E}, e
\end{array}
\\ \\
    \end{array} 
$
  \begin{mathpar}
    \inferrule{ m=\mode(E) \\
      e=E[e'] \\
      (\varphi,\heap,e') \longrightarrow (\varphi',\heap',e'')}
    {(\varphi,\heap,e)\longrightarrow_{m} (\varphi',\heap',E[e''])}


    \DIFaddbeginFL \inferrule{ m=\mode(E) \\
      e=E[\eif{\estar{x}}{e_1}{e_2}] \\
      (\varphi,\heap,\eif{\estar{x}}{e_1}{e_2})
              \longrightarrow (\varphi',\heap',e')}
    {\DIFaddFL{(\varphi,}\heap\DIFaddFL{,e)\longrightarrow_{m} (\varphi',}\heap\DIFaddFL{',E}[\DIFaddFL{e'}]\DIFaddFL{)}}
    \DIFaddFL{\;\;\;{[\emph{prefer}]}
}

  \DIFaddendFL \end{mathpar}
}
  \caption{\lang semantics: Evaluation}
  \label{fig:c-context}
\end{figure}

\subsection{Semantics}\label{sec:semantics}





The operational semantics for \lang is defined as a small-step
transition relation with the judgment $ (\varphi,\heap,e)
\longrightarrow_m (\varphi',\heap',r)$. Here, $\varphi$ is a
\emph{stack} mapping from variables to values $\evalue{n}{\tau}$ and
$\heap$ is a \emph{heap} mapping addresses (integer literals) to
values $\evalue{n}{\tau}$; for both we ensure
$\fv(\tau)=\emptyset$.
\DIFaddbegin \DIFadd{While heap bindings can change, stack bindings are immutable---once
variable $x$ is bound to $\evalue{n}{\tau}$ in $\varphi$, that binding will not
be updated; we can model mutable stack variables as pointers into the
mutable heap.
As mentioned, value $\evalue{0}{\tau}$
represents a $\enull$ pointer when $\tau$ is a pointer type;
correspondingly, $\heap(0)$ should always be undefined.
}\DIFaddend The relation steps to a \emph{result} $r$,
which is either an expression or a $\enull$ or $\ebounds$ failure,
representing a null-pointer dereference or out-of-bounds access,
respectively. Such failures are a \emph{good} outcome; stuck states
(non-value expressions that cannot transition to a result $r$)
characterize undefined behavior.
The mode $m$ indicates whether the
stepped redex within $e$ was in a checked ($\cmode$) or
unchecked ($\umode$) region.

The rules for the main operational semantics
judgment---\emph{evaluation}---are given at the bottom of
Fig.~\ref{fig:c-context}.
The \DIFaddbegin \DIFadd{first }\DIFaddend rule takes an expression $e$, decomposes
it into an \emph{evaluation context} $E$ and a subexpression $e'$
(such that replacing the hole $\Box$ in $E$ with $e'$ would yield
$e$), and then evaluates $e'$ according to the \emph{computation}
  relation \DIFdelbegin \DIFdel{$
(\varphi,\heap,e') \longrightarrow (\varphi,\heap,e'')$,
}\DIFdelend \DIFaddbegin \DIFadd{$(\varphi,\heap,e') \longrightarrow (\varphi,\heap,e'')$,
whose rules are given in Fig.~\ref{fig:semantics}, }\DIFaddend discussed
shortly. 
The \DIFdelbegin \DIFdel{computation relation can transition to any $r$; the rule in the figure just considers $r = e$. For the cases $r = \enull$ and $r = \ebounds$, two other rules (not shown) will cause the whole
evaluation to terminate with $r$.  The semantics has a special case
for a conditional $\eif{e_0}{e_1}{e_2}$.  If $e_0=\estar{x}$, the
conditional itself is considered as the redex with special handling
for bound widening.Otherwise, the standard conditional behavior is
used.
}\DIFdelend \DIFaddbegin \DIFadd{second rule handles conditionals $\eif{\estar{x}}{e_2}{e_3}$ in
redex position specially, delegating directly to the }\textsc{\DIFadd{S-IfNTT}} \DIFadd{computation
rule, which supports bounds widening; we discuss this rule
shortly. When the second and first rules could both apply, we always
prefer the second.}\footnote{\DIFadd{This approach is that of the PLT Redex model of }\lang\DIFadd{; the Coq
development uses a slightly simpler syntax to achieve the same
effect.}}
\DIFaddend The $\mode$ function
determines the mode \DIFdelbegin \DIFdel{of the }\DIFdelend \DIFaddbegin \DIFadd{when }\DIFaddend evaluating $e'$ based on the context $E$:
if the $\Box$ \DIFdelbegin \DIFdel{in $E$ occurs in context $\eunchecked{E'}$, }\DIFdelend \DIFaddbegin \DIFadd{occurs within $(\eunchecked{E'})$ inside $E$, then }\DIFaddend the mode is
$\umode$\DIFdelbegin \DIFdel{, }\DIFdelend \DIFaddbegin \DIFadd{; }\DIFaddend otherwise, it is $\cmode$. Evaluation contexts $E$ define a
standard left-to-right evaluation order. (We explain the
$\ret{x}{\mu}{e}$ syntax shortly.)


\DIFdelbegin %DIFDELCMD < \begin{DIFnomarkup}
%DIFDELCMD < \begin{figure*}[t]
%DIFDELCMD < {\small
%DIFDELCMD <   \begin{mathpar}
%DIFDELCMD <     \inferrule[S-Cast]
%DIFDELCMD <               {}
%DIFDELCMD <               {(\varphi,\heap,\ecast{\tau}{\evalue{n}{\tau'}}) \longrightarrow (\varphi,\heap,\evalue{n}{\varphi(\tau)})}
%DIFDELCMD < 

%DIFDELCMD <     \inferrule[S-Ret]{}{(\varphi,\heap,\ret{x}{\mu}{\evalue{n}{\tau}}) \longrightarrow (\varphi[x\mapsto \mu],\heap,\evalue{n}{\tau})}
%DIFDELCMD < 

%DIFDELCMD <         \inferrule[S-Let]{}{(\varphi,\heap,\elet{x}{\evalue{n}{\tau}}{e}) \longrightarrow (\varphi[x\mapsto \evalue{n}{\tau}],\heap,\ret{x}{\varphi(x)}{e})}
%DIFDELCMD < 

%DIFDELCMD <     \inferrule[S-DefNull]{}{(\varphi,\heap,\estar{\evalue{0}{\tptr{\omega}{\cmode}}}) \longrightarrow (\varphi,\heap,\enull)}
%DIFDELCMD < 

%DIFDELCMD <         \inferrule[S-DefNTArray]{\heap(n)=\evalue{n_a}{\tau_a} \\ 0 \in [n_l,n_h]}
%DIFDELCMD <     {(\varphi,\heap,\estar{\evalue{n}{\tntarrayptr{n_l}{n_h}{\tau}{\cmode}}}) \longrightarrow (\varphi,\heap,\evalue{n_a}{\tau})}
%DIFDELCMD < 

%DIFDELCMD <     \inferrule[S-Fun]{ \Xi(f) = \tau\;(\evalue{\overline{x}}{\overline{\tau}})\;e}
%DIFDELCMD <         {(\varphi,\heap,\ecall{f}{{\evalue{\overline{n}}{\overline{\tau_a}}}}) \longrightarrow
%DIFDELCMD <    (\varphi,\heap, \mathtt{let}\;\overline{x}={\evalue{\overline{n}}{(\overline{\tau}[\overline{n} / \overline{x}])}}\;\mathtt{in}\;\ecast{\tau[\overline{n} / \overline{x}]}{e})}
%DIFDELCMD <     

%DIFDELCMD <   \inferrule[S-DynCast]{
%DIFDELCMD < \varphi(\tptr{\tallarrayb{\bvar}{\tau}}{m})=\tallarrayptr{n_l'}{n_h'}{\tau_b}{m} \\ n_l' \le n_l\ \\ n_h \le n_h'}
%DIFDELCMD <     { (\varphi,\heap,\edyncast{\tptr{\tallarrayb{\bvar}{\tau}}{m}}{\evalue{n}{\tallarrayptr{n_l}{n_h}{\tau_a}{m}}}) \longrightarrow (\varphi',\heap',\evalue{n}{\tallarrayptr{n_l'}{n_h'}{\tau_b}{m}})}
%DIFDELCMD < 

%DIFDELCMD <  \inferrule[S-DynCastBound]{\varphi(\tptr{\tallarrayb{\bvar}{\tau}}{\cmode})=\tallarrayptr{n_l'}{n_h'}{\tau_b}{\cmode} \\ n_l' > n_l \vee n_h > n_h'}{ (\varphi,\heap,\edyncast{\tptr{\tallarrayb{\bvar}{\tau}}{\cmode}}{\evalue{n}{\tallarrayptr{n_l}{n_h}{\tau_a}{\cmode}}}) 
%DIFDELCMD <  \longrightarrow (\varphi',\heap',\ebounds)}
%DIFDELCMD < 

%DIFDELCMD <       \inferrule[S-StrWiden]{
%DIFDELCMD <          \varphi(x) = \evalue{n}{\tarrayptr{n_l}{n_h}{\tau}{\cmode}}\\ 0 \in [n_l,n_h] \\ n_a > n_h
%DIFDELCMD < \\ \heap(n+n_a) = 0 
%DIFDELCMD < \\\\ (\forall i. n \le i < n+n_a \Rightarrow (\exists n_i\;t_i. \heap(n+i) = \evalue{n_i}{\tau_i} \wedge n_i \neq 0))}
%DIFDELCMD <     {(\varphi,\heap,\estrlen{x}) \longrightarrow (\varphi[x\mapsto \evalue{n}{\tarrayptr{n_l}{n_a}{\tau}{\cmode}}],\heap,\evalue{n_a}{\tint})}
%DIFDELCMD < 

%DIFDELCMD <      \inferrule[S-IfNTT]{\varphi(x)=\evalue{n}{\tntarrayptr{n_l}{0}{\tau}{\cmode}} \\ \heap(n)\neq 0}
%DIFDELCMD <     {(\varphi,\heap,\eif{*x}{e_1}{e_2}) \longrightarrow (\varphi[x\mapsto \evalue{n}{\tntarrayptr{n_l}{1}{\tau}{\cmode}}],\heap,e_1)}
%DIFDELCMD < 

%DIFDELCMD <     
%DIFDELCMD <     \inferrule[S-AssignArr]{\heap(n)=\evalue{n_a}{\tau_a}\\ 0 \in [n_l,n_h) }
%DIFDELCMD <       {(\varphi,\heap,\eassign{\evalue{n}{\tallarrayptr{n_l}{n_h}{\tau}{\cmode}}}{\evalue{n_1}{\tau_1}}) \longrightarrow (\varphi,\heap[n \mapsto \evalue{n_1}{\tau}],\evalue{n_1}{\tau})}
%DIFDELCMD < 

%DIFDELCMD <         \inferrule[S-Def]{\heap(n)=\evalue{n_a}{\tau_a} }
%DIFDELCMD <     {(\varphi,\heap,\estar{\evalue{n}{\tptr{\tau}{m}}}) \longrightarrow (\varphi,\heap,\evalue{n_a}{\tau})}
%DIFDELCMD < \end{mathpar}
%DIFDELCMD < }
%DIFDELCMD < \caption{\lang semantics: Computation (selected rules)}
%DIFDELCMD < \label{fig:semantics}
%DIFDELCMD < \end{figure*}
%DIFDELCMD < \end{DIFnomarkup}
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \begin{DIFnomarkup}
\begin{figure*}[t]
{\small
  \begin{mathpar}
        \inferrule[S-Def]{\heap(n)=\evalue{n_a}{\tau_a} }
    {(\varphi,\heap,\estar{\evalue{n}{\tptr{\tau}{m}}}) \longrightarrow (\varphi,\heap,\evalue{n_a}{\tau})}

    \inferrule[S-DefNull]{}{(\varphi,\heap,\estar{\evalue{0}{\tptr{\omega}{\cmode}}}) \longrightarrow (\varphi,\heap,\enull)}

        \inferrule[S-DefNTArray]{\heap(n)=\evalue{n_a}{\tau_a} \\ 0 \in [n_l,n_h]}
    {(\varphi,\heap,\estar{\evalue{n}{\tntarrayptr{n_l}{n_h}{\tau}{\cmode}}}) \longrightarrow (\varphi,\heap,\evalue{n_a}{\tau})}


    \inferrule[S-AssignArr]{\heap(n)=\evalue{n_a}{\tau_a}\\ 0 \in [n_l,n_h) }
      {(\varphi,\heap,\eassign{\evalue{n}{\tallarrayptr{n_l}{n_h}{\tau}{\cmode}}}{\evalue{n_1}{\tau_1}}) \longrightarrow (\varphi,\heap[n \mapsto \evalue{n_1}{\tau}],\evalue{n_1}{\tau})}

    \inferrule[S-Cast]
              {}
              {(\varphi,\heap,\ecast{\tau}{\evalue{n}{\tau'}}) \longrightarrow (\varphi,\heap,\evalue{n}{\varphi(\tau)})}

  \inferrule[S-DynCast]{
\varphi(\tptr{\tallarrayb{\bvar}{\tau}}{m})=\tallarrayptr{n_l'}{n_h'}{\tau_b}{m} \\ n_l' \le n_l\ \\ n_h \le n_h'}
    { (\varphi,\heap,\edyncast{\tptr{\tallarrayb{\bvar}{\tau}}{m}}{\evalue{n}{\tallarrayptr{n_l}{n_h}{\tau_a}{m}}}) \longrightarrow (\varphi',\heap',\evalue{n}{\tallarrayptr{n_l'}{n_h'}{\tau_b}{m}})}


 \inferrule[S-DynCastBound]{\varphi(\tptr{\tallarrayb{\bvar}{\tau}}{\cmode})=\tallarrayptr{n_l'}{n_h'}{\tau_b}{\cmode} \\ n_l' > n_l \vee n_h > n_h'}{ (\varphi,\heap,\edyncast{\tptr{\tallarrayb{\bvar}{\tau}}{\cmode}}{\evalue{n}{\tallarrayptr{n_l}{n_h}{\tau_a}{\cmode}}}) 
 \longrightarrow (\varphi',\heap',\ebounds)}

        \inferrule[S-Let]{}{(\varphi,\heap,\elet{x}{\evalue{n}{\tau}}{e}) \longrightarrow (\varphi[x\mapsto \evalue{n}{\tau}],\heap,\ret{x}{\varphi(x)}{e})}

    \inferrule[S-Ret]{}{(\varphi,\heap,\ret{x}{\mu}{\evalue{n}{\tau}}) \longrightarrow (\varphi[x\mapsto \mu],\heap,\evalue{n}{\tau})}


    \inferrule[S-Fun]{ \Xi(f) = \tau\;(\evalue{\overline{x}}{\overline{\tau}})\;e}
        {(\varphi,\heap,\ecall{f}{{\evalue{\overline{n}}{\overline{\tau_a}}}}) \longrightarrow
   (\varphi,\heap, \mathtt{let}\;\overline{x}={\evalue{\overline{n}}{(\overline{\tau}[\overline{n} / \overline{x}])}}\;\mathtt{in}\;\ecast{\tau[\overline{n} / \overline{x}]}{e})}

\inferrule[S-StrWiden]{
         \varphi(x) = \evalue{n}{\tarrayptr{n_l}{n_h}{\tau}{\cmode}}\\ 0 \in [n_l,n_h] \\ n_a > n_h
\\ \heap(n+n_a) = 0 
\\\\ (\forall i. n \le i < n+n_a \Rightarrow (\exists n_i\;t_i. \heap(n+i) = \evalue{n_i}{\tau_i} \wedge n_i \neq 0))}
    {(\varphi,\heap,\estrlen{x}) \longrightarrow (\varphi[x\mapsto \evalue{n}{\tarrayptr{n_l}{n_a}{\tau}{\cmode}}],\heap,\evalue{n_a}{\tint})}

     \inferrule[S-IfNTT]{\varphi(x)=\evalue{n}{\tntarrayptr{n_l}{0}{\tau}{\cmode}} \\ \heap(n)\neq 0}
    {(\varphi,\heap,\eif{*x}{e_1}{e_2}) \longrightarrow (\varphi[x\mapsto \evalue{n}{\tntarrayptr{n_l}{1}{\tau}{\cmode}}],\heap,e_1)}



\end{mathpar}
}
\caption{\lang semantics: Computation (selected rules)}
\label{fig:semantics}
\end{figure*}
\end{DIFnomarkup}
\DIFaddend 





\begin{figure}[t]
{\small
{\captionsetup[lstlisting]{margin = 8 mm}
  \DIFmodbegin
\begin{lstlisting}[xleftmargin=8 mm,alsolanguage=DIFcode]
%DIF < nt_array_ptr<int> strncat : count(0)
%DIF <   (nt_array_ptr<int> a : count(n),
%DIF <    nt_array_ptr<int> b : count(0), int n) {
%DIF <   int x = strlen(a);
%DIF <   int y = strlen(b);
%DIF <   if (x <= n)
%DIF <     nt_array_ptr<int> c : count(n) =
%DIF <       dynamic_bounds_cast
%DIF <         <nt_array_ptr<int>>(a,count(n));
%DIF <     else return null;
%DIF < -
%DIF <   if (x+y <= n) 
%DIF > nt_array_ptr<char> safe_strcat
%DIF >    (nt_array_ptr<char> dst : count(n),
%DIF >     nt_array_ptr<char> src : count(0), int n) {
%DIF >   int x = strlen(dst);
%DIF >   int y = strlen(src);
%DIF >   nt_array_ptr<char> c : count(n) =
%DIF >     dyn_bounds_cast
%DIF >            <nt_array_ptr<char>>(dst,count(n));
%DIF >     // sets c == dst with bound n (not x)
%DIF >   if (x+y < n) {
    for (int i = 0; i < y; ++i)
%DIF <          * (c+x+i) = * (b+i);
%DIF <     else return null;
%DIF <   return a;
%DIF >       *(c+x+i) = *(src+i);
%DIF >     *(c+x+y) = '\0';
%DIF >     return dst;
  }
%DIF < -
%DIF < nt_array_ptr<int> strncat_c : count(0)
%DIF <   (nt_array_ptr<int> a : count(n),
%DIF <    nt_array_ptr<int> b : count(0), int n) {
%DIF <    int x = 0;
%DIF <    int y = strlen(b);
%DIF <    while (*x != '/0')
%DIF <     a++; x++;
%DIF <     -
%DIF <    for (int i = 0; i < y; ++i)
%DIF <      if (i + x < n)
%DIF <          * (a+i) = * (b+i);
%DIF <        else return null;
%DIF <    return a;
%DIF >   return null;
}
  
\end{lstlisting}
\DIFmodend
}
}
\caption{\DIFdelbeginFL \DIFdelFL{Implementations for strncat}\DIFdelendFL \DIFaddbeginFL \DIFaddFL{Implementation of safe }\code{strcat}\DIFaddendFL }
\DIFdelbeginFL %DIFDELCMD < \label{fig:strncat-ex}
%DIFDELCMD < %%%
\DIFdelendFL \DIFaddbeginFL \label{fig:strcat-ex}
\DIFaddendFL \end{figure}

Fig.~\ref{fig:semantics} shows \DIFaddbegin \DIFadd{selected }\DIFaddend rules for the computation
relation\DIFdelbegin \DIFdel{. We explain the rules in turn using the example of }\DIFdelend \DIFaddbegin \DIFadd{; we explain them with the help of the example in
}\DIFaddend Fig.~\DIFdelbegin \DIFdel{\ref{fig:strncat-ex}.  }\DIFdelend \DIFaddbegin \DIFadd{\ref{fig:strcat-ex},
  which defines a 
  safe version of }\code{strcat} \DIFadd{(using actual Checked C syntax).  The
  function takes a target 
  pointer }\code{dst} \DIFadd{of capacity }\code{n}\DIFadd{, where the first null
  character (determined by }\code{strlen}\DIFadd{) is at index }\code{x} \DIFadd{where
  $0 \leq $}\code{x}\DIFadd{$ \leq n$. It concatenates the }\code{src} \DIFadd{buffer to
  the end of }\code{dst} \DIFadd{as long as }\code{dst} \DIFadd{has sufficient space.
}\DIFaddend 



\myparagraph{Pointer accesses}
The rules for dereference and assignment operations---\textsc{S-Def},
\textsc{S-DefNull}, \textsc{S-DefNTArray}, and
\textsc{S-AssignArr}---illustrate how the semantics checks bounds.
Rule \textsc{S-DefNull} transitions attempted null-pointer
dereferences to $\enull$, whereas \textsc{S-Def} dereferences a
non-null (single) pointer.
  \DIFaddbegin \DIFadd{When $\enull$ is returned by the
computation relation, the evaluation relation halts the entire
evaluation with $\enull$ (using a rule not shown in Fig.~\ref{fig:c-context}); it
does likewise when $\ebounds$ is returned (see below).
}\DIFaddend 



\textsc{S-AssignArr} assigns to an array as long as 0 (the point of
dereference) is within the bounds designated by the pointer's annotation
and strictly less than the upper bound. For the assignment rule,
arrays are treated uniformly whether they are null-terminated or not
($\kappa$ can be $\cdot$ or $nt$)---the semantics does not search past
the current position for a null terminator. The program
can widen the bounds as needed, if they currently precede the null
terminator: \textsc{S-DefNTArray}, which dereferences an NT array
pointer, allows an upper bound of $0$, since the program may read, but
not write, the null terminator. A separate rule (not shown) handles
normal arrays.

\myparagraph{Casts}
Static casts of a literal $n\!:\!\tau'$ to a type $\tau$ are handled
by \textsc{S-Cast}. In a type-correct program, such casts are
confirmed safe by the type system. To evaluate a cast, the rule
updates the type annotation on $n$. Before doing so, it must
``evaluate'' any variables that occur in $\tau$ according to their
bindings in $\varphi$. For example, if $\tau$ was
$\tarrayptr{0}{x+3}{\tint}{\cmode}$, then $\varphi(\tau)$ would
produce $\tarrayptr{0}{5}{\tint}{\cmode}$ if $\varphi(x) = 2$.

Dynamic casts are accounted for by \textsc{S-DynCast} and
\textsc{S-DynCastBound}. In a type-correct program, such casts are
assumed correct by the type system, and later confirmed by the
semantics. As such, a dynamic cast will cause a $\ebounds$ failure if
the cast-to type is incompatible with the type of the target pointer,
as per the $n_l' > n_l \vee n_h > n_h'$ condition in
\textsc{S-DynCastBound}. An example use of dynamic casts is given on
line~7 in Fig.~\DIFdelbegin \DIFdel{\ref{fig:strncat-ex}}\DIFdelend \DIFaddbegin \DIFadd{\ref{fig:strcat-ex}}\DIFaddend . The values of \code{x} and
\code{n} might not be known statically, so the type system cannot
confirm that \code{x <= n}; the dynamic cast assumes this inequality
holds, but then checks it at run-time.

\myparagraph{Binding and Function Calls}
The semantics handles variable scopes using the special $\erettext$
form. \textsc{S-Let} evaluates to a configuration whose stack
is $\varphi$ extended with a binding for $x$, and whose expression is
$\ret{x}{\varphi(x)}{e})$ which remembers $x$ was previously bound to
$\varphi(x)$; if it had no previous binding, $\varphi(x) =
\bot$. Evaluation proceeds on $e$ until it becomes a literal
$n\!:\!\tau$, in which case \textsc{S-Ret} restores the saved
binding (or $\bot$) in the new stack, and evaluates to
$n\!:\!\tau$. 

Function calls are handled by \textsc{S-Fun}. Recall that array
bounds in types may refer to in-scope variables; e.g., parameter
\DIFdelbegin %DIFDELCMD < \code{a}%%%
\DIFdelend \DIFaddbegin \code{dst}\DIFaddend 's bound \code{count(n)} refers to parameter \code{n} on lines
2-3 in Fig.~\DIFdelbegin \DIFdel{\ref{fig:strncat-ex}}\DIFdelend \DIFaddbegin \DIFadd{\ref{fig:strcat-ex}}\DIFaddend . A call to function $f$ causes $f$'s
definition to be retrieved from $\Xi$,
which maps function names to
forms $\tau\;(\evalue{\overline{x}}{\overline{\tau}})\;e$, where
$\tau$ is the return type, $(\evalue{\overline{x}}{\overline{\tau}})$
is the parameter list of variables and their types, and $e$ is the
function body. The call is expanded into a \texttt{let} which binds
parameter variables $\overline{x}$ to the actual arguments
$\overline{n}$, but annotated with the parameter types
$\overline{\tau}$ (this will be safe for type-correct programs). The
function body $e$ is wrapped in a static cast
$(\tau[\overline{n} / \overline{x}])$, which is the function's return
type but with any parameter variables $\overline{x}$ appearing in that
type substituted with the call's actual arguments $\overline{n}$. To
see why this is needed, suppose that \DIFdelbegin %DIFDELCMD < \code{strncat} %%%
\DIFdelend \DIFaddbegin \code{safe_strcat} \DIFaddend in
Fig.~\DIFdelbegin \DIFdel{\ref{fig:strncat-ex} }\DIFdelend \DIFaddbegin \DIFadd{\ref{fig:strcat-ex} }\DIFaddend is defined to return a
\code{nt_array_ptr<int>:count(n)} typed term, and assume that we
perform a \DIFdelbegin %DIFDELCMD < \code{strncat} %%%
\DIFdelend \DIFaddbegin \code{safe_strcat} \DIFaddend function call as
\DIFdelbegin %DIFDELCMD < \code{x=strncat(a,b,10)}%%%
\DIFdelend \DIFaddbegin \code{x=safe_strcat(a,b,10)}\DIFaddend . After the evaluation of \DIFdelbegin %DIFDELCMD < \code{strncat}%%%
\DIFdelend \DIFaddbegin \code{safe_strcat}\DIFaddend , the
function returns a value with type \code{nt_array_ptr<int>:count(10)}
because we substitute bound variable \code{n} in the 
defined return type with \code{10} from the function call's
argument list.
\DIFaddbegin \DIFadd{Note that the }\textsc{\DIFadd{S-Fun}} \DIFadd{rule replaces the
  annotations $\overline{\tau_a}$ with
  $\overline{\tau}$ (after instantiation) from the function's
  signature. Using $\overline{\tau_a}$ when executing the body of
the function has no impact on the soundness of }\lang\DIFadd{, but will violate
Theorem~\ref{simulation-thm}, which we introduce in Sec.~\ref{sec:compilation}.
}\DIFaddend 

\myparagraph{Bounds Widening}
Bounds widening occurs when branching on a dereference of a NT array
pointer, or when performing $\estrlentext$. The latter is most useful
when assigned to a local variable so that subsequent code can use the
result, e.g., $e$ in $\elet{x}{\estrlen{y}}{e}$.  Lines 4 and 5 in
Fig.~\DIFdelbegin \DIFdel{\ref{fig:strncat-ex} }\DIFdelend \DIFaddbegin \DIFadd{\ref{fig:strcat-ex} }\DIFaddend are examples. 
The widened upper bound
precipitated by $\estrlen{y}$ is extended beyond the lifetime of $x$, as long as $y$ is live.
For example, \code{x}'s scope in line 4 \DIFaddbegin \DIFadd{at runtime }\DIFaddend is
the whole function body in \DIFdelbegin %DIFDELCMD < \code{strncat} %%%
\DIFdelend \DIFaddbegin \code{safe_strcat} \DIFaddend because the lifetime of the pointer \DIFdelbegin \DIFdel{$y$ }\DIFdelend \DIFaddbegin \code{dst} \DIFaddend is in the function body.
This is different from the \checkedc specification, 
which only allows bound widening to happen within the scope of \DIFdelbegin \DIFdel{$x$}\DIFdelend \DIFaddbegin \code{x}\DIFaddend , and restoring old bound values once \DIFdelbegin \DIFdel{$x$ }\DIFdelend \DIFaddbegin \code{x} \DIFaddend dies.
We allow widening to persist outside the scope at run-time as long as
we are within the stack frame, and we show
this does not necessarily require the use of fat pointers in
Sec.~\ref{sec:compilation}.

Rule \textsc{S-StrWiden} implements $\estrlentext$ widening. The
predicate
$\forall i. n \le i < n+n_a \Rightarrow (\exists n_i\;t_i. \heap(n+i)
= \evalue{n_i}{\tau_i} \wedge n_i \neq 0))$ aims to find a position
$n+n_a$ in the NT array that stores a null character, where no
character as indexes between $n$ and $n+n_a$ contains one. (This rule
handles the case when $n_a > n_h$, the $n_a \le n_h$ case is handled
by a normal $\estrlentext$ rule; see 
\DIFdelbegin \DIFdel{Appx.~\ref{fig:rem-semantics}.)
}\DIFdelend \DIFaddbegin \iftr
\DIFadd{Appendix~\ref{sec:rem-semantics}.)
}\else
\DIFadd{the supplemental report~}\cite{checkedc-tech-report}\DIFadd{.)
}\fi
\DIFaddend 

Rule \textsc{S-IfNTT} performs bounds widening on $x$ when the
dereference $\estar{x}$ is not at the null terminator, but the
pointer's upper bound is 0 (i.e., it's at the end of its known
range). $x$'s upper bound is incremented to 1, and this count persists
as long as $x$ is live.  For example, \code{s}'s increment (lines
5--8) is live until the return of the function in
Fig.~\ref{fig:checkedc-example}; thus, line 11 is valid because
\code{s}'s upper bound is properly extended. 









\subsection{Typing}\label{sec:type-system}



We now turn to the \lang type system.
The typing judgment has the form $\Gamma;\Theta\vdash_m e : \tau$,
which states that in \DIFaddbegin \DIFadd{a }\DIFaddend type environment $\Gamma$ (mapping variables to
their types) and \DIFaddbegin \DIFadd{a }\DIFaddend predicate environment $\Theta$ (mapping integer-typed
variables to Boolean predicates), expression $e$ will have type $\tau$ if evaluated
in mode $m$. Key rules for this judgment are given in
Fig.~\ref{fig:type-system-1}. In the rules, $m \le m'$ uses
the two-point lattice with $\umode < \cmode$.
All remaining rules
are given in
\DIFdelbegin \DIFdel{Appx.}\DIFdelend \DIFaddbegin \iftr
\DIFadd{Appendix}\DIFaddend ~\ref{sec:literal-pointer-typing}~and~\ref{rem-type}.
\DIFaddbegin \else
\DIFadd{the supplemental report~}\cite{checkedc-tech-report}\DIFadd{.
}\fi
\DIFaddend 

\DIFdelbegin %DIFDELCMD < \begin{DIFnomarkup}
%DIFDELCMD < \begin{figure*}[t]
%DIFDELCMD < {\small
%DIFDELCMD <   \begin{mathpar}
%DIFDELCMD <     \inferrule[T-Cast]
%DIFDELCMD <               {m = \cmode \Rightarrow \tau \neq\tptr{\tau''}{\cmode} \text{ for any $\tau''$} \\\\
%DIFDELCMD <                 \Gamma;\Theta \vdash_m e : \tau'}
%DIFDELCMD <               {\Gamma;\Theta \vdash_m \ecast{\tau}{e} : \tau}
%DIFDELCMD <               

%DIFDELCMD <      \inferrule[T-CastCheckedPtr]
%DIFDELCMD <                {\Gamma;\Theta \vdash_m e : \tau' \\
%DIFDELCMD <                  \tau' \sqsubseteq \tptr{\tau}{\cmode}}
%DIFDELCMD <                {\Gamma;\Theta \vdash_m \ecast{\tptr{\tau}{\cmode}}{e} : \tptr{\tau}{\cmode}}
%DIFDELCMD <                 

%DIFDELCMD <       \inferrule[T-DynCast]
%DIFDELCMD <                 {\Gamma;\Theta \vdash_m e : \tptr{\tallarrayb{\bvar'}{\tau}}{m}}
%DIFDELCMD <                 {\Gamma;\Theta \vdash_m \edyncast{\tptr{\tallarrayb{\bvar}{\tau}}{m}}{e} : \tptr{\tallarrayb{\bvar}{\tau}}{m}}
%DIFDELCMD <                 

%DIFDELCMD <       \inferrule[T-Str]
%DIFDELCMD <                 {\Gamma; \Theta \vdash_m e :  \tptr{\tntarrayb{\bvar}{\tau_a}}{m} 
%DIFDELCMD <                 }
%DIFDELCMD <                 {\Gamma;\Theta \vdash_m \estrlen{e} : \tint}
%DIFDELCMD < 

%DIFDELCMD <       \inferrule[T-LetStr]
%DIFDELCMD <                 {\Gamma(y) = \tntarrayptr{b_l}{b_h}{\tau_a}{\cmode} \\ x \not\in \fv(\tau) \\\\
%DIFDELCMD <                  \Gamma[x\mapsto \tint,y\mapsto [\tntarrayptr{b_l}{x}{\tau_a}{\cmode}];\Theta[x\mapsto \texttt{ge}\_0] \vdash_m e : \tau}
%DIFDELCMD <                 {\Gamma;\Theta \vdash_m \elet{x}{\estrlen{y}}{e} : \tau}
%DIFDELCMD < 

%DIFDELCMD <                 \inferrule[T-Ret]
%DIFDELCMD <     {\Gamma(x)\neq \bot \\
%DIFDELCMD <           \Gamma;\Theta \vdash_m e : \tau}
%DIFDELCMD <     {\Gamma;\Theta \vdash_m \eret{x}{\mu}{e} : \tau}
%DIFDELCMD < 

%DIFDELCMD <       \inferrule[T-If ]
%DIFDELCMD <         {\Gamma; \Theta \vdash_m e : \tau \\\\ \Gamma; \Theta \vdash_m e_1 : \tau_1 \\\\ \Gamma; \Theta \vdash_m e_2 : \tau_2}
%DIFDELCMD <         {\Gamma; \Theta \vdash_m \eif{e}{e_1}{e_2} : \tau_1 \sqcup \tau_2}
%DIFDELCMD <         

%DIFDELCMD <       \inferrule [T-IfNT]
%DIFDELCMD <                 { \Gamma; \Theta \vdash_m x : \tptr{\tntarrayb{(b_l,0)}{\tau}}{c} \\\\
%DIFDELCMD <                    \Gamma[x \mapsto \tptr{\tntarrayb{(b_l,1)}{\tau}}{c}]; \Theta \vdash_m e_1 : \tau_1\\\\
%DIFDELCMD <                   \Gamma;\Theta \vdash_m e_2 : \tau_2 }
%DIFDELCMD <                 {\Gamma;\Theta \vdash_m \eif{\estar{x}}{e_1}{e_2} : \tau_1 \sqcup \tau_2}
%DIFDELCMD < 

%DIFDELCMD <    \inferrule[T-Let]
%DIFDELCMD <     { x\in \fv(\tau') \Rightarrow e_1 \in \text{Bound} \\\\
%DIFDELCMD <         \Gamma;\Theta \vdash_m e_1 : \tau \\\\
%DIFDELCMD <            \Gamma[x\mapsto \tau];\Theta \vdash_m e_2 : \tau'
%DIFDELCMD <              }
%DIFDELCMD <     {\Gamma;\Theta \vdash_m \elet{x}{e_1}{e_2} : \tau'[e_1 / x]}
%DIFDELCMD < 

%DIFDELCMD <     \inferrule[T-DefArr]
%DIFDELCMD <               {m \leq m' \\\\ \Gamma;\Theta \vdash_{m} e : \tptr{\tallarrayb{\bvar}{\tau}}{m'}}
%DIFDELCMD <               {\Gamma;\Theta \vdash_m \estar{e} : \tau}
%DIFDELCMD < 

%DIFDELCMD <     \inferrule[T-AssignArr]
%DIFDELCMD <               {\Gamma; \Theta \vdash_m e_1 : \tptr{\tallarrayb{\bvar}{\tau}}{m'}\\\\
%DIFDELCMD <                 \Gamma; \Theta \vdash_m e_2 : \tau' \\
%DIFDELCMD <                 \tau'\sqsubseteq \tau\\
%DIFDELCMD <                 m \leq m'}
%DIFDELCMD <               {\Gamma; \Theta \vdash_m \eassign{e_1}{e_2} : \tau}
%DIFDELCMD < 

%DIFDELCMD < \inferrule[T-Fun]
%DIFDELCMD <     {\Xi(f) = \tau\;(\overline{x}:\overline{\tau})\;e \\\\
%DIFDELCMD <         \Gamma; \Theta \vdash_m \overline{e} : \overline{\tau'} \\
%DIFDELCMD <              \overline{\tau'} \sqsubseteq 
%DIFDELCMD <                \overline{\tau}[\overline{e} / \overline{x}]}
%DIFDELCMD <     {\Gamma; \Theta \vdash_m f(\overline{e}) : \tau[\overline{e} / \overline{x}]}
%DIFDELCMD <   \end{mathpar}
%DIFDELCMD < }
%DIFDELCMD < \caption{Selected Type Rules}
%DIFDELCMD < \label{fig:type-system-1}
%DIFDELCMD < \end{figure*}
%DIFDELCMD < \end{DIFnomarkup}
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \begin{DIFnomarkup}
\begin{figure*}[t]
{\small
  \begin{mathpar}
    \inferrule[T-DefArr]
              {m \leq m' \\\\ \Gamma;\Theta \vdash_{m} e : \tptr{\tallarrayb{\bvar}{\tau}}{m'}}
              {\Gamma;\Theta \vdash_m \estar{e} : \tau}

    \inferrule[T-AssignArr]
              {\Gamma; \Theta \vdash_m e_1 : \tptr{\tallarrayb{\bvar}{\tau}}{m'}\\\\
                \Gamma; \Theta \vdash_m e_2 : \tau' \\
                \tau'\sqsubseteq \tau\\
                m \leq m'}
              {\Gamma; \Theta \vdash_m \eassign{e_1}{e_2} : \tau}

    \inferrule[T-Unchecked]
              {\Gamma;\Theta \vdash_u e : \tau}
              {\Gamma;\Theta \vdash_m \eunchecked{e} : \tau}

    \inferrule[T-Cast]
              {m = \cmode \Rightarrow \tau \neq\tptr{\tau''}{\cmode} \text{ for any $\tau''$} \\\\
                \Gamma;\Theta \vdash_m e : \tau'}
              {\Gamma;\Theta \vdash_m \ecast{\tau}{e} : \tau}

     \inferrule[T-CastCheckedPtr]
               {\Gamma;\Theta \vdash_m e : \tau' \\
                 \tau' \sqsubseteq \tptr{\tau}{\cmode}}
               {\Gamma;\Theta \vdash_m \ecast{\tptr{\tau}{\cmode}}{e} : \tptr{\tau}{\cmode}}

      \inferrule[T-DynCast]
                {\Gamma;\Theta \vdash_m e : \tptr{\tallarrayb{\bvar'}{\tau}}{m}}
                {\Gamma;\Theta \vdash_m \edyncast{\tptr{\tallarrayb{\bvar}{\tau}}{m}}{e} : \tptr{\tallarrayb{\bvar}{\tau}}{m}}

      \inferrule[T-If ]
        {\Gamma; \Theta \vdash_m e : \tau \\\\ \Gamma; \Theta \vdash_m e_1 : \tau_1 \\\\ \Gamma; \Theta \vdash_m e_2 : \tau_2}
        {\Gamma; \Theta \vdash_m \eif{e}{e_1}{e_2} : \tau_1 \sqcup \tau_2}

      \inferrule [T-IfNT]
                { \Gamma; \Theta \vdash_m x : \tptr{\tntarrayb{(b_l,0)}{\tau}}{c} \\\\
                   \Gamma[x \mapsto \tptr{\tntarrayb{(b_l,1)}{\tau}}{c}]; \Theta \vdash_m e_1 : \tau_1\\\\
                  \Gamma;\Theta \vdash_m e_2 : \tau_2 }
                {\Gamma;\Theta \vdash_m \eif{\estar{x}}{e_1}{e_2} : \tau_1 \sqcup \tau_2}

      \inferrule[T-Str]
                {\Gamma; \Theta \vdash_m e :  \tptr{\tntarrayb{\bvar}{\tau_a}}{m} 
                }
                {\Gamma;\Theta \vdash_m \estrlen{e} : \tint}

      \inferrule[T-LetStr]
                {\Gamma(y) = \tntarrayptr{b_l}{b_h}{\tau_a}{\cmode} \\ x \not\in \fv(\tau) \\\\
                 \Gamma[x\mapsto \tint,y\mapsto [\tntarrayptr{b_l}{x}{\tau_a}{\cmode}];\Theta[x\mapsto \texttt{ge}\_0] \vdash_m e : \tau}
                {\Gamma;\Theta \vdash_m \elet{x}{\estrlen{y}}{e} : \tau}


   \inferrule[T-Let]
    { x\in \fv(\tau') \Rightarrow e_1 \in \text{Bound} \\\\
        \Gamma;\Theta \vdash_m e_1 : \tau \\
           \Gamma[x\mapsto \tau];\Theta \vdash_m e_2 : \tau'
             }
    {\Gamma;\Theta \vdash_m \elet{x}{e_1}{e_2} : \tau'[e_1 / x]}



\inferrule[T-Fun]
    {\Xi(f) = \tau\;(\overline{x}:\overline{\tau})\;e \\
        \Gamma; \Theta \vdash_m \overline{e} : \overline{\tau'} \\
             \overline{\tau'} \sqsubseteq 
               \overline{\tau}[\overline{e} / \overline{x}]}
    {\Gamma; \Theta \vdash_m f(\overline{e}) : \tau[\overline{e} / \overline{x}]}


                \inferrule[T-Ret]
    {\Gamma(x)\neq \bot \\
          \Gamma;\Theta \vdash_m e : \tau}
    {\Gamma;\Theta \vdash_m \eret{x}{\mu}{e} : \tau}

  \end{mathpar}
}
\caption{Selected type rules}
\label{fig:type-system-1}
\end{figure*}
\end{DIFnomarkup}
\DIFaddend 

\myparagraph{Pointer Access}
Rules \textsc{T-DefArr} and \textsc{T-AssignArr} typecheck array
dereference and assignment operations resp.\DIFaddbegin \DIFadd{, }\DIFaddend returning the type of
pointed-to objects; rules for pointers to single objects are
similar.
The condition $m\le m'$ ensures that \DIFdelbegin \DIFdel{checked pointers cannot
}\DIFdelend \DIFaddbegin \DIFadd{unchecked pointers can only
}\DIFaddend be dereferenced in \DIFdelbegin \DIFdel{$\eunchecked{e}$ }\DIFdelend \DIFaddbegin \DIFadd{unchecked }\DIFaddend blocks;
the type rule for
$\eunchecked{e}$ \DIFdelbegin \DIFdel{(not shown) }\DIFdelend sets $m = \umode$ when checking $e$.
The rules do not attempt to reason whether the access is in bounds;
this check is deferred to the semantics.



\myparagraph{Casting and Subtyping}
Rule \textsc{T-Cast} rule forbids casting to checked pointers when in checked
regions (when $m = \cmode$), but $\tau$ is unrestricted when
$m = \umode$. The \textsc{T-CastCheckedPtr} rule
permits casting from an expression of type $\tau'$ to a checked pointer when
$\tau' \sqsubseteq \tptr{\tau}{\cmode}$. This subtyping relation
$\sqsubseteq$ is given in Fig.~\ref{fig:checkc-subtype}; the many
rules ensure the relation is transitive. Most of the rules handle
casting between array pointer types; the second rule 
$0\le b_l \wedge b_h \le 1 \Rightarrow \tptr{\tau}{m}\sqsubseteq
\tarrayptr{b_l}{b_h}{\tau}{m}$ permits treating a singleton
pointer as an array pointer with $b_h\le 1$ and $0 \le b_l$.

Since bounds expressions may
contain variables, determining assumptions like $b_l \leq b_l'$
requires reasoning about those variables' possible values. The type
system uses $\Theta$ to make such reasoning more precise.\footnote{So,
  technically, the subtyping relation $\sqsubseteq$ and the bounds
  ordering relation $\leq$ are parameterized by $\Theta$; this fact is
  implicit to avoid clutter.} $\Theta$ is a map from variables $x$ to
predicates $P$, which have the form $P ::= \top \;|\; \texttt{ge}\_0$.
If $\Theta$ maps $x$ to $\top$, that means that the variable can
possibly be any value; $\texttt{ge}\_0$ means that $x \ge 0$. We will
see how $\Theta$ gets populated and give a detailed example of
subtyping below.\footnote{As it turns out, the subtyping relation is
  also parameterized by $\varphi$, which is needed when type checking
  intermediate results to prove type preservation; source programs
  would always have $\varphi = \emptyset$. Details are in
\DIFaddbegin \iftr
  \DIFaddend Appendix~\ref{app:le}.
\DIFaddbegin \else
  \DIFadd{the supplemental report~}\cite{checkedc-tech-report}\DIFadd{.
}\fi
\DIFaddend }

Rule \textsc{T-DynCast} typechecks dynamic casting operations, which
apply to array pointer types only. The cast is accepted by the type
system, as its legality will be checked by the semantics.

\DIFdelbegin %DIFDELCMD < \begin{DIFnomarkup}
%DIFDELCMD < \begin{figure}
%DIFDELCMD < {\small
%DIFDELCMD < \begin{center}
%DIFDELCMD <   $\begin{array}{r@{~}c@{~}l@{~}c@{~}l}
%DIFDELCMD <     &&\multicolumn{1}{r}{\tau} &\sqsubseteq& \tau\\[0.6em]
%DIFDELCMD <     0\le b_l \wedge b_h \le 1 &\Rightarrow& \tptr{\tau}{m}&\sqsubseteq& \tarrayptr{b_l}{b_h}{\tau}{m}\\[0.6em]
%DIFDELCMD <     b_l \le 0 \wedge 1 \le b_h &\Rightarrow& \tarrayptr{b_l}{b_h}{\tau}{m} &\sqsubseteq& \tptr{\tau}{m}\\[0.6em]
%DIFDELCMD <     b_l \le 0 \wedge 1 \le b_h &\Rightarrow& \tntarrayptr{b_l}{b_h}{\tau}{m} &\sqsubseteq& \tptr{\tau}{m}\\[0.6em]
%DIFDELCMD < b_l \le b_l' \wedge b_h' \le b_h &\Rightarrow& \tntarrayptr{b_l}{b_h}{\tau}{m} &\sqsubseteq& \tarrayptr{b_l'}{b_h'}{\tau}{m}\\[0.6em]
%DIFDELCMD <     b_l \le b_l' \wedge b_h' \le b_h &\Rightarrow& \tallarrayptr{b_l}{b_h}{\tau}{m} &\sqsubseteq& \tallarrayptr{b_l'}{b_h'}{\tau}{m}
%DIFDELCMD <     \end{array}
%DIFDELCMD <   $
%DIFDELCMD < \end{center}
%DIFDELCMD < }
%DIFDELCMD <   \caption{Subtyping Relation}
%DIFDELCMD <   \label{fig:checkc-subtype}
%DIFDELCMD < \end{figure}
%DIFDELCMD < \end{DIFnomarkup}
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \begin{DIFnomarkup}
\begin{figure}
{\small
\begin{center}
  %
\mbox{%DIFAUXCMD
$\begin{array}{r@{~}c@{~}l@{~}c@{~}l}
    &&\multicolumn{1}{r}{\tau} &\sqsubseteq& \tau\\[0.6em]
    0\le b_l \wedge b_h \le 1 &\Rightarrow& \tptr{\tau}{m}&\sqsubseteq& \tarrayptr{b_l}{b_h}{\tau}{m}\\[0.6em]
    b_l \le 0 \wedge 1 \le b_h &\Rightarrow& \tarrayptr{b_l}{b_h}{\tau}{m} &\sqsubseteq& \tptr{\tau}{m}\\[0.6em]
    b_l \le 0 \wedge 1 \le b_h &\Rightarrow& \tntarrayptr{b_l}{b_h}{\tau}{m} &\sqsubseteq& \tptr{\tau}{m}\\[0.6em]
b_l \le b_l' \wedge b_h' \le b_h &\Rightarrow& \tntarrayptr{b_l}{b_h}{\tau}{m} &\sqsubseteq& \tarrayptr{b_l'}{b_h'}{\tau}{m}\\[0.6em]
    b_l \le b_l' \wedge b_h' \le b_h &\Rightarrow& \tallarrayptr{b_l}{b_h}{\tau}{m} &\sqsubseteq& \tallarrayptr{b_l'}{b_h'}{\tau}{m}
    \end{array}
  $
}%DIFAUXCMD
\end{center}
}
  \caption{Subtyping}
  \label{fig:checkc-subtype}
\end{figure}
\end{DIFnomarkup}
\DIFaddend 

\myparagraph{Bounds Widening}
The bounds of NT array pointers may be widened at conditionals, and
due to calls to $\estrlentext$.  Rule \textsc{T-If} handles normal
branching operations; rule \textsc{T-IfNT} is specialized to the case
of branching on $\estar{x}$ when $x$ is a NT array pointer whose upper
bound is 0. In this case, true-branch $e_1$ is checked with $x$'s type
updated so that its upper bound is incremented by 1; the else-branch
$e_2$ is typechecked under the existing assumptions. For both rules,
the resulting type is the join of the types of the two branches
(according to subtyping). This is important for the situation when $x$
itself is part of the result, since $x$ will have
different types in the two branches.



Rule \textsc{T-Str} handles the case for when $\estrlentext(y)$ does
not appear in a let binding. Rule \textsc{T-LetStr} handles the case
when it does, and performs bounds widening. The result of the call is
stored in variable $x$, and the type of $y$ is updated in $\Gamma$ when
checking the let-body $e$ to indicate that $x$ is $y$'s upper
bound. Notice that the lower bound $b_l$ is unaffected by the call to
$\estrlentext(y)$; this is sound because we know that $\estrlentext$
will always return a result $n$ such that $n \ge b_h$, the current
view of $x$'s upper bound.
The type rule tracks $\estrlentext$'s widened bounds
within the scope of $x$, while the bound-widening effect in the semantics applies to the lifetime of $y$.
Our type preservation theorem in Sec.~\ref{sec:theorem}
shows that our type system is a sound model of the \CoreChkC semantics,
and we discuss how we guarantee that the behavior of our compiler formalization and the semantics matches in Sec.~\ref{sec:compilation}.

This rule also extends $\Theta$ when checking $e$, adding a predicate
indicating that $x\ge 0$. To see how this information is used,
consider this example.  The \code{return} on line \DIFdelbegin \DIFdel{16 }\DIFdelend \DIFaddbegin \DIFadd{13 }\DIFaddend of
Fig.~\DIFdelbegin \DIFdel{\ref{fig:strncat-ex} }\DIFdelend \DIFaddbegin \DIFadd{\ref{fig:strcat-ex} }\DIFaddend has an implicit static cast from the
returned expression to the declared function type (see rule
\textsc{T-Fun}, described below). In type checking the $\estrlentext$
on line 4, we insert a predicate in $\Theta$ showing
\DIFdelbegin %DIFDELCMD < \code{n}%%%
\DIFdelend \DIFaddbegin \code{x}\DIFaddend $\;\ge 0$.  The static cast on line \DIFdelbegin \DIFdel{16 }\DIFdelend \DIFaddbegin \DIFadd{13 }\DIFaddend is valid according \DIFdelbegin \DIFdel{ot
}\DIFdelend \DIFaddbegin \DIFadd{to
}\DIFaddend the last line in Fig.~\ref{fig:checkc-subtype}:
\DIFaddbegin 

\DIFaddend {\small
$$
\DIFdelbegin %DIFDELCMD < \tallarrayptr{0}{n}{\tau}{c} %%%
\DIFdelend \DIFaddbegin \tallarrayptr{0}{x}{\tau}{c} \DIFaddend \sqsubseteq \tallarrayptr{0}{0}{\tau}{c}
$$
}
because $0 \leq 0$ and \DIFdelbegin \DIFdel{$0 \leq n$}\DIFdelend \DIFaddbegin \DIFadd{$0 \leq x$}\DIFaddend , where the latter holds since
$\Theta$ proves \DIFdelbegin \DIFdel{$n \ge 0$}\DIFdelend \DIFaddbegin \DIFadd{$x \ge 0$}\DIFaddend .  Without $\Theta$, we would need a
dynamic cast.

In our formal presentation, $\Theta$ is quite simple and is just meant
to illustrate how static information can be used to avoid dynamic
checks; it is easy to imagine richer environments of facts that can be
leveraged by, say, an SMT solver as part of the subtyping
check \cite{LiquidHaskell,Refinementlh}





\myparagraph{Dependent Functions and Let Bindings}
Rule \textsc{T-Fun} is the standard dependent function call rule. It
looks up the definition of the function in the function environment
$\Xi$, typechecks the actual arguments $\overline{e}$ which have
types $\overline{\tau'}$, and then confirms that each of these types
is a subtype of the declared type of $f$'s corresponding parameter. Because
functions have dependent types, we substitute each parameter $e_i$ for
its corresponding parameter $x_i$ in both the parameter types and the
return type. Consider the \DIFdelbegin %DIFDELCMD < \code{strncat} %%%
\DIFdelend \DIFaddbegin \code{safe_strcat} \DIFaddend function in
Fig.~\DIFdelbegin \DIFdel{\ref{fig:strncat-ex}}\DIFdelend \DIFaddbegin \DIFadd{\ref{fig:strcat-ex}}\DIFaddend ; its parameter type for \DIFdelbegin %DIFDELCMD < \code{a} 
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \code{dst} 
\DIFaddend depends on \code{n}. The \textsc{T-Fun} rule will substitute 
\code{n} with the argument at a call-site.

Rule \textsc{T-Let} types a $\elettext$ expression, which also admits
type dependency. In particular, the result of evaluating a $\elettext$
may have a type that refers to one of its bound variables (e.g., if
the result is a checked pointer with a variable-defined bound); if so,
we must substitute away this variable once it goes out of scope. Note
that we restrict the expression $e_1$ to syntactically match the
structure of a Bounds expression $b$ (see Fig.~\ref{fig:checkc-syn}).

Rule \textsc{T-Ret} types a $\erettext$ expression, which does not
appear in source programs but is introduced by the semantics when
evaluating a let binding (rule \textsc{S-Let} in
Fig.~\ref{fig:semantics}); this rule is needed for the preservation
proof. After the evaluation of a let binding a variable $x$ concludes,
we need to restore any prior binding of $x$, which is either
$\bot$ (meaning that there is no $x$ originally) or some value
$\evalue{n}{\tau}$.

\subsection{Type Soundness and Blame}\label{sec:theorem}





In this subsection, we focus on our main metatheoretic results about
\lang: type soundness (progress and preservation) and
blame.
  \DIFaddbegin \DIFadd{These proofs have been carried out in our
  Coq model, found at }\url{https://github.com/plum-umd/checkedc}\DIFadd{.
}

\DIFaddend The type soundness theorems rely on \DIFdelbegin \DIFdel{a notion of
heap and stack
}\DIFdelend \DIFaddbegin \DIFadd{several notions of
}\DIFaddend \emph{well-formedness}:

\DIFdelbegin %DIFDELCMD < \smallskip
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \begin{defi}[Type Environment Well-formedness]\label{type-wellformed}
\DIFadd{A type environment $\Gamma$ is well-formed iff every variable mentioned as type bounds in $\Gamma$ are bounded by $\tnat$ typed variables in $\Gamma$.
}\end{defi}

\DIFaddend \begin{defi}[Heap Well-formedness]
A heap $\heap$ is well-formed \DIFdelbegin \DIFdel{, }\DIFdelend iff (i) \DIFdelbegin \DIFdel{the null position
($0$) is not defined in $\heap$}\DIFdelend \DIFaddbegin \DIFadd{$\heap(0)$ is undefined}\DIFaddend , and
(ii) \DIFdelbegin \DIFdel{every type annotation in it
}\DIFdelend \DIFaddbegin \DIFadd{for all $\evalue{n}{\tau}$ in the range of $\heap$, type $\tau$
}\DIFaddend contains no free variables. 
\end{defi}
\DIFdelbegin %DIFDELCMD < \smallskip
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin 

\DIFaddend \begin{defi}[Stack Well-formedness]
A stack snapshot $\varphi$ is well-formed \DIFdelbegin \DIFdel{, iff
every type annotation in it }\DIFdelend \DIFaddbegin \DIFadd{iff
for all $\evalue{n}{\tau}$ in the range of $\varphi$, type $\tau$
}\DIFaddend contains no free variables. 
\end{defi}
\DIFdelbegin %DIFDELCMD < \smallskip
%DIFDELCMD < %%%
\DIFdelend 

\DIFaddbegin \DIFadd{We also need to introduce a notion of
}\emph{\DIFadd{consistency}}\DIFadd{, relating heap environments before and after a
reduction step, and type environments, predicate sets, and stack
snapshots together.
}


\begin{defi}[Stack Consistency]
\DIFadd{A type environment $\Gamma$, variable predicate set $\Theta$, and
stack snapshot $\varphi$ are consistent---written $\Gamma;\Theta\vdash
\varphi$---iff for every variable $x$, $\Theta(x)$ is defined implies
$\Gamma(x) = \tau$ for some $\tau$ and 
$\varphi(x) =\evalue{n}{\tau'}$ for some $n,\tau'$ where $\tau' \sqsubseteq \tau$. 
}\end{defi}

\begin{defi}[Stack-Heap Consistency]
\DIFadd{A stack snapshot $\varphi$ is consistent with heap $\heap$---written $\heap \vdash \varphi$---iff
for every variable $x$, $\varphi(x)= \evalue{n}{\tau}$ implies $\heap;\emptyset \vdash n:\tau$.
}\end{defi}

\begin{defi}[Heap-Heap Consistency]
\DIFadd{A heap $\heap'$ is consistent with $\heap$---written $\heap \triangleright \heap'$---iff
for every constant $n$, $\heap;\emptyset \vdash n:\tau$ implies $\heap';\emptyset \vdash n:\tau$.
}\end{defi}

\DIFaddend Moreover, as a program evaluates its expression may contain literals
\DIFdelbegin \DIFdel{$n\!:\!\tau$ }\DIFdelend \DIFaddbegin \DIFadd{$\evalue{n}{\tau}$ }\DIFaddend where $\tau$ is a pointer type, i.e., $n$ is an
index in $\heap$ (perhaps because $n$ was chosen by
$\mathtt{malloc}$). The normal typechecking judgment for $e$ is
implicitly parameterized by $\heap$, and the rules for typechecking
literals confirm that pointed-to heap cells are compatible with
(subtypes of) the pointer's type annotation; in turn this check may
precipitate checking the type consistency of the heap itself. We
follow the same approach as \citet{ruef18checkedc-incr}, and show the
rules in
  \DIFaddbegin \DIFadd{Fig.~\ref{fig:const-type}; the judgment
  $\heap;\sigma \vdash n : \tau$ is used to confirm literal
  well-typing, where $\sigma$ is a set pointer literals already
  checked in $\heap$ (to allow pointer cycles). See
  }\iftr
  \DIFaddend Appendix~\ref{sec:literal-pointer-typing}
  \DIFaddbegin \else
  \DIFadd{the supplemental report~}\cite{checkedc-tech-report}
  \fi
   \DIFadd{for further discussion}\DIFaddend .

Progress now states that terms that don't reduce are either values or their
mode is unchecked:

\DIFdelbegin %DIFDELCMD < \smallskip
%DIFDELCMD < \begin{thm}[Type Progress Theorem]%%%
\DIFdelend \DIFaddbegin \begin{thm}[Progress]\DIFaddend \label{thm:progress}
\DIFaddbegin 

\DIFaddend For any \checkedc program $e$\DIFdelbegin \DIFdel{and }\DIFdelend \DIFaddbegin \DIFadd{, }\DIFaddend heap $\heap$, \DIFdelbegin \DIFdel{if $e$ and $\heap$ are }\DIFdelend \DIFaddbegin \DIFadd{stack
$\varphi$, type environment $\Gamma$, and variable predicate set $\Theta$
that are all are }\DIFaddend well-formed, \DIFdelbegin \DIFdel{and $\emptyset;\emptyset\vdash_m e : \tau$,
then }\DIFdelend \DIFaddbegin \DIFadd{consistent
($\Gamma;\Theta\vdash \varphi$ and $\heap \vdash \varphi$) and well
typed ($\Gamma;\Theta\vdash_{\cmode} e : \tau$ for some $\tau$),
one of the following holds:
}

\begin{itemize}

\item \DIFaddend $e$ is a value ($\evalue{n}{\tau}$)\DIFaddbegin \DIFadd{.
}

\item \DIFadd{there exists $\varphi'$ $\heap'$ $r$, such that $(\varphi,\heap,e) \longrightarrow_m (\varphi',\heap',r)$.
}

\item \DIFadd{$m = \umode$}\DIFaddend , \DIFdelbegin %DIFDELCMD < \code{unchecked} %%%
\DIFdel{($m=\umode$), }\DIFdelend or there exists \DIFdelbegin \DIFdel{$\varphi'$ $\heap'$ }\DIFdelend \DIFaddbegin \DIFadd{$E$ and }\DIFaddend $e'$, such that \DIFdelbegin \DIFdel{$(\emptyset,\heap,e)
\longrightarrow_m (\varphi',\heap',e')$.
}\DIFdelend \DIFaddbegin \DIFadd{$e = E[e']$ and $\mode(E) = \umode$.
}

\end{itemize}
\DIFaddend \end{thm}
{\em Proof:} By induction on the typing derivation.

\DIFdelbegin %DIFDELCMD < \smallskip
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \begin{DIFnomarkup}
 \begin{figure}[t]
 {\small
 \text{Type rules for constants and variables:}
 \begin{mathpar}
   \inferrule[T-Var]
       {x : \tau \in \Gamma}
       {\Gamma;\Theta \vdash_m x : \tau}

   \inferrule[T-Const]
       {\fv(\tau) = \emptyset \\ \heap;\emptyset \vdash n : \tau}
       {\Gamma;\Theta\vdash_m \evalue{n}{\tau} : \tau}
 \end{mathpar}

 \text{Rules for checking constant pointers:}
 \begin{mathpar}
   \inferrule
       {}
       {\heap;\sigma \vdash n : \tint}

   \inferrule
       {}
       {\heap;\sigma \vdash n : \tptr{\omega}{\umode}}

   \inferrule
       {}
       {\heap;\sigma \vdash 0 : \tptr{\omega}{\cmode}}

   \inferrule
       {(\evalue{n}{\tptr{\omega}{\cmode}})\in \sigma}
       {\heap;\sigma \vdash n : \tptr{\omega}{\cmode}}

   \inferrule
       {\forall i \in [0,\size(\omega)) .
            \heap;(\sigma \cup \{(n:\tptr{\omega}{\cmode})) \}\vdash \heap(n+i)}
       {\heap;\sigma \vdash n : \tptr{\omega}{\cmode}}
 \end{mathpar}
 }
 \caption{Type rules for constants/variables}
 \label{fig:const-type}
 \end{figure}
\end{DIFnomarkup}
\DIFaddend 

\DIFdelbegin \DIFdel{For preservation, we also need to introduce a notion of
}\emph{\DIFdel{consistency}}%DIFAUXCMD
\DIFdel{, relating heap environments before and after a
reduction step, and type environments, predicate sets, and stack
snapshots together.
}%DIFDELCMD < 

%DIFDELCMD < \smallskip
%DIFDELCMD < \begin{defi}[Type-Stack Consistency]
%DIFDELCMD < %%%
\DIFdel{A type environment $\Gamma$, variable predicate set $\Theta$, and stack snapshot $\varphi$ are consistent, iff every variable defined in $\Theta$ is defined in $\Gamma$, and for every variable $x$, $\Gamma(x) = \tau$ implies that $\varphi(x)$ is defined and there exists $n$ and $\tau'$, such that $\varphi(x)=\evalue{n}{\tau'}$ and $\tau' \sqsubseteq \tau$.
}%DIFDELCMD < \end{defi}
%DIFDELCMD < \smallskip
%DIFDELCMD < \begin{defi}[Heap Consistency]
%DIFDELCMD < %%%
\DIFdel{A heap $\heap'$ is consistent with $\heap$ iff every address defined
in $\heap$ is defined in $\heap'$.
}%DIFDELCMD < \end{defi}
%DIFDELCMD < \smallskip
%DIFDELCMD < 

%DIFDELCMD < %%%
\DIFdelend \noindent
\DIFdelbegin \DIFdel{Armed with the definitions of consistency, we can now prove
preservation, which }\DIFdelend \DIFaddbegin \DIFadd{Preservation }\DIFaddend states that a reduction step preserves both the
type \DIFdelbegin \DIFdel{of the expression being reduced, as well as well-formedness and
consistency of environments:
}\DIFdelend \DIFaddbegin \DIFadd{and consistency of the program being reduced.
}\DIFaddend 

\DIFdelbegin %DIFDELCMD < \smallskip
%DIFDELCMD < \begin{thm}[Type Preservation Theorem]
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \begin{thm}[Preservation]
\DIFaddend For any \checkedc program $e$, heap $\heap$, stack
$\varphi$, type environment $\Gamma$, \DIFaddbegin \DIFadd{and }\DIFaddend variable predicate set $\Theta$
\DIFdelbegin \DIFdel{,
and a type $\tau$, }\DIFdelend that are all are well-formed, \DIFdelbegin \DIFdel{if $\Gamma, \Theta$,
and $\varphi$ are consistent
, $e$ is well
typed $\Gamma;\Theta\vdash_{\cmode} e : \tau$, }\DIFdelend \DIFaddbegin \DIFadd{consistent
($\Gamma;\Theta\vdash \varphi$ }\DIFaddend and \DIFaddbegin \DIFadd{$\heap \vdash \varphi$) and well
typed ($\Gamma;\Theta\vdash_{\cmode} e : \tau$ for some $\tau$), }\DIFaddend if there exists $\varphi'$,
$\heap'$ and $e'$, such that $(\varphi,\heap,e)
\longrightarrow_{\cmode} (\varphi',\heap',e')$, then \DIFaddbegin \DIFadd{$\heap'$ is
consistent with $\heap$ ($\heap \triangleright \heap'$) and }\DIFaddend there exists
$\Gamma'$, $\Theta'$ and $\tau'$ \DIFdelbegin \DIFdel{, such that $\Gamma'$, $\Theta'$,
$\varphi'$, $\heap'$ }\DIFdelend \DIFaddbegin \DIFadd{that are well formed, consistent
($\Gamma';\Theta'\vdash \varphi'$ }\DIFaddend and \DIFdelbegin \DIFdel{$e'$ are well-formed, $\Gamma'$, $\Theta'$
and $\varphi'$ are consistent
, $\heap'$ is consistent with $\heap$,
}\DIFdelend \DIFaddbegin \DIFadd{$\heap' \vdash \varphi'$) and
well typed (}\DIFaddend $\Gamma';\Theta' \vdash_{\cmode} e: \tau'$\DIFdelbegin \DIFdel{, and }\DIFdelend \DIFaddbegin \DIFadd{), where
}\DIFaddend $\tau'\sqsubseteq \tau$.
\end{thm}
{\em Proof:} By induction on the typing derivation.
\smallskip

Using \DIFdelbegin \DIFdel{type soundness }\DIFdelend \DIFaddbegin \DIFadd{these two theorems }\DIFaddend we can prove our main result, {\em blame},
which states that
  if \DIFdelbegin \DIFdel{there is any spatial memory safety violation is triggered, it must necessarily come from the
}\DIFdelend \DIFaddbegin \DIFadd{a well-typed program is }\emph{\DIFadd{stuck}}\DIFadd{---expression
$e$ is a non-value that cannot take a step}\footnote{\DIFadd{Note that
  $\ebounds$ and $\enull$ are }\emph{\DIFadd{not}} \DIFadd{stuck expressions---they represent a
  program terminated by a failed run-time check. A program that tries to access $\heap{n}$
  but $\heap$ is undefined at $n$ will be stuck, and violates spatial
  safety.}}\DIFadd{---the cause must be the
(past or imminent) execution of code in an }\DIFaddend unchecked region.



\DIFdelbegin %DIFDELCMD < \smallskip
%DIFDELCMD < \begin{thm}%%%
\DIFdelend \DIFaddbegin \begin{thm}[The Blame Theorem]\DIFaddend \label{thm:blame} \DIFdelbegin %DIFDELCMD < [%%%
\DIFdel{The Blame Theorem}%DIFDELCMD < ] %%%
\DIFdelend For any \checkedc
  program $e$, heap $\heap$, \DIFdelbegin \DIFdel{type $\tau$, if $\heap$ and $e$ }\DIFdelend \DIFaddbegin \DIFadd{stack
$\varphi$, type environment $\Gamma$, and variable predicate set $\Theta$
that }\DIFaddend are well-formed \DIFaddbegin \DIFadd{and consistent
($\Gamma;\Theta\vdash \varphi$ and $\heap \vdash \varphi$),
if $e$ is well-typed ($\varphi;\theta\vdash_{\cmode} e :
\tau$ for some $\tau$) and there exists
$\varphi_i$, $\heap_i$, $e_i$, and $m_i$ for $i\in [1,k]$}\DIFaddend , \DIFdelbegin \DIFdel{$\emptyset;\emptyset\vdash_{\cmode} e : \tau$, and if there exists
$\varphi'$, $\heap'$, a failure result $r$, and $m$, }\DIFdelend such that
\DIFdelbegin \DIFdel{$(\varphi,\heap,e) \longrightarrow_m^* (\varphi',\heap',r)$}\DIFdelend \DIFaddbegin \DIFadd{$(\varphi,\heap,e) \longrightarrow_{m_1} (\varphi_1,\heap_1,e_1)\longrightarrow_{m_2} ...\longrightarrow_{m_k} (\varphi_k,\heap_k,r)$ and $r$ is }\emph{\DIFadd{stuck}}\DIFaddend , then
there \DIFdelbegin \DIFdel{exist }\DIFdelend \DIFaddbegin \DIFadd{exists $j \in [1,k]$, such that $m_j = \umode$, or there exists }\DIFaddend $E$ and \DIFdelbegin \DIFdel{$e_a$}\DIFdelend \DIFaddbegin \DIFadd{$e'$}\DIFaddend , such that \DIFdelbegin \DIFdel{$e' = E[e_a]$, }\DIFdelend \DIFaddbegin \DIFadd{$r = E[e']$ }\DIFaddend and $\mode(E) = \umode$.
\end{thm}
{\em Proof:} By induction on the number of steps of the \checkedc
evaluation ($\longrightarrow_m^*$), using progress and preservation to
maintain the invariance of the assumptions.

\DIFdelbegin \DIFdel{These proofs have been carried out in a Coq development}\DIFdelend \DIFaddbegin \DIFadd{Compared to }\citet{ruef18checkedc-incr}\DIFadd{, proofs for
  }\lang \DIFadd{were made challenging by the addition of dependently typed
  functions and dynamic arrays, and the need to handle bounds widening for NT
  array pointers. These features required changes in the runtime
  semantics (adding a stack, and dynamically changing bounds) and in
  compile-time knowledge of them (to soundly typing widened bounds)}\DIFaddend .







































































































 %DIF <  \ignore{
%DIF <  \begin{figure}[t!]
%DIF <    \begin{prooftree}
%DIF <      \hypo{\evalue{n}{\tau} \in \defscope}
%DIF <      \infer1[T-VConst]{\Gamma;\defscope \vdash_m \evalue{n}{\tau}  : \tau}
%DIF <    \end{prooftree}
%DIF <    \qquad
\DIFdelbegin %DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{
%DIF <        \begin{matrix}
%DIF <          \Gamma;\defscope \vdash_m e : \tau \\
%DIF <          \Gamma;\defscope \vdash_m e_1 : \tau_1 
%DIF <        \end{matrix}
%DIF <      }
%DIF <      \hypo{
%DIF <        \begin{matrix}
%DIF <  \Gamma \vdash_m \tau_3 = \tau_1 \vee \tau_2 \\
%DIF <              \Gamma;\defscope \vdash_m e_2 : \tau_2
%DIF <            \end{matrix}
%DIF <          }
%DIF <      \infer2[T-If]{\Gamma;\defscope \vdash_m \eif{e}{e_1}{e_2} : \tau_3}
%DIF <    \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{
%DIF <        \begin{matrix}
%DIF <          \Gamma;\defscope \vdash_m x : \tptr[c]{(\tntarray{l}{0}{\tau})}, l \leq 0 \\
%DIF <          \Gamma, x : \tptr[c]{(\tntarray{l}{1}{\tau})};\defscope \vdash_m e_1 : \tau_1 \\
%DIF <          \Gamma;\defscope \vdash_m e_2 : \tau_2 \\
%DIF <          \Gamma \vdash_m \tau_3 = \tau_1 \vee \tau_2
%DIF <        \end{matrix}
%DIF <      }
%DIF <      \infer1[T-IfNT]{\Gamma;\defscope \vdash_m \eif{\estar{x}}{e_1}{e_2} : \tau_3}
%DIF <    \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{
%DIF <        \begin{matrix}
%DIF <          F(f) = \tau_{j}\;(x_0:\tau_0, \ldots, x_{j-1}:\tau_{j-1})\;e  \\
%DIF <          \Gamma; \defscope \vdash_m \tau_i[x_0,\ldots,x_{i-1} \mapsto e_0,\ldots,e_{i-1}] ~~~ 0 \leq i \leq j\\
%DIF <          \Gamma; \defscope \vdash_m e_i : \tau_i' ~~~ 0 \leq i \leq j\\
%DIF <          \Gamma; \defscope \vdash_m \subtype{\tau_i'}{\tau_i[x_0,\ldots,x_{i-1} \mapsto e_0,\ldots,e_{i-1}]}  ~~~ 0 \leq i < j
%DIF <        \end{matrix}
%DIF <      }
%DIF <      \infer1[T-VCall]{\Gamma; \defscope \vdash_m f(\overline{e}) : \tau_j[x_0,\ldots,x_{j-1} \mapsto e_0,\ldots,e_{j-1}]}
%DIF <    \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{
%DIF <            \Gamma; \defscope \vdash_m e_1 : \tau_1
%DIF <        }
%DIF <        \hypo{        \Gamma, x = e_1 : \tau_1; \defscope \vdash_m e_2 : \tau_2
%DIF <  }
%DIF <      \infer2[T-Let]{\Gamma; \defscope \vdash_m \elet{x}{e_1}{e_2} : \tau[x \mapsto e_1]}
%DIF <    \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{
%DIF <        \begin{matrix}
%DIF <          \Gamma; \defscope \vdash_m \estrlen{y} : \tau_1\\
%DIF <          \Gamma; \defscope \vdash_m y : \tptr[c]{(\tntarray{le}{\_}{\tau_3})}\\
%DIF <          \Gamma, x = \estrlen{y} : \tau_1, \\ y : \tptr[c]{(\tntarray{le}{x}{\tau_3})} ;  \defscope  \vdash_m e_2 : \tau_2
%DIF <          \end{matrix}
%DIF <          }
%DIF <          \infer1[T-LetStr]{\Gamma; \defscope \vdash_m \elet{x}{\estrlen{y}}{e_2} : \tau[x \mapsto e_1]}
%DIF <    \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{
%DIF <          \Gamma; \defscope \vdash_m e : \tptr[c]{(\tntarray{le}{he}{\tau})}
%DIF <        }
%DIF <          \infer1[T-Str]{\Gamma; \defscope \vdash_m \estrlen{y} : \tint}
%DIF <        \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <        \begin{prooftree}
%DIF <          \hypo{
%DIF <            \begin{matrix}
%DIF <              \tau = \tint \vee \tau = \tptr[u]{\omega}~\vee  n=0~ \vee \\ \tau = \tptr[c]{(\tarray{0}{0}{\tau'})} \vee \\
%DIF <              \tau = \tptr[c]{(\tntarray{0}{0}{\tau'})}
%DIF <          \end{matrix}
%DIF <        }
%DIF <        \infer1[T-Base]{\Gamma; \defscope \vdash_m \evalue{n}{\tau}  : \tau}
%DIF <      \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <      \begin{prooftree}
%DIF <        \hypo{
%DIF <          \begin{matrix}
%DIF <          \tau = \tptr[c]{\omega} \\
%DIF <          \tau_0, ..., \tau_{j-1} = \mathrm{types}(D,\omega)\\
%DIF <          \Gamma;\defscope, \evalue{n}{\tau}  \vdash_m {H(n+k)} : {\tau_k} ~~~ 0 \leq k < j
%DIF <        \end{matrix}
%DIF <        }
%DIF <        \infer1[T-PtrC]{\Gamma; \defscope \vdash_m \evalue{n}{\tau}  : \tau}
%DIF <      \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <      \begin{prooftree}
%DIF <        \hypo{
%DIF <          \begin{matrix}
%DIF <              \Gamma; \defscope \vdash_m e :  {\tptr[m]{\tstruct{T}}} \\
%DIF <  D(T) = ...; \tau_f~f; ...
%DIF <          \end{matrix}
%DIF <        }
%DIF <        \infer1[T-Amper]{\Gamma; \defscope \vdash_m \eamper{e}{f} : \tptr[m]{\tau_f}}
%DIF <      \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <      \todo[inline]{YL: how to express le - n as a metafunction?}
%DIF <      \begin{prooftree}
%DIF <        \hypo{
%DIF <          \begin{matrix}
%DIF <          \Gamma; \defscope \vdash_m e_1 : \tptr[m']{(\tgarray{\alpha}{le}{he}{\tau})}\\
%DIF <          \Gamma; \defscope \vdash_m \evalue{n}{\tau}  : \tint \\
%DIF <          le' = le - n, he' = he - n
%DIF <        \end{matrix}
%DIF <      }
%DIF <        \infer1[T-BinopInd]{\Gamma; \defscope \vdash_m (e_1 \plus \evalue{n}{\tau} ) : \tptr[m']{(\tgarray{\alpha}{le'}{he'}{\tau})}}
%DIF <      \end{prooftree}
%DIF <  \caption{Typing}
%DIF <  \label{fig:typing}
%DIF <  \end{figure}
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  \begin{figure}[t!]
%DIF <    \todo[inline]{no sizeof check because we don't know statically whether the allocation would be null}
%DIF <    \begin{prooftree}
%DIF <      \hypo{
%DIF <        \omega = \tgarray{\alpha}{le}{he}{\tau} \Rightarrow le = 0
%DIF <      }
%DIF <      \infer1[T-Malloc]{\Gamma; \defscope \vdash_m \emalloc{\omega} : \tptr[c]{\omega}}
%DIF <    \end{prooftree}\\\\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{
%DIF <        \Gamma; \defscope \vdash_u e : \tau
%DIF <      }
%DIF <      \infer1[T-Unchecked]{\Gamma; \defscope \vdash_m \eunchecked{e} : \tau}
%DIF <    \end{prooftree}\\\\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \todo[inline]{any constraints on m'?}
%DIF <    \begin{prooftree}
%DIF <      \hypo{\Gamma; \defscope \vdash_m e :  \tptr[m']{(\tgarray{\alpha}{le'}{he'}{\tau})} }
%DIF <      \infer1[T-DynCast]{\Gamma; \defscope \vdash_m \edyncast{\tptr[m']{(\tgarray{\alpha}{le}{he}{\tau})}}{e} : \tau}
%DIF <    \end{prooftree}\\\\
  %DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{\Gamma; \defscope \vdash_m e : \tau'}
%DIF <      \infer1[T-Cast]{\Gamma; \defscope \vdash_m \ecast{\tau}{e} : \tau}
%DIF <    \end{prooftree}\\\\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{
%DIF <        \begin{matrix}
%DIF <          \Gamma; \defscope \vdash_m e_1 : \tptr[m']{\tgarray{\alpha}{le}{he}{\tau}} \\
%DIF <          \Gamma; \defscope \vdash_m e_2 : \tint \\
%DIF <          m' = u \Rightarrow m = u \\
%DIF <        \end{matrix}
%DIF <      }
%DIF <      \infer1[T-Index]{\Gamma; \defscope \vdash_m \estar{(\ebinop{e_1}{e_2})} : \tau}
%DIF <    \end{prooftree} \\\\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{
%DIF <        \begin{matrix}
%DIF <          \Gamma; \defscope \vdash_m e_1 : \tptr[m']{\omega} \\
%DIF <          \Gamma; \defscope \vdash_m e_2 : \tau \\
%DIF <          m' = u \Rightarrow m = u \\
%DIF <          \omega = \tau \vee \omega = \tgarray{\alpha}{le}{he}{\tau}
%DIF <        \end{matrix}
%DIF <      }
%DIF <      \infer1[T-Assign]{\Gamma; \defscope \vdash_m \eassign{e_1}{e_2} : \tau}
%DIF <    \end{prooftree}\\\\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{
%DIF <        \begin{matrix}
%DIF <          \Gamma; \defscope \vdash_m e_1 : \tptr[m']{\omega} \\
%DIF <          \Gamma; \defscope \vdash_m e_2 : \tint \\
%DIF <          \Gamma; \defscope \vdash_m e_3 : \tau \\
%DIF <          m' = u \Rightarrow m = u \\
%DIF <          \omega = \tau \vee \omega = \tgarray{\alpha}{le}{he}{\tau}
%DIF <        \end{matrix}
%DIF <      }
%DIF <      \infer1[T-IndAssign]{\Gamma; \defscope \vdash_m \eassign{(e_1 \plus e_2)}{e_3} : \tau}
%DIF <    \end{prooftree}
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  \caption{Typing Cont.}
%DIF <  \label{fig:typing2}
%DIF <  \end{figure}
%DIF <  \ignore{
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  \begin{figure}[t!]
%DIF <    \begin{prooftree}
%DIF <      \hypo{
%DIF <        \begin{matrix}
%DIF <          \Gamma \vdash x_0:\tau_0, \ldots, x_{j}:\tau_{j} \\
%DIF <          \Gamma, x_0 = \kw{none} : \tau_0, \ldots, x_{j-1} = \kw{none} : \tau_{j-1}; \defscope \vdash e : \tau_{r}
%DIF <        \end{matrix}
%DIF <      }
%DIF <      \infer1[WF-Fun]{\Gamma;\defscope \vdash \tau_{j}\;(x_0:\tau_0, \ldots, x_{j-1}:\tau_{j-1})\;e}
%DIF <    \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \infer0[WF-Nil]{\Gamma \vdash \circ}
%DIF <    \end{prooftree} \\\\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{
%DIF <        \begin{matrix}
%DIF <          \Gamma \vdash \tau_0 \\
%DIF <          \Gamma, x_0 = \kw{none} :\tau_0 \vdash x_1:\tau_{1}, \ldots, x_{j}:\tau_{j}
%DIF <        \end{matrix}
%DIF <      }
%DIF <      \infer1[WF-Cons]{\Gamma \vdash x_0:\tau_0, \ldots, x_{j}:\tau_{j}}
%DIF <    \end{prooftree} \\\\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \infer0[WF-Int]{\Gamma \vdash \tint}
%DIF <    \end{prooftree} \\\\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{   \Gamma \vdash le }
%DIF <       \hypo{   \Gamma \vdash he }
%DIF <        \hypo{  \Gamma \vdash \tau}
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <      \infer3[WF-Array]{\Gamma \vdash \tptr[m]{(\tgarray{\alpha}{le}{he}{\tau})}}
%DIF <    \end{prooftree} \\\\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{T \in dom(D)}
%DIF <      \infer1[WF-Struct]{\Gamma \vdash \tptr[m]{\tstruct{T}}}
%DIF <    \end{prooftree} \\\\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{\Gamma \vdash \tau}
%DIF <      \infer1[WF-Ptr]{\Gamma \vdash \tptr[m]{\tau}}
%DIF <    \end{prooftree} \\\\
  %DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \infer0[WFB-Int]{\Gamma \vdash i}
%DIF <    \end{prooftree}\\\\
  %DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{x = e? : \tint \in \Gamma}
%DIF <      \infer1[WFB-Var]{\Gamma \vdash x \plus i}
%DIF <    \end{prooftree} \\\\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \caption{Well-Formedness}
%DIF <    \label{fig:wf}
%DIF <  \end{figure}
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  \begin{figure}[t!]
%DIF <    \begin{prooftree}
%DIF <      \infer0[Sub-Nt]{\subtype{\tptr[c]{(\tntarray{le}{he}{\tau})}}{\tptr[c]{(\tarray{le}{he}{\tau})}}}
%DIF <    \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \infer0[Sub-Refl]{\subtype{\tau}{\tau}}
%DIF <    \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \todo[inline]{what about ntarrays?}
%DIF <    \begin{prooftree}
%DIF <      \infer0[Sub-Ptr]{\subtype{\tptr[c]{\tau}}{\tptr{\tarray{0}{1}{\tau}}}}
%DIF <    \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \todo[inline]{the subtyping relation is not anti-symmetric..}
%DIF <    \begin{prooftree}
%DIF <      \infer0[Sub-Arr]{\subtype{\tptr[c]{\tarray{0}{1}{\tau}}}{\tptr{\tau}}}
%DIF <    \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <      \hypo{\rboundle{le_0}{le_1}}
%DIF <      \hypo{\rboundle{he_1}{he_0}}
%DIF <      \infer2[Sub-Subsume]{\subtype{\tptr{(\tgarray{\alpha}{le}{he}{\tau})}{\cmode}}{ \tptr{(\tgarray{\alpha}{ le_1} {he_1} {\tau})}}}
%DIF <    \end{prooftree} \\ \\
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{prooftree}
%DIF <  \hypo{D(T) = \tau_f~f; ...}
%DIF <      \hypo{\subtype{\tau_f}{\tau}}
%DIF <      \infer2{\subtype{\tptr[c]{\tstruct{T}}}{\tau}}
%DIF <    \end{prooftree}
%DIF <    \caption{Subtyping}
%DIF <    \label{fig:sub}
%DIF <  \end{figure}
%DIF <  }
%DIF <  }
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  \ignore{
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  \begin{figure*}[t]
%DIF <    \begin{lstlisting}
%DIF <  int foo(nt_array_ptr<char> p : count(0)) {
%DIF <    if (* p) {
%DIF <      dyn_bounds_cast<nt_array_ptr<char>>(p, count(1));
%DIF <    }
%DIF <    dyn_bounds_cast<nt_array_ptr<char>>(p, count(1));
%DIF <    return 0;
%DIF <  }
%DIF <    \end{lstlisting}
%DIF <  \caption{The example where clang Checked C fails at run-time}
%DIF <  \label{fig:clangbad1}
%DIF <  \end{figure*}
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  \begin{figure*}[t]
%DIF <    \begin{lstlisting}
%DIF <  /* nt_array_ptr<char> p : bounds(p,p) */
%DIF <  size_t cnt = 0;
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  while(*(p+cnt)) {
%DIF <    ++cnt;
%DIF <  }
%DIF <  dyn_bounds_cast<nt_array_ptr<char>>(p, count(cnt));
%DIF <    \end{lstlisting}
%DIF <  \caption{A useful program that the Checked C spec doesn't allow at run-time}
%DIF <  \label{fig:clangbad2}
%DIF <  \end{figure*}
%DIF <  }
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  \ignore{
%DIF <  The Clang CheckedC implementation uses statically determined
%DIF <  bounds to insert run-time checks. In Fig.~\ref{fig:clangbad1}, the
%DIF <  \code{dyn_bounds_cast} at line 3 will always succeed, because the
%DIF <  compiler knows that within the scope of then branch, the pointer
%DIF <  \code{p} must have at least one element. The same cast at line 5,
%DIF <  however, will always fail, since there is no way to tell statically
%DIF <  whether the program has entered the then branch before. The compiler
%DIF <  will check whether the \code{count(1)} bounds specification is
%DIF <  contained within the earlier \code{count(0)} specification, resulting
%DIF <  in a run-time failure even when we pass in a non-empty string.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Our formalization diverges from this run-time behavior and instead keeps
%DIF <  track of the bounds on the stack. After entering the then branch, we
%DIF <  increment the upper bound for \code{p}, effectively making the
%DIF <  updated bounds information available even after we exit the if
%DIF <  statement. The cast at line 5 will be checking the new bounds against
%DIF <  the incremented bounds for non-empty strings.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Fig.~\ref{fig:clangbad2} gives a more practical example of why keeping
%DIF <  track of the bounds on the stack is useful. The program snippet
%DIF <  implements the functionality of the \code{strlen} function using a
%DIF <  while loop and a \code{cnt} variable. Even though the type system is
%DIF <  unable to reason about the while loop, as long as the runtime system
%DIF <  updates the bounds in-place, the user can apply a
%DIF <  \code{dyn_bounds_cast} to soundly recover the more precise bounds
%DIF <  information.
%DIF <  }
%DIFDELCMD < 

%DIFDELCMD <  %%%
\DIFdelend \section{Compilation}\label{sec:compilation}








The semantics of \lang uses annotations on pointer literals in order
to keep track of array bounds information, which is \DIFdelbegin \DIFdel{checked at
dereferences and
  changed during widening}\DIFdelend \DIFaddbegin \DIFadd{used in premises
of rules like }\textsc{\DIFadd{S-DefArray}} \DIFadd{and
  }\textsc{\DIFadd{S-AssignArr}} \DIFadd{to prevent spatial safety violations}\DIFaddend . However, in the real
implementation of \checkedc, \DIFaddbegin \DIFadd{which extends clang/LLVM, }\DIFaddend these annotations
are not present---pointers are represented as a single
machine word with no extra metadata\DIFdelbegin \DIFdel{. We show how the
}\DIFdelend \DIFaddbegin \DIFadd{, and bounds
  checks are not handled by the machine, but inserted by the
  compiler.
}

\DIFadd{This section shows how }\lang
\DIFaddend annotations can be safely erased: using static information a compiler
can insert code to manage and check bounds metadata, with no loss of
expressiveness. \DIFdelbegin %DIFDELCMD < 

%DIFDELCMD < %%%
\DIFdel{This section sketches our }\DIFdelend \DIFaddbegin \DIFadd{We present a }\DIFaddend compilation algorithm that converts from
\lang to \elang, an untyped language without metadata
annotations. \DIFaddbegin \DIFadd{The syntax and semantics }\elang
  \DIFadd{closely mirrors that of }\lang\DIFadd{; it differs only in that literals lack
  type annotations and its operational rules perform no
  bounds and null checks, which are instead inserted during
  compilation. Our compilation algorithm is evidence that }\lang\DIFadd{'s
  semantics, despite its apparent use of fat pointers, faithfully
  represents Checked C's intended behavior. The algorithm also sheds
  light on how compilation can be implemented in the real Checked C
  compiler, while eschewing many important details (}\elang \DIFadd{has many 
  differences with LLVM IR).
}

\DIFaddend Compilation is defined by extending \lang's
typing judgment thusly:
\[\Gamma;\Theta;\rho \vdash_m e \gg \dot e:\tau\]
There is now a \elang output $\dot e$ and an input $\rho$, which maps
each \code{nt_array_ptr} variable \DIFdelbegin \DIFdel{$p$ }\DIFdelend \DIFaddbegin \code{p} \DIFaddend to a pair of \emph{\DIFdelbegin \DIFdel{ghost
  }\DIFdelend \DIFaddbegin \DIFadd{shadow
  }\DIFaddend variables} that keep \DIFdelbegin \DIFdel{$p$}\DIFdelend \DIFaddbegin \code{p}\DIFaddend 's up-to-date upper and lower bounds; these
may differ from the bounds in \DIFdelbegin \DIFdel{$p$}\DIFdelend \DIFaddbegin \code{p}\DIFaddend 's type due to bounds
widening.\footnote{Since lower bounds are never widened, the
  lower-bound \DIFdelbegin \DIFdel{ghost }\DIFdelend \DIFaddbegin \DIFadd{shadow }\DIFaddend variable is unnecessary; we include it for uniformity.}
\DIFdelbegin \DIFdel{When $\Gamma$,$\Theta$ and $\rho$ are all empty, we write $e \gg \dot e$ rather than the
complete judgment, implicitly assuming that $e$ is a well-typed and closed
term.
}\DIFdelend 


We formalize rules for this judgment in PLT Redex~\cite{pltredex},
following and extending our Coq development for \lang. To give
confidence that compilation is correct, we use Redex's property-based
random testing support to show that compiled-to $\dot e $ simulates
$e$, for all $e$.



\subsection{Approach}

Due to space constraints, we explain the rules for compilation by
example\DIFaddbegin \DIFadd{, using a C-like syntax}\DIFaddend ; the complete rules are given in
\DIFaddbegin \iftr
\DIFaddend Appendix~\ref{appx:comp1}
\DIFdelbegin \DIFdel{. 
}\DIFdelend \DIFaddbegin \else
\DIFadd{the supplemental report~}\cite{checkedc-tech-report}\DIFadd{.
}\fi
\DIFaddend Each rule performs up to three tasks: (a) conversion of $e$ to
A-normal form; (b) insertion of dynamic checks; and (c) insertion of
bounds widening expressions.
A-normal form conversion is straightforward: compound expressions are
handled by storing results of subexpressions into temporary variables,
as in the following example.

{\vspace*{-0.5em}
{\small
\begin{center}
$
\begin{array}{l}
$\DIFdelbegin %DIFDELCMD < \code{y=(x+1)+(6+1);}%%%
\DIFdelend \DIFaddbegin \code{let y=(x+1)+(6+1)}\DIFaddend $
\;
\begin{frame}

\tikz\draw[-Latex,line width=2pt,color=orange] (0,0) -- (1,0);

\end{frame}
\;
\begin{array}{l}
$\DIFdelbegin %DIFDELCMD < \code{a=x+1;}%%%
\DIFdelend \DIFaddbegin \code{let a=x+1;}\DIFaddend $\\
$\DIFdelbegin %DIFDELCMD < \code{b=6+1;}%%%
\DIFdelend \DIFaddbegin \code{let b=6+1;}\DIFaddend $\\
$\DIFdelbegin %DIFDELCMD < \code{y=a+b;}%%%
\DIFdelend \DIFaddbegin \code{let y=a+b}\DIFaddend $\\
\end{array}
\end{array}
$
\end{center}
}
}

This simplifies the management of effects from subexpressions. The
next two steps of compilation are more interesting.


\begin{figure}[t!]
  \begin{small}
\DIFmodbegin
\begin{lstlisting}[mathescape,xleftmargin=4 mm,alsolanguage=DIFcode]
%DIF < /* nt_array_ptr<int> p : count(p,p) */
%DIF < /* $\rho$(p) = p_lo,p_hi */
%DIF > /* p : $\color{purple!40!black}\tntarrayptr{0}{0}{\tint}{\cmode}$  */
%DIF > /* $\color{purple!40!black}\rho$(p) = p_lo,p_hi */
{
%DIF <   int x = strlen(p);
%DIF >   let x = strlen(p);
  if (x > 1) putchar(*(p+1));
}
\end{lstlisting}
\DIFmodend
\begin{frame}

\tikz\draw[-Latex,line width=2pt,color=orange] (0,0) -- (1,0);

\end{frame}
\DIFmodbegin
\begin{lstlisting}[xleftmargin=4 mm,alsolanguage=DIFcode]
{
%DIF <   assert(p_lo <= p && p <= p_hi);  //bound check
%DIF <   assert(p != NULL);               //null check
%DIF <   int x = strlen(p);
%DIF <   int *p_hi_new = p + x;
%DIF >   assert(p_lo <= 0 && 0 <= p_hi); // bounds check
%DIF >   assert(p != 0); // null check
%DIF >   let x = strlen(p);
%DIF >   let p_hi_new = x;
  p_hi = max(p_hi, p_hi_new);
  if (x > 1) {
%DIF <     assert(p != NULL);             //null check p
%DIF <     int *p_1 = p + 1;
%DIF <     assert(p_lo <= p_1 && p_1 <= p_hi); // p+1
%DIF <     assert(p_1 != NULL);          //null check p+1
%DIF >     assert(p != 0); // null check for p + 1
%DIF >     let p_1 = p + 1;
%DIF >     assert(p_lo <= 1 && // bounds check for p + 1
%DIF >      1 <= p_hi);    
    putchar(*p_1);
  }
}
\end{lstlisting}
\DIFmodend
\end{small}
\caption{Compilation example for check insertions
}
\label{fig:compilationexample}
\end{figure}


\begin{figure}[t!]
  \begin{small}
\DIFmodbegin
\begin{lstlisting}[mathescape,xleftmargin=4 mm,alsolanguage=DIFcode]
%DIF < int deref_array (int n, 
%DIF <       nt_array_ptr<int> p : bounds(p, p+n)) {
%DIF <   /* $\rho$(p) = p_lo,p_hi */
%DIF <   if (*p) return *(p+1);
%DIF <   return 0;
%DIF > int deref_array(n : int,
%DIF >      p :  $\color{green!40!black}\tntarrayptr{0}{n}{\tint}{\cmode}$) {
%DIF >   /* $\color{purple!40!black}\rho$(p) = p_lo,p_hi */
%DIF >   if (* p)
%DIF >     (* (p + 1))
%DIF >     else 0
}
...
%DIF < // nt_array_ptr<int> p0 : bounds(p0, p0+5)
%DIF > /* p0 : $\color{purple!40!black}\tntarrayptr{0}{5}{\tint}{\cmode}$ */
deref_array(5, p0);
    
\end{lstlisting}
\DIFmodend
\begin{frame}

\tikz\draw[-Latex,line width=2pt,color=orange] (0,0) -- (1,0);

\end{frame}
\DIFmodbegin
\begin{lstlisting}[xleftmargin=4 mm,alsolanguage=DIFcode]
%DIF < int deref_array(int n, int *p) {
%DIF <   int *p_lo = p;
%DIF <   int *p_hi = p + n;
%DIF > deref_array(n, p) {
%DIF >   let p_lo = 0;
%DIF >   let p_hi = n;
  /* runtime checks */
%DIF <   assert(p_lo <= p && p <= p_hi);
%DIF <   assert(p != NULL);
%DIF <   int p_derefed = *p;
%DIF <   if (p_derefed != '\0') {
%DIF >   assert(p_lo <= 0 && 0 <= p_hi);
%DIF >   assert(p != 0);
%DIF >   let p_derefed = *p;
%DIF >   if (p_derefed != 0) {
    /* widening */
%DIF <     if (p_hi == p) {
%DIF <       ++p_hi;
%DIF >     if (p_hi == 0) {
%DIF >       p_hi = p_hi + 1;
    }
%DIF <     int *p0 = p + 1;
%DIF <     assert(p_lo <= p0 && p0 <= p_hi);
%DIF <     assert(p0 != NULL);
%DIF <     return *p0;
%DIF >     /* null check before pointer arithmetic */
%DIF >     assert(p != 0);
%DIF >     let p0 = p + 1;
%DIF >     assert(p_lo <= 1 && 1 <= p_hi);
%DIF >     (* p0)
  }
%DIF <   return 0;
%DIF >   else {
%DIF >     0
%DIF >   }
%DIF > }
...
%DIF < //int *p0, set_bounds(p0) = p_lo, p_hi
deref_array(5, p0);
    
\end{lstlisting}
\DIFmodend
\end{small}
    \caption{Compilation example for dependent functions}
\label{fig:compilationexample1}
\end{figure}



During compilation, $\Gamma$ tracks the lower and upper bound
associated with every pointer variable according to its type. At each
declaration of a \code{nt_array_ptr} variable \DIFdelbegin \DIFdel{$p$}\DIFdelend \DIFaddbegin \code{p}\DIFaddend , the
compiler allocates two \emph{\DIFdelbegin \DIFdel{ghost }\DIFdelend \DIFaddbegin \DIFadd{shadow }\DIFaddend variables}, 
stored in $\rho(p)$; these are initialized to \DIFdelbegin \DIFdel{$p$}\DIFdelend \DIFaddbegin \code{p}\DIFaddend 's declared bounds
and will be updated during bounds widening.\footnote{\DIFdelbegin \DIFdel{Ghost }\DIFdelend \DIFaddbegin \DIFadd{shadow }\DIFaddend variables
  are not used for \code{array_ptr} types (the bounds expressions are)
  since they are not subject to bounds widening.} 
Fig.~\ref{fig:compilationexample} shows how an invocation of
\code{strlen} on a null-terminated string is compiled into C
code. Each dereference of a checked pointer requires a null check
(See \textsc{S-DefNull} in Fig.~\ref{fig:semantics}), which the
compiler makes explicit: Line~$3$ of the generated code has the null
check on pointer \DIFdelbegin \DIFdel{$p$,
  and similar checks happen }\DIFdelend \DIFaddbegin \code{p} \DIFadd{due to the }\code{strlen}\DIFadd{,
  and a similar check happens
  }\DIFaddend at line~$8$ \DIFdelbegin \DIFdel{and
line~$11$}\DIFdelend \DIFaddbegin \DIFadd{due to the pointer arithmetic on }\code{p}\DIFaddend .
Dereferences also require bounds checks: line~$2$ checks \code{p} is
in bounds before computing \code{strlen(p)}, while line~$10$ does
likewise before computing \code{*(p+1)}.

For \code{strlen(p)} and conditionals \code{if(*p)}, the \lang
semantics allows the upper bound of \code{p} to be extended.
The compiler explicitly inserts statements to do so on \code{p}'s
\DIFdelbegin \DIFdel{ghost }\DIFdelend \DIFaddbegin \DIFadd{shadow }\DIFaddend bound variables. For example,
Fig.~\ref{fig:compilationexample}~line~$6$ widens \code{p}'s upper
bound if \code{strlen}'s result is larger than the existing
bound. 
Lines 7--12 of the generated code in
Fig.~\ref{fig:compilationexample1}
show how bounds are 
widened when compiling expression \code{if(*p)}. If we find that the
current \code{p}\DIFdelbegin \DIFdel{address }\DIFdelend \DIFaddbegin \DIFadd{'s relative upper bound }\DIFaddend is equal to \DIFdelbegin \DIFdel{the upper bound }\DIFdelend \DIFaddbegin \DIFadd{$0$ }\DIFaddend (line 10),
and \code{p}'s content is not null (line 8), we then increase the
upper bound by $1$ (line 11).
\DIFaddbegin 

\DIFaddend Fig.~\ref{fig:compilationexample1} also shows a dependent function call.
Notice that the bounds for the array pointer \code{p} are not passed as
arguments. Instead, they are initialized according to \code{p}'s
type---see line~3 of the original \lang program at the top of the figure.
Line~$2$ of the generated code
sets the lower bound  to \DIFdelbegin %DIFDELCMD < \code{p} %%%
\DIFdelend \DIFaddbegin \code{0} \DIFaddend and line~$3$ sets the
upper bound to \DIFdelbegin %DIFDELCMD < \code{p+n}%%%
\DIFdelend \DIFaddbegin \code{n}\DIFaddend .

\subsection{Comparison with Checked C Specification}
\label{sec:disc}

\DIFaddbegin \begin{figure}[t]
{\small
{\captionsetup[lstlisting]{margin = 8 mm}
  \DIFmodbegin
\begin{lstlisting}[xleftmargin=8 mm,alsolanguage=DIFcode]
%DIF > nt_array_ptr<char> safe_strcat_c 
%DIF >    (nt_array_ptr<char> dst : count(n),
%DIF >     nt_array_ptr<char> src : count(0), int n) {
%DIF >   nt_array_ptr<char> tmp : count(n) = dst;
%DIF >   int x = strlen(tmp);
%DIF >   /* tmp now has x as its upper bound */
%DIF >   /* dst still has n as its upper bound */
%DIF >   int y = strlen(src);
%DIF > 
%DIF >   if (x+y < n) {
%DIF >     for (int i = 0; i < y; ++i)
%DIF >       *(dst+x+i) = *(src+i);
%DIF >     *(dst+x+y) = '\0';
%DIF >     return dst;
%DIF >   }
%DIF >   return null;
%DIF > }
\end{lstlisting}
\DIFmodend
}
}
\caption{\DIFaddFL{Safe }\code{strcat} \DIFaddFL{in Checked C that avoids a run-time error
  exhibited by }\code{safe_strcat} \DIFaddFL{(Fig.~\ref{fig:strcat-ex}) when
  compiled with the current Checked C compiler}}
\label{fig:strcatc-ex}
\end{figure}

\DIFaddend The use of \DIFdelbegin \DIFdel{ghost }\DIFdelend \DIFaddbegin \DIFadd{shadow }\DIFaddend variables for bounds widening is a key novelty of our
compilation approach, and adds more precision to bounds checking at runtime
compared to the official specification and current implementation of
\checkedc~\cite[5.1.2, pg 85]{checkedc}.  For example, the
\DIFdelbegin %DIFDELCMD < \code{strncat} %%%
\DIFdelend \DIFaddbegin \code{safe_strcat} \DIFaddend example of Fig.~\DIFdelbegin \DIFdel{\ref{fig:strncat-ex} }\DIFdelend \DIFaddbegin \DIFadd{\ref{fig:strcat-ex} }\DIFaddend compiles with the
current Clang \checkedc compiler but will fail with a runtime
error. The statement \DIFdelbegin %DIFDELCMD < \code{int x = strlen(a)} %%%
\DIFdelend \DIFaddbegin \code{int x = strlen(dst)} \DIFaddend at line 4 changes the
\DIFaddbegin \DIFadd{statically determined }\DIFaddend upper bound of \DIFdelbegin %DIFDELCMD < \code{a} %%%
\DIFdelend \DIFaddbegin \code{dst} \DIFaddend to \code{x}, which can be smaller than
\code{n}, the \DIFdelbegin \DIFdel{capacity of the array pointer }%DIFDELCMD < \code{a}%%%
\DIFdel{. The assignment
at line 14 }\DIFdelend \DIFaddbegin \DIFadd{full capacity of }\code{dst}\DIFadd{. The attempt to recover
the full capacity of }\code{dst} \DIFadd{through a dynamic cast
at line 7 }\DIFaddend will always fail if the \DIFdelbegin \DIFdel{index }%DIFDELCMD < \code{x + i} %%%
\DIFdelend \DIFaddbegin \DIFadd{capacity }\code{n} \DIFaddend is checked
against the statically determined \DIFaddbegin \DIFadd{new }\DIFaddend upper bound \code{x}. This \DIFdelbegin \DIFdel{forces us to inline the definition of }\DIFdelend \DIFaddbegin \DIFadd{problem can be worked around by invoking }\DIFaddend \code{strlen} \DIFdelbegin \DIFdel{as
in }%DIFDELCMD < \code{strncat_c} %%%
\DIFdel{to avoid runtime errors when running code compiled with the
Clang }%DIFDELCMD < \checkedc %%%
\DIFdel{compiler.}\DIFdelend \DIFaddbegin \DIFadd{on a temporary
variable }\code{tmp} \DIFadd{instead of }\code{dst}
\DIFadd{as in }\code{safe_strcat_c} \DIFadd{in Fig.~\ref{fig:strcatc-ex} (lines 4-5).
}\DIFaddend Likewise, if we were to add \DIFdelbegin \DIFdel{another dereference to
$p$ }\DIFdelend \DIFaddbegin \DIFadd{line }\code{putchar(*(p+1));} 
\DIFaddend after line 6 in the original code at the top of
Fig.~\ref{fig:compilationexample}, the \DIFaddbegin \DIFadd{code will always fail: the }\DIFaddend Clang \checkedc
compiler \DIFaddbegin \DIFadd{(with the transliterated C code as its input) }\DIFaddend would 
check \code{p} against its \DIFdelbegin \DIFdel{original bounds }%DIFDELCMD < \code{(p,p)} %%%
\DIFdelend \DIFaddbegin \emph{\DIFadd{original}} \DIFadd{bounds }\code{(0,0)} \DIFaddend since the
updated upper bound \DIFdelbegin %DIFDELCMD < \code{p+x} %%%
\DIFdel{cannot be retained with }\DIFdelend \code{x} \DIFaddbegin \DIFadd{is now }\DIFaddend out of
the scope. \DIFdelbegin \DIFdel{In the presence of ghost variables ,
these bounds have been widened by the assignment in line $5$ (assuming
the null-terminator was not the first element of the string) and
remain available in the entire stack frame, and
therefore the check will succeed.In contrast, in the actual
implementation of Checked C, the scope of the widening is limited to
the scope of the conditional at both runtime and compile time, which means that the inserted dynamic
check would fail.
}\DIFdelend \DIFaddbegin \DIFadd{Shadow variables address these problems because
they retain widened bounds beyond the scope of variables that store
them (i.e., }\code{x} \DIFadd{in both examples).
}

\DIFaddend To make it match the specification, our compilation definition could
\DIFaddbegin \DIFadd{easily eschew
shadow variables and }\DIFaddend rely only on the type-based
bounds expressions available in $\Gamma$ for checking\DIFdelbegin \DIFdel{, and eschew ghost variables}\DIFdelend . However, doing so would 
force us to weaken the simulation theorem, reduce expressiveness,
and/or force the semantics to be more awkward. We plan to work with
the \checkedc team to implement our approach in a future revision.



\subsection{Metatheory}
\label{sec:meta}



\DIFdelbegin \DIFdel{While designing our Coq model of }%DIFDELCMD < \lang%%%
\DIFdel{, we also designed a model in
PLT Redex.}\footnote{\DIFdel{The two models, in Redex and Coq, are
  equivalent, with the only difference being in the representation of
  stacks: as we saw, the Coq model uses an explicit map for
  representing stacks to ease the effort of theorem proving; on the
  other hand, the Redex model uses }\texttt{\DIFdel{let}} %DIFAUXCMD
\DIFdel{bindings to simulate a
  stack, which removes the need to account for the stack during random
  generation of terms.}}  %DIFAUXCMD
\addtocounter{footnote}{-1}%DIFAUXCMD
\DIFdel{Redex~}%DIFDELCMD < \cite{pltredex} %%%
\DIFdel{is a semantic
engineering framework implemented in Racket, which allows for
concisely specifying semantics and typing rules. We formalize the }\DIFdelend \DIFaddbegin \DIFadd{We formalize both the compilation procedure and the }\DIFaddend simulation
theorem in \DIFdelbegin \DIFdel{this model }\DIFdelend \DIFaddbegin \DIFadd{the PLT Redex model we developed for }\lang \DIFadd{(see Sec.~\ref{sec:syntax})}\DIFaddend ,
and then attempt to falsify it via Redex's support for random
testing. \DIFaddbegin \DIFadd{Redex allows us
  to specify compilation as logical rules (essentially, an extension
  of typing), but then execute it algorithmically to
  automatically test whether simulation holds. This process revealed
  several bugs in compilation and the theorem statement.
}\DIFaddend We ultimately plan to prove simulation in the Coq model.

\DIFdelbegin \DIFdel{Turning to the simulation theorem: We first introduce notation
used to specify the theorem. We }\DIFdelend \DIFaddbegin \DIFadd{We }\DIFaddend use the notation $\gg$ to
indicate the \emph{erasure} of stack and heap---the rhs is the same as
the lhs but with type annotations removed:
\begin{equation*}
  \begin{split}
    \heap  \gg & \dot \heap \\
    \varphi \gg & \dot \varphi
  \end{split}
\end{equation*}
In addition, \DIFaddbegin \DIFadd{when $\Gamma;\emptyset\vdash
\varphi$ and $\varphi$ is well-formed, }\DIFaddend we write $(\varphi,\heap,e) \gg (\dot \varphi, \dot \heap,
\dot e)$ to denote $\varphi \gg \dot \varphi$, $\heap \gg \dot \heap$
and \DIFdelbegin \DIFdel{$e \gg \dot e$ respectively. }%DIFDELCMD < 

%DIFDELCMD < %%%
\DIFdel{We }\DIFdelend \DIFaddbegin \DIFadd{$\Gamma;\Theta;\emptyset \vdash e \gg \dot e : \tau$ for some $\tau$ respectively. $\Gamma$ is omitted from the notation since the well-formedness of $\varphi$ and its consistency with respect to $\Gamma$ imply that $e$ must be closed under $\varphi$, allowing us to recover $\Gamma$ from $\varphi$.
Finally, we }\DIFaddend use $\xrightarrow{\cdot}^*$ to denote the transitive closure of the
reduction relation of $\elang$. Unlike the $\lang$, the semantics of
$\elang$ does not distinguish checked and unchecked regions.

Fig.~\ref{fig:checkedc-simulation-ref} gives an overview of 
the simulation theorem.\footnote{We ellide the  possibility of $\dot e_1$ evaluating to $\ebounds$ or $\enull$ in the diagram for readability.} The simulation theorem is specified in a way
that is similar to the one by~\citet{merigoux2021catala}.
An ordinary simulation property would
replace the middle and bottom parts of the figure with the
following: \[(\dot \varphi_0, \dot \heap_0, \dot e_0) 
  \xrightarrow{\cdot}^* (\dot \varphi_1, \dot \heap_1, \dot e_1)\]
Instead, we relate two erased configurations using the relation $\sim$,
which only requires that the two configurations will eventually reduce
to the same state. We formulate our simulation theorem differently
because the standard simulation theorem imposes a very strong
syntactic restriction to the compilation strategy. Very often, $(\dot
\varphi_0, \dot \heap_0, \dot e_0)$ reduces to a term that is
semantically equivalent to $(\dot \varphi_1, \dot \heap_1, \dot e_1)$,
but we are unable to syntactically equate the two configurations due
to the extra binders generated for dynamic checks and ANF
transformation. In earlier versions of the Redex model, we attempted
to change the compilation rules so the configurations could match
syntactically. However, the approach scaled poorly as we added
additional rules. 
This slight relaxation on the equivalence relation
between target configurations allows us to specify compilation more
naturally without having to worry about syntactic constraints.


\begin{thm}[Simulation ($\sim$)]\label{simulation-thm}
For \lang expressions $e_0$, stacks $\varphi_0$, $\varphi_1$, and heap snapshots $\heap_0$, $\heap_1$, 
if \DIFdelbegin \DIFdel{$\emptyset;\emptyset;\emptyset \vdash_\cmode e_0 \gg \dot e_0 :\tau_0$, }\DIFdelend \DIFaddbegin \DIFadd{$\heap_0 \vdash \varphi_0$, $(\varphi_0,\heap_0,e_0)\gg(\dot \varphi_0,\dot \heap_0, \dot e_0)$,
}\DIFaddend and if there exists some $r_1$ such that $(\varphi_0, \heap_0, e_0)
\rightarrow_\cmode (\varphi_1, \heap_1, r_1)$, \DIFdelbegin \DIFdel{when $r_1 = e_1$ for
some }\DIFdelend \DIFaddbegin \DIFadd{then the following facts hold:
}

\begin{itemize}

\item \DIFadd{if there exists }\DIFaddend $e_1$ \DIFdelbegin \DIFdel{and
$\emptyset;\emptyset;\emptyset \vdash_\cmode e_1 \gg \dot e_1 :\tau_1$ where $\tau_1 \sqsubseteq \tau_0$
}\DIFdelend \DIFaddbegin \DIFadd{such that $r=e_1$ and $(\varphi_1, \heap_1, e_1) \gg (\dot \varphi_1, \dot \heap_1, \dot e_1)$}\DIFaddend , then there exists some $\dot \varphi$,$\dot \heap$, $\dot e$, such that
$(\dot \varphi_0, \dot \heap_0,\dot e_0) \xrightarrow{\cdot}^* (\dot
\varphi,\dot \heap,\dot e)$ and $(\dot
\varphi_1,\dot \heap_1,\dot e_1) \xrightarrow{\cdot}^* (\dot \varphi,
\dot \heap,\dot e)$.
\DIFdelbegin \DIFdel{When }\DIFdelend \DIFaddbegin 

\item \DIFadd{if }\DIFaddend $r_1 = \ebounds$ or $\enull$, \DIFaddbegin \DIFadd{then }\DIFaddend we have $(\dot \varphi_0, \dot \heap_0,\dot e_0) \xrightarrow{\cdot}^* (\dot
\dot \varphi_1,\dot \heap_1, r_1)$ where $\varphi_1 \gg \dot
\varphi_1$, $\heap_1 \gg \dot \heap_1$.
\DIFaddbegin 

\end{itemize}
\DIFaddend \end{thm}






Our random generator (discussed in the next section) never produces
$\euncheckedtext$ expressions (whose behavior could be undefined), so we
can only test a the simulation theorem 
as it applies to checked code. This limitation makes it
unnecessary to state the other direction of the simulation theorem
where $e_0$ is stuck, because Theorem~\ref{thm:progress} guarantees
that $e_0$ will never enter a stuck state if it is well-typed in
checked mode.

The current version of the Redex model has been tested against $20000$
expressions with depth less than $10$. Each expression can
reduce multiple steps, and we test simulation between every two
adjacent steps to cover a wider range of programs, particularly the
ones that have a non-empty heap.

\begin{figure}[t]
{\small
\[
\begin{array}{c}
\begin{tikzpicture}[
            > = stealth, shorten > = 1pt, auto,
            node distance = 3cm
        ]

\begin{scope}[every node/.style={draw}]
    \node (A) at (0,1.5) {$\varphi_0,\heap_0, e_0$};
    \node (B) at (4,1.5) {$\varphi_1, \heap_1 ,e_1$};
    \node (C) at (0,0) {$\dot \varphi_0, \dot \heap_0 ,\dot e_0$};
    \node (D) at (4,0) {$\dot \varphi_1, \dot \heap_1, \dot e_1$};
    \node (E) at (2,-1.5) {$\dot \varphi,\dot \heap ,\dot e$};
\end{scope}
\begin{scope}[every edge/.style={draw=black}]

    \path [->] (A) edge node {$\longrightarrow_\cmode$} (B);
    \path [<->] (A) edge node {$\gg$} (C);
    \path [<->] (B) edge node {$\gg$} (D);
    \path [dashed,<->] (C) edge node {$\sim$} (D);
    \path [dashed,->] (C) edge node {$\xrightarrow{\cdot}^*$} (E);
    \path [dashed,->] (D) edge node[above] {$\xrightarrow{\cdot}^*$} (E);
\end{scope}

\end{tikzpicture}
\end{array}
\]
}
\caption{Simulation between \lang and \elang }
\label{fig:checkedc-simulation-ref}
\end{figure}






















 %DIF <  \ignore
%DIF <  {The two theorems can be best understood by the diagram in Fig.~\ref{fig:checkedc-simulation-ref}.
%DIF <  On the top of the relation, we have type soundness theorem (Sec.~\ref{sec:theorem}) stating that every type-checked \lang program $e_0$ can transition via \lang semantics into a type-checked program $e_1$ by taking a checked step.
%DIF <  The second line refers to that both $e_0$ and $e_1$ can be compiled to a C program $\dot e_0$ and $\dot e_1$, and such compilations always exist. The bottom two rewrites ($\xrightarrow{c}$) state that both $\dot e_0$ and $\dot e_1$ are transitioned finally to the same state $\dot e$. 
\DIFdelbegin %DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <   The simulation states that given any well-typed \lang expression $e_0$, its compiled C program as $\dot e_0$, if $e_0$ can transition one step to $e_1$, and there must exist the compiled C program $\dot e_1$, such that both $\dot e_0$ and $\dot e_1$ transition to the same final state $\dot e$ in C. The simulation relation $\sim$ is built on top of the "triangle" structure in Fig.~\ref{fig:checkedc-simulation-ref} stating that every \lang expression and its one step transitioned expression might be compiled to two different C program, but the C semantics always evaluates them to the same place.
%DIF <  The translation preservation theorem is a support for the simulation theorem stating that for any well-typed \lang expression $e_0$,  its one step \checkedc transition expression $e_1$ must exist a compiled C program through the compilation process ($\gg$).
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  A corollary of the simulation theorem states that for any \lang expression $e_0$ and its one step \lang transition expression $e_1$, such that $e_0 \longrightarrow e_1$, if $e_0$ contains a fault due to a unchecked block (the blame theorem tells us that if there is a fault in a \lang code, it must come from a unchecked block), and its compiled code $\dot e_0$ is evaluated to a fault state, the compiled code $\dot e_1$ for $e_1$ is always evaluated to the same fault state in C.
%DIF <  This is an important property for a \lang compiler to preserve because any problematic program will be captured by running it long enough, so that enough random testing cases are able to capture all the bugs.
%DIF <  In our formalization implementation, the type soundness theorem is proved through Coq, while the simulation theorem is validated through intensive random test case generation. We generate tens of thousands cases and cover all possible corner cases of the compilation. 
%DIF <  }
%DIF <  \ignore{
%DIF <  \begin{figure*}[t]
%DIF <    \begin{subfigure}[b]{1\textwidth}
%DIF <      \begin{lstlisting}
%DIF <  % int deref_array (size_t n, nt_array_ptr<int> p : bounds(p, p + n)) {
%DIF <    return *p;
%DIF <  }
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  ...
%DIF <  /* nt_array_ptr<int> p0 : bounds(p0, p0 + 5) */
%DIF <  deref_array(5, p0);
%DIF <      \end{lstlisting}
%DIF <      \label{fig:chkcexamplederef}
%DIF <      \caption{\texttt{deref\_array} in \checkedc}
%DIF <    \end{subfigure}
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{subfigure}[b]{1\textwidth}
%DIF <  \begin{lstlisting}
%DIF <  % int deref_array(size_t n, int *p) {
%DIF <    /* statically determine the definitions p_lo and p_hi */
%DIF <    int *p_lo = p;
%DIF <    int *p_hi = p + n;
%DIF <    /* runtime checks */
%DIF <    assert(p_lo <= p && p <= p_hi);
%DIF <    assert(p != NULL);
%DIF <    /* widening */
%DIF <    int p_derefed = *p;
%DIF <    if (p_derefed != '\0') {
%DIF <      if (p_hi == p) {
%DIF <        ++p_hi;
%DIF <      }
%DIF <    }
%DIF <    return p_derefed;
%DIF <  }
%DIF <  ...
%DIF <  /* int *p0 */
%DIF <  /* rho(p0) = p_lo, p_hi */
%DIF <  deref_array(5, p0);
%DIF <  \end{lstlisting}
%DIF <  \caption{\texttt{deref\_array} in C}
%DIF <      \label{fig:cexamplederef}
%DIF <    \end{subfigure}
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{subfigure}[b]{\textwidth}
%DIF <      \begin{lstlisting}
%DIF <  % /* nt_array_ptr<int> p : bounds(e0, e1) */
%DIF <  /* rho(p) = p_lo, p_hi */
%DIF <  size_t x = strlen(p);
%DIF <  if(x >= 1) {
%DIF <    *(p+1);
%DIF <  }
%DIF <      \end{lstlisting}
%DIF <      \caption{\texttt{strlen} in \checkedc}
%DIF <      \label{fig:chkcexamplestrlen}
%DIF <    \end{subfigure}
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <    \begin{subfigure}[b]{\textwidth}
%DIF <      \begin{lstlisting}
%DIF <  % /* nt_array_ptr<int> p : bounds(e0, e1) */
%DIF <  /* rho(p) = p_lo, p_hi */
%DIF <  /* runtime checks omitted */
%DIF <  ...
%DIF <  size_t x = strlen(p);
%DIF <  int *p_hi_new = p + x;
%DIF <  p_hi = max(p_hi, p_hi_new);
%DIF <  if (x >= 1) {
%DIF <    /* null check for pointer arithmetic */
%DIF <    assert(p != NULL);
%DIF <    int *p_1 = p + 1;
%DIF <    /* null check for dereference */
%DIF <    assert(p_1 != NULL);
%DIF <    /* bounds check for dereference */
%DIF <    /* note how we are using p_hi rather than p + x */
%DIF <    assert(p_lo <= p_1 && p_1 <= p_hi);
%DIF <    ...
%DIF <  }
%DIF <      \end{lstlisting}
%DIF <      \caption{\texttt{strlen} in C}
%DIF <      \label{fig:cexamplestrlen}
%DIF <    \end{subfigure}
%DIF <  \caption{Compilation of null-terminated string dereference}
%DIF <  \label{fig:compilationexample}
%DIF <  \end{figure*}
%DIF <  }
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  \ignore{
%DIF <  Fig.~\ref{fig:compilationexample} gives an example of how we compile the
%DIF <  dereference of null-terminated strings by inserting explicit checks and
%DIF <  bounds widening code. For readability, we present the example in real
%DIF <  \checkedc and C syntax. At
%DIF <  line 3-4 of Fig.~\ref{fig:cexamplederef}, we see how the upper and lower
%DIF <  bounds are defined in terms of the arguments \code{p} and \code{n}
%DIF <  according to the bounds annotations obtained during typechecking. This
%DIF <  avoids the need to pass in bounds as extra arguments, thus maintaining
%DIF <  compatibility with C code. When we call \code{deref_array} on
%DIF <  \code{p0}, a string with size 5 (excluding the null character), there
%DIF <  is no need to pass the bounds \code{p_lo} and \code{p_hi} stored on
%DIF <  the stack. It is possible that \code{p_hi} has been widened
%DIF <  before we reach line 21. The programmer will have to perform a
%DIF <  \code{dynamic_cast} to recover the more precise bounds information. The if statement from line 10 to line 14
%DIF <  attempts to widen the bound when the dereferenced result is not
%DIF <  null. \todo[inline]{Show a full-fledged C program?} The widened upper bound will be available within the scope of
%DIF <  \code{deref_array}, in contrast to the T-IfNT rule, which only
%DIF <  remembers the widened bounds within the scope of the then branch of
%DIF <  the if statement. 
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  \todo[inline]{Widening can happen at every
%DIF <    dereference at runtime. Is that ok?} Fig.~\ref{fig:cexamplestrlen}
%DIF <  shows how an invocation of \code{strlen} on null-termianted strings
%DIF <  is compiled into C code. We perform the same runtime checks that
%DIF <  happen during dereferencing. The widening code at line
%DIF <  8 updates \code{p}'s upper bound only if the result of
%DIF <  \code{strlen} is larger than the value of the upper bound stored on
%DIF <  the stack. This is another scenario where the runtime can be more precise
%DIF <  than the statically determined bounds information.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  }
 \DIFdelend \section{Random Testing via the Implementation}\label{sec:evaluation}



In addition to using the \lang Redex model to establish simulation of
compilation (Section~\ref{sec:meta}), we also used it to gain confidence
that our model matches the Clang \checkedc implementation;
disagreement on outcomes signals a bug in either the model or the
compiler itself. Doing so allowed us to quickly iterate on the
design of the model while adding new features, and revealed
several bugs in the Clang \checkedc implementation.

\myparagraph{Generating Well Typed Terms} For this random generation, we follow
the approach of~\citet{PalkaAST11} to generate well-typed \checkedc
terms by viewing the typing rules as generation rules.
Suppose we have a context \DIFdelbegin \DIFdel{$\textcolor{red}{\Gamma}$}\DIFdelend \DIFaddbegin \DIFadd{$\Gamma$}\DIFaddend , a mode
\DIFdelbegin \DIFdel{$\textcolor{red}{m}$ }\DIFdelend \DIFaddbegin \DIFadd{$m$ }\DIFaddend and a type \DIFdelbegin \DIFdel{$\textcolor{red}{\tau}$}\DIFdelend \DIFaddbegin \DIFadd{$\tau$}\DIFaddend , and we are
trying to generate a well-typed expression. We can do that by
reversing the process of type checking, selecting a typing rule and
building up an expression in a way that satisfies the rule's premises.

Recall the typing rule for dereferencing an
array pointer, which we depict below as
\textsc{G-DefArr}\footnote{Generator rules G-* correspond one to one
  with the type rules T-* in Sec.~\ref{sec:type-system}.}, color-coded to represent \textcolor{red}{inputs} and \textcolor{blue}{outputs} of the
generation process:\footnote{This input-output marking is commonly called a mode in
  the literature, but we eschew this term to avoid
  confusion with our pointer mode annotation.}
\begin{mathpar}
    \inferrule[G-DefArr]
              {\textcolor{red}{\Gamma};\textcolor{red}{\Theta} \vdash_{\textcolor{red}{m}} \textcolor{blue}{e} : \DIFdelbegin %DIFDELCMD < \tptr{\tallarraybc{\textcolor{cyan}{\bvar}}{\textcolor{red}{\tau}}}{\textcolor{cyan}{m_a}} %%%
\DIFdelend \DIFaddbegin \tptr{\tallarraybc{\textcolor{cyan}{\bvar}}{\textcolor{red}{\tau}}}{\textcolor{cyan}{m'}} \DIFaddend \\
\textcolor{red}{m} \leq \textcolor{cyan}{m\DIFdelbegin \DIFdel{_a}\DIFdelend \DIFaddbegin \DIFadd{'}\DIFaddend } 
              }
              {\textcolor{red}{\Gamma};\textcolor{red}{\Theta} \vdash_{\textcolor{red}{m}} \textcolor{blue}{\estar{e}} : \textcolor{red}{\tau}}
\end{mathpar}
If we selected \textsc{G-DefArr} for generating an expression, the
generated expression has to have the form $\textcolor{blue}{*e}$,
for some $\textcolor{blue}{e}$, to be generated according
to the rule's premises.
To satisfy the premise
\DIFdelbegin \DIFdel{$\textcolor{red}{\Gamma};\textcolor{red}{\Theta}
\vdash_{\textcolor{red}{m}} \textcolor{blue}{e} :
\tptr{\tallarraybc{\textcolor{cyan}{\bvar}}{\textcolor{red}{\tau}}}{\textcolor{cyan}{m_a}}$}\DIFdelend \DIFaddbegin \DIFadd{$\textcolor{red}{\Gamma};\textcolor{red}{\Theta}
\vdash_{\textcolor{red}{m}} \textcolor{blue}{e} :
\tptr{\tallarraybc{\textcolor{cyan}{\bvar}}{\textcolor{red}{\tau}}}{\textcolor{cyan}{m'}}$}\DIFaddend ,
we essentially need to make a recursive call to the generator, with
appropriately adjusted inputs.
However, the type in this judgment is not fixed yet---it contains
three unknown variables: \DIFdelbegin \DIFdel{$\textcolor{cyan}{m_a}$}\DIFdelend \DIFaddbegin \DIFadd{$\textcolor{cyan}{m'}$}\DIFaddend ,
$\textcolor{cyan}{\bvar}$, and $\textcolor{cyan}{\kappa}$---that need
to be generated before making the call.
Looking at the second premise informs that generation:
if the input mode $\textcolor{red}{m}$ is $\umode$, then \DIFdelbegin \DIFdel{$\textcolor{cyan}{m_a}$
}\DIFdelend \DIFaddbegin \DIFadd{$\textcolor{cyan}{m'}$
}\DIFaddend needs to be $\umode$ as well; if not, it is unconstrained,
just like $\textcolor{cyan}{\bvar}$ and $\textcolor{cyan}{\kappa}$, and therefore all three are free to be generated at random.
Thus, the recursive call to generate $\textcolor{blue}{e}$ can now
be made, and the \textsc{G-DefArr} rule returns $\textcolor{blue}{*e}$
as its output.



Using such generator rules, we can create a generator for random
well-typed terms of a given type in a straightforward manner: find all
rules whose conclusion matches the given type and then randomly choose
a candidate rule to perform the generation. To ensure that this
process terminates, we follow the standard practice of using ``fuel'' to
bound the depth of the generated terms; once the fuel is exhausted,
only rules without recursive premises are
selected~\cite{Pierce:SF4}. Similar methods were used for
generating top level functions and \kw{struct} definitions. 



While using just the typing-turned-generation rules is in theory
enough to generate all well-typed terms, it's more effective in
practice to try and exercise interesting patterns.  As
in~\citet{PalkaAST11} this can be viewed as a way of adding admissible
but redundant typing rules, with the sole purpose of
using them for generation. For example, below is one such rule,
\textsc{G-ASTR}, which creates an initialized null-terminated string that
is statically cast into an array with bounds $(0,0)$.
\begin{mathpar}
    \inferrule[G-ASTR]
    {
      \textcolor{cyan}{i} \in \mathbb{N}^* \quad\quad
      \textcolor{cyan}{n_0,\ldots,n_{i-1} } \in \mathbb{Z} \quad\quad
      \texttt{fresh}(\textcolor{cyan}{x})\\
      \textcolor{red}{\Gamma} \vdash_{\textcolor{red}{m}}
      \textcolor{blue}{e'} :
      \tptr{\textcolor{red}{\tntarray{0}{\textcolor{cyan}{i}}{\tint}}}{c}
      \\      
\textcolor{blue}{e} = \elet{\textcolor{cyan}{x}}{\textcolor{blue}{e'}}{\texttt{(init $\textcolor{cyan}{x}$ with }\textcolor{cyan}{n_0,\ldots
        n_{i-1}}\texttt{)};\textcolor{cyan}{x}}
}
    {\textcolor{red}{\Gamma} \vdash_{\textcolor{red}{m}} \textcolor{blue}{\ecast{\tptr{\tntarray{0}{0}{\tint}}{c}}{e}} : \textcolor{red}{\tptr{\tntarray{0}{0}{\tint}}{c}}}
  \end{mathpar}
Given some positive number $\textcolor{cyan}{i}$, numbers
$\textcolor{cyan}{n_0, \ldots, n_{i-1}}$, and a fresh variable
$\textcolor{cyan}{x}$ (which are arbitrarily generated), we can
recursively generate a pointer $\textcolor{blue}{e'}$ with bounds
$(0,\textcolor{cyan}{i})$, and initialize it with the generated $n_j$
using $\textcolor{cyan}{x}$ to temporarily store the pointer.

This rule is particularly useful when combined with \textsc{G-IfNT}
since there is a much higher chance of obtaining a non-zero value when
evaluating $\estar{p}$ in the guard of $\eiftext$, skewing the
distribution towards programs that enter the $\ethentext$ branch.
Relying solely on the type-based rules, entering the $\ethentext$
branch requires \textsc{G-AssignArr} was chosen before \textsc{G-IfNT},
and that assignment would have to appear before $\eiftext$, which
means additional \textsc{G-Let} rules would need to be chosen: this
combination would therefore be essentially impossible to generate in
isolation.

\DIFaddbegin \DIFadd{Adding admissible generation rules like }\textsc{\DIFadd{G-Astr}} \DIFadd{in this
manner, as described in~}\citet{PalkaAST11}\DIFadd{, is a manual process. It is
guided by gathering statistics on the generated data and focusing on
language constructs that appear underrepresented in the posterior
distribution. For example, we arrived at the }\textsc{\DIFadd{G-Astr}} \DIFadd{rule by
recognizing that the pure type-based generation was not generating
non-trivial null-terminated strings, and then analyzing the sequence
of random choices that could lead to their generation.
}



\DIFaddend \myparagraph{Generating Ill-typed Terms}
We can use generated well-typed terms to test our simulation theorem
(Section~\ref{sec:compilation}) and test that \lang and \checkedc
Clang agree on what is type-correct. But it is also useful to generate
ill-typed terms to test that \lang and \checkedc Clang \DIFdelbegin \DIFdel{agree on those}\DIFdelend \DIFaddbegin \DIFadd{also agree on
what is not}\DIFaddend .  However, while it is easy to generate arbitrary
ill-typed terms, they would be very unlikely to trigger any
inconsistencies; those are far more likely to exist on the boundary
between well- and ill-typedness. Therefore, we also \DIFdelbegin \DIFdel{include }\DIFdelend \DIFaddbegin \DIFadd{manually added
variations of existing }\DIFaddend generation rules modified to be slightly more
permissive, \DIFdelbegin \DIFdel{which results in sometimes generating
}\DIFdelend \DIFaddbegin \DIFadd{e.g., by relaxing a single premise, thus allowing }\DIFaddend terms
that are ``a little'' ill-typed \DIFdelbegin \DIFdel{.
}\DIFdelend \DIFaddbegin \DIFadd{to be generated. Unlike coming up with
admissible generation rules like }\textsc{\DIFadd{G-Astr}} \DIFadd{(which is quite
challenging to automate), systematically and automatically relaxing
premises of existing rules seems feasible, and worthwhile future work.
}\DIFaddend 





\myparagraph{Random Testing for Language Design}
We used our Redex model and random generator to successfully guide the
design of our formal model, and indeed the Clang Checked C
implementation itself, which is being actively developed. To that end, we implemented a
conversion tool that converts \lang into a subset of the \checkedc
language and ensured that model and implementation exhibit the same
behavior (accept and reject the same programs and yield the same return
value).

This approach constitutes an interesting twist to traditional
model-based checking approaches.  Usually, one checks that the
implementation and model agree on all inputs \emph{of the
  implementation}, with the goal of covering as many behaviors as
possible. This is the case, for example, in \citet{lambdajs}, where
they use real test suites to demonstrate the faithfullness of their
core calculus to Javascript. Our approach and goal in this work is
essentially the opposite: as the Clang Checked C implementation does
not fully implement the Checked C spec, there is little hope of
covering all terms that are generated by Clang Checked C. Instead,
we're looking for \emph{inconsistencies}, which could be caused by
bugs either in the Clang Checked C compiler or our own model.  

One inconsistency we found comes from the following:

{\small 
\begin{lstlisting}[xleftmargin=4 mm]
 array_ptr<char> fun(void) : count(3) {
   array_ptr<char> x : count(3);
   x = calloc(3, sizeof(char));
   return x+3;
 }
 int main(void) {
   *(fun()) = 0;
   return 0;
 }
\end{lstlisting}
}\noindent
In this code, the function \code{fun} is supposed to return a
checked array pointer of size 3. Internally, it allocates such an
array, but instead of returning the pointer \code{x} to that array, it
increments that pointer by 3. Then, the \code{main} function just
calls \code{fun}, and tries to assign 0 to its result. Our model
correctly rules out this program, while the Clang Checked C
implementation happily accepted this out-of-bounds
assignment. Interestingly, it correctly rejected programs where the
array had size 1 or 2. This inconsistency has been fixed in the latest
version of the compiler.

We also found the opposite kind of inconsistency---programs that
the Clang Checked C implementation rejects contrary to the spec.
For instance:\footnote{After minimization, this turned out to be a known issue: 
  \url{https://github.com/microsoft/checkedc-clang/issues/1008}}

{\small 
\begin{lstlisting}[xleftmargin=4 mm]
array_ptr<int> f(void) : count(5) {
  array_ptr<int> x : count(5) =
    calloc<int>(5, sizeof(int)); 
  return x;
}
array_ptr<int> g(void ) : count(5) {
  array_ptr<int> x : count(5) =
    calloc<int>(5, sizeof(int)); 
  return x+3;
}
int main(void) {
  return *(0 ? g() : f() + 3);
}    
\end{lstlisting}
}\noindent
In this piece of code both \code{f} and \code{g} functions compute a
pointer to the same index in an array of size 5 (as \code{f} calls
\code{g}). The \code{main} function then creates a ternary expression
whose branches call \code{f} and \code{g}, but the Clang Checked C
implementation rejects this program, as its static analysis is not
sophisticated enough to detect that both branches have the same type.














 \section{Related Work}
\label{sec:related}

Our work is most closely related to prior formalizations of C(-like)
languages that aim to enforce memory safety, but it also touches on
C-language formalization in general.


\myparagraph{Formalizing C and Low-level code}
A number of prior works have looked at formalizing the semantics of C,
including CompCert~\cite{Blazy2009,leroy:hal-00703441},
\citet{ellison-rosu-2012-popl}, \citet{Kang:2015:FCM:2813885.2738005},
and \citet{10.1145/2980983.2908081, Memarian:2019:ECS:3302515.3290380}. These works also model
pointers as logically coupled with either the bounds of the blocks
they point to, or provenance information from which bounds can be
derived. None of these is directly concerned with enforcing
spatial safety, and that is reflected in the design. For example,
memory itself is not be represented as a flat address space, as in our
model or real machines, so memory corruption due to spatial safety
violations, which Checked C's type system aims to prevent, may not be
expressible. That said, these formalizations consider much more of the
C language than does \lang, since they are interested in the entire
language's behavior.

\myparagraph{Spatially Safe C Formalizations}
Several prior works formalize C-language transformations or C-language
dialects aiming to ensure spatial safety. 
\citet{10.1145/2813885.2737979} extends the formalization
of \citet{ellison-rosu-2012-popl} to produce a semantics that detects
violations of spatial safety (and other forms of undefinedness). It
uses a CompCert-style memory model, but ``fattens'' logical pointer
representations to facilitate adding side conditions similar to \lang's.
Its concern is bug finding, not compiling programs to
use this semantics.

CCured~\cite{Necula2005} and Softbound~\cite{softbound} implement
spatially safe semantics for normal C via program transformation. Like
\lang, both systems' operational semantics annotate pointers with
their bounds. CCured's equivalent of array pointers are compiled to be
``fat,'' while SoftBound compiles bounds metadata to a separate
hashtable, thus retaining binary compatibility at higher checking
cost. Checked C uses static type information to enable bounds checks
without need of pointer-attached metadata, as we show in
Section~\ref{sec:compilation}. Neither CCured nor Softbound models
null-terminated array pointers, whereas our semantics ensures that
such pointers respect the zero-termination invariant, leveraging
bounds widening to enhance expressiveness.

Cyclone \cite{Jim2002,GrossmanMJHWC02} is a C dialect that aims to
ensure memory safety; its pointer types are similar to
CCured. Cyclone's formalization~\cite{GrossmanMJHWC02} focuses on the
use of \emph{regions} to ensure temporal safety; it does not formalize
arrays or threats to spatial safety. Deputy~\cite{Feng2006,Condit2007}
is another safe-C dialect that aims to avoid fat pointers; it was an
initial inspiration for Checked C's design~\cite{Elliott2018}, though
it provides no specific modeling for null-terminated array
pointers. Deputy's formalization~\cite{Condit2007} defines its
semantics directly in terms of compilation, similar in style to what
we present in Section~\ref{sec:compilation}. Doing so tightly couples
typing, compilation, and semantics, which are treated independently in
\lang. Separating semantics from compilation isolates meaning 
from mechanism, easing understandability. Indeed, it was this
separation that led us to notice the 
limitation with Checked C's handling of bounds widening.

The most closely related work is the
formalization of \checkedc done by \citet{ruef18checkedc-incr}. They
\DIFdelbegin \DIFdel{were the first to formalize and prove }\emph{\DIFdel{blame}} %DIFAUXCMD
\DIFdel{for }\DIFdelend \DIFaddbegin \DIFadd{present the type system and semantics of }\DIFaddend a core model of \checkedc,
\DIFdelbegin \DIFdel{which shows that any
spatial safety violation owes to invariants violated by unchecked
code.  Our }\DIFdelend \DIFaddbegin \DIFadd{mechanized in Coq, and were the first to prove a blame theorem.  }\lang\DIFadd{'s
}\DIFaddend Coq-based development (Section~\ref{sec:formal}) substantially extends
theirs \DIFdelbegin \DIFdel{,}\footnote{%DIFDELCMD < \url{https://github.com/plum-umd/checkedc/tree/master/coq}%%%
}
%DIFAUXCMD
\addtocounter{footnote}{-1}%DIFAUXCMD
\DIFdel{re-proving the blame theorem after adding }\DIFdelend \DIFaddbegin \DIFadd{to include conditionals, }\DIFaddend dynamically bounded array
pointers with dependent types, null-terminated \DIFdelbegin \DIFdel{pointers, and
}\DIFdelend \DIFaddbegin \DIFadd{array pointers, 
}\DIFaddend dependently typed functions\DIFaddbegin \DIFadd{, and subtyping}\DIFaddend . They postulate that pointer metadata can
be erased \DIFaddbegin \DIFadd{in a real implementation}\DIFaddend , but do not show it\DIFdelbegin \DIFdel{; indeed, we found it nontrivial }\DIFdelend \DIFaddbegin \DIFadd{. Our }\CoreChkC
\DIFadd{compiler, formalized and
validated in PLT Redex via randomized testing, demonstrates that such
metadata }\emph{\DIFadd{can}} \DIFadd{be erased; we found that erasure was non-obvious }\DIFaddend once
null-terminated pointers \DIFaddbegin \DIFadd{and bounds widening }\DIFaddend were considered.









































































 
%DIF <  \ignore{
\DIFdelbegin %DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Other work that might be relavent but for guaranteeing temporal safety, I have recorded some of them in the related work if they are relavent to spatial safety, but I might missed some.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Purify operates on binaries, but only ensures the safety of heap-allocated objects.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Safe C ensures complete temporal safety by using fat-pointers.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  MSCC uses a fat-pointer approach for handling the spatial and temporal safeties regarding stack/heap pointers. According to the experiment in MSCC, it is supposed to be faster than CCured, but it seems that they are in the same level or CCured might be faster in some cases according to.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Fail-Safe C is an updated version of Safe C, and it maintains complete compatibility with ANSI C but incurs significant runtime overhead.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Cyclone is a new dialect designed to minimise the changes required to port over C programs. Cyclone’s region-based memory management system provides a foundation for solving the temporal safety issues for stack pointers in Checked-C. The only difference between the Cyclone’s region-based system and the Checked-C will be time when dangling pointers cause errors. Dangling pointers should be banned at the time when they are used to access memory. If a program contains a function call with a stack pointer that is created and returned to the upper level function call and it is never used to access memory, the program should be considered as valid. 
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Here are several ideas of using metadata instead of fat-pointers, I (Liyi) think they are basically another form of fat-pointer approaches:
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Patil and Fischer address the spatial and temporal safeties by maintaining disjoint metadata and performing checks in a separate “shadow process,” but this requires an additional CPU.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  MemSafe provides a framework for checking spatial and temporal memory safety at runtime. 
%DIF <  Their work is based on transferring an original C program to an updated CFG-based program with extra metadata. These metadata has similar functionality as fat pointer and there are extra
%DIF <  checks allowing them to place extra checks during the program execution. For each pointer, the updated CFG stores information about all possible values of the pointer through possible aliasing. The efficiency of MemSafe can be as effective as CCured.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Write integrity testing -- similar to regional memory management. The so-called colored memory space is essentially giving regional flags to different pointers, and then check if these pointers have potential security threats.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  The following approaches require hardware support:
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Clause et al. describe an efficient technique for detecting memory errors, but it requires custom hardware.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Dhurjati and Adve describe a technique based on the Electric Fence [11] malloc debugger: Their system assigns a unique virtual page to every dynamically allocated object and relies on hardware page protection to detect dangling pointer dereferences.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  There are also few static approaches to the temporal safety in C. However, they are not complete and a lot of them are not even sound. There are four kinds of static approach methods: model checking, abstract interpretation, pattern matching, and pointer analysis. 
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Model Checking. CBMC is a bounded model checker that reasons about all the program paths for C/C++ programs as constraints that can be solved by an SMT solver. When used in finding UAF bugs, CBMC is sound (in a bounded manner) and highly precise but scales only to small programs whose “sizes are restricted” (according to its user manual).
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Thomas Ball and Sriram K. Rajamani developed a model checking framework (C2bp) for checking Temporal Safety Properties in C. The framework allows pointer analysis by using a pointer aliasing algorithm. The problem is that it only deals with small programs, and the pointer aliasing algorithm only detects a small part of aliasing pointers.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  MOPS (MOdel checking Program for Security Properties) makes use of the model checking technique to check for violation of security rules, that are defined as temporal safety properties. As for program representation, MOPS models the program in the form of Push Down Automaton (PDA), that contains all the possible execution paths. Push Down Automata are used as tools to analyze procedural sequential programs, and more specifically those having recursive procedures. As for automata, they are according to Schneider used in the objective of specifying security policies that can be enforced by mechanisms. MOPS makes use of this approach to model security properties in the form of Finite State Automata (FSA), that dictate the order of security-relevant operations sequence. The modularity of security properties was also proposed by MOPS; this approach allows the decomposition of complex security properties into simpler and reusable basic security properties that are easy to model and to extend (such as role based access). MOPS verifies that the security properties are properly respected in all the execution paths of the analyzed program, making use of the model checking on the PDA, and checks if risky states are reachable within the PDA. MOPS does not know that a pointer is an alias of another, so the property is not sound for this program.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Abstract Interpretation. Clang Static Analyzer is an abstract interpreter for analyzing C/C++ programs. It adopts a highly unsound model by analyzing only a small subset of the program paths in order to achieve scalability and precision. To scale for large codebases with few false alarms, Clang limits its UAF-bug-finding ability by performing an intraprocedural analysis (with inlining). In general, such tools refrain from reporting too many false alarms, but at the expense of missing many UAF bugs.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Pattern Matching. Coccinelle is a pattern-based tool for analyzing and certifying C programs. Coccinelle can find UAF bugs based on some patterns given. Due to the lack of the points-to information, Coccinelle can be both fairly unsound and imprecise but is highly scalable (due to its pattern-matching nature).
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Pointer Analysis. Supa is a state-of-the-art demand-driven pointer analysis that is field-, flow- and context-sensitive but path- insensitive for C programs. When used in finding UAF bugs, Supa can be regarded as reasoning about all the program paths with an extremely coarse abstraction, in order to achieve soundness and scalability.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Yan et al. develops a Spatio-Temporal context reduction technique for  doing pointer-analysis for detecting use-after-free vulnerabilities, which are essentially temporal safety. They mainly focus on the heap pointer allocation-free detection to  check if a pointer is used after the free function call for the memory field the pointer points to. The technique is based on static analysis. The main idea is still based on intraprocedural control flow analysis. It relies on context sensitive reduction technique to reduce the search function calling path spaces for analyzing pointer aliasing.  The context sensitivity and their pointer analysis algorithm is applied in a state-of-the-art manner. The information for the algorithm of search pointer aliasing reduces the calling context path, while the context path information enhances the efficiency of the algorithm.  However, the technique is not complete. It will ban a large number of valid C programs due to false use-after-free vulnerabilities.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  It seems that they might not detect the use-after-free error in this case. In addition, the work does not handle stack pointer use-after-free vulnerabilities.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  ASAP: As Static As Possible memory management -- use data flow analysis, garbage collection and region memory management tools to ensure the security safety of C programs by static analysis. In order to guarantee the use-after-free, it requires the program written in a special way: in a linearly typed program, each value must be used exactly once. It does not include examples of dealing with stack pointers. It shows that in a pointer management world, a C program temporal safety cannot be fully analyzed by only static analysis.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Jia-Ju Bai et al. develops a static method to detect use-after-free bugs in Linux device drivers. It is a UAF bug in the concurrent system. The basic algorithm is simple. It first goes through each single-threaded code to collect a read/write set storing point-to information. The information collection is through traditional intraprocedural CFG analysis. Then, it uses a trace analysis tool to discover UAF bugs. This is achievable only in dealing with linux device drivers, since usually, these drivers are simple and the concurrency is very formulated.  I believe if we apply the same process in dealing with C, the method will not be sound.
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  Industrial tools:
%DIFDELCMD < 

%DIFDELCMD < %%%
%DIF <  There are also some industrial level tools for static checking bugs in C. However, they are either not able to check UAF bugs or they only use heuristics to check very small sets of UAF bugs. They include CppCheck, Clang Core, Clang Alpha, CodeSonar, Facebook Infer,  Splint standard, Splint weak. For example, CodeSonar state-based checkers do not check temporal safety. They require insertion of extra code in order for the tool to check if a supposed deadcode will be reached or not. Coverity is a dataflow analysis tool that relies on inter-procedural analysis techniques. The analysis is neither sound nor complete, that is, there may be both defects which are not reported and there may be false alarms. Coverity Prevent implements an incremental analysis which means that the system automatically infers what parts of the source code that have to be re-analyzed after the code has been modified. This typically reduces the analysis time substantially, but may of course imply a complete re-analysis in the worst case. Klocwork does similar things to Coverity and Coverity Prevent.
%DIF <  }
 %DIFDELCMD < 

%DIFDELCMD < %%%
\DIFdelend \section{Conclusion and Future Work}
\label{sec:conclude}

This paper presented \CoreChkC, a formalization of an extended core of
the Checked C language which aims to provide spatial memory
safety. \DIFdelbegin %DIFDELCMD < \lang %%%
\DIFdelend \DIFaddbegin \CoreChkC \DIFaddend models dynamically sized and
null-terminated arrays with dependently typed bounds that can
additionally be widened at runtime. We prove, in Coq, the key safety
property of Checked C for our formalization, {\em blame}: if a mix of
checked and unchecked code gives rise to a spatial memory safety
violation, then this violation originated in an unchecked part of the
code. We also show how programs written in \CoreChkC (whose
semantics leverage fat pointers) can be compiled to \elang (which does
not) while preserving their behavior. \DIFdelbegin \DIFdel{Finally, we developed a random
}\DIFdelend \DIFaddbegin \DIFadd{We developed a version of }\lang
\DIFadd{written in PLT Redex, and used a custom term generator in conjunction with Redex's
randomized }\DIFaddend testing framework to \DIFdelbegin \DIFdel{guide the design of our formal model by comparing
it }\DIFdelend \DIFaddbegin \DIFadd{give confidence that compilation is
correct. We also used this framework to cross-check }\lang
\DIFaddend against the \checkedc compiler, finding multiple inconsistencies
in the process. 

As future work, we \DIFdelbegin \DIFdel{are interested in designing an a way to automatically port legacy C code to }%DIFDELCMD < \checkedc%%%
\DIFdel{.  We also want to
further extend our }\DIFdelend \DIFaddbegin \DIFadd{wish to extend }\DIFaddend \CoreChkC \DIFdelbegin \DIFdel{model to include more C behaviors, such as function pointers, with our }\DIFdelend \DIFaddbegin \DIFadd{to model more of Checked
C, with our Redex-based }\DIFaddend testing framework guiding the \DIFdelbegin \DIFdel{design process. }\DIFdelend \DIFaddbegin \DIFadd{process. The
most interesting Checked C feature not yet modeled is }\emph{\DIFadd{interop
  types}} \DIFadd{(itypes), which are used to simplify interactions with
unchecked code via function calls. A function whose
parameters are itypes can be passed checked or unchecked pointers
depending on whether the caller is in a checked region. This feature
allows for a more modular C-to-Checked C porting process, but complicates reasoning
about blame. A more ambitious next step would be to extend an existing
formally verified framework for C, such as CompCert~}\cite{compcert} \DIFadd{or VeLLVM
}\cite{Zhao:2012:FLI:2103621.2103709}\DIFadd{, with Checked C features, towards
producing a verified-correct Checked C compiler. We believe that
}\lang\DIFadd{'s Coq and Redex models lay the foundation for such a step, but
substantial engineering work remains.
 }\DIFaddend 

%DIF <   \ignore{
%DIF <  \begin{acks}                            This material is based upon work supported by the
%DIF <    \grantsponsor{GS100000001}{National Science
%DIF <      Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
%DIF <    No.~\grantnum{GS100000001}{nnnnnnn} and Grant
%DIF <    No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
%DIF <    conclusions or recommendations expressed in this material are those
%DIF <    of the author and do not necessarily reflect the views of the
%DIF <    National Science Foundation.
%DIF <  \end{acks}
%DIF <  }
\DIFaddbegin \bigskip
\DIFaddend 

\DIFaddbegin \paragraph*{\DIFadd{Acknowledgments}}
\DIFadd{We thank the anonymous reviewers for their helpful, constructive
comments. This work was supported in part by a gift from Microsoft. 
}








\DIFaddend \begin{small}
\DIFaddbegin \balance
\DIFaddend \bibliography{IEEEabrv,paper,sources}
\end{small}
\DIFaddbegin 

\iftr
\DIFaddend \newpage
\appendix
\section{Appendix}

\DIFaddbegin \subsection{Differences with the Coq and Redex Models}\label{app:model-diffs}



\DIFadd{The Coq and Redex models of }\lang \DIFadd{may be found at }\url{https://github.com/plum-umd/checkedc}\DIFadd{.
The Coq model's syntax is slightly different from that in
Fig.~\ref{fig:checkc-syn}. In particular, the arguments in a function call
are restricted to variables and constants, according to
a separate well-formedness condition. A function call }\code{f(e)} \DIFadd{can
always be written in }\code{let x = e in f(x)} \DIFadd{to cope.
In addition,
conditionals have two syntactic forms: }\code{EIf} \DIFadd{is a normal
conditional, and }\code{EIfDef} \DIFadd{is one whose boolean guard is of the
form }\estar{x}\DIFadd{. By syntactically distinguishing these two
cases, the Coq model does not need the }\emph{[\DIFadd{prefer}]} \DIFadd{rule for
}\code{if (*x)}\DIFadd{$...$ forms as in
Fig.~\ref{fig:c-context}. The Redex model }\emph{\DIFadd{does}} \DIFadd{prioritize such
forms but not the same way as in the figure. It uses a variation of
the }\textsc{\DIFadd{S-Var}} \DIFadd{rule: The 
modified rule is equipped with a precondition that is false whenever
}\textsc{\DIFadd{S-IfNTT}} \DIFadd{is applicable.
}


\DIFadd{The Coq model uses a runtime stack $\varphi$ as described at the start
of Sec.~\ref{sec:semantics}.
The Redex model introduces let bindings during evaluation to
simulate a runtime stack. For example, consider the expression 
$e \equiv \elet{x}{(\evalue{5}{\tint})}{\ebinop{x}{x}}$. Expression $e$ first steps to
$\elet{x}{(\evalue{5}{\tint})}{\ebinop{(\evalue{5}{\tint})}{x}}$, which in
turns steps to
$\elet{x}{(\evalue{5}{\tint})}{\ebinop{(\evalue{5}{\tint})}{(\evalue{5}{\tint})}}$. Since
the rhs of $x$ is a value, the let binding in $e$ effectively
functions as a stack that maps from $x$ to $\evalue{5}{\tint}$. The
let form remains in the expression and lazily replaces the variables
in its body. The let form can be removed from the expression only if its
body is evaluated to a value, e.g., 
$\elet{x}{(\evalue{5}{\tint})}{(\evalue{10}{\tint})}$
steps to 
$\evalue{10}{\tint}$. The rule for popping let bindings in this manner
corresponds to the }\textsc{\DIFadd{S-Ret}} \DIFadd{rule in Fig.~\ref{fig:semantics}.
Leveraging let bindings adds complexity to the semantics but
simplifies typing/consistency and term generation during randomized testing.
}


\DIFaddend \subsection{Typing Rules for Literal Pointers}\label{sec:literal-pointer-typing}

\DIFdelbegin \DIFdel{One thing we elided from the main presentation is the typing }\DIFdelend \DIFaddbegin \DIFadd{The typing }\DIFaddend of integer literals\DIFdelbegin \DIFdel{(}\DIFdelend \DIFaddbegin \DIFadd{, }\DIFaddend which can also be pointers to the
heap\DIFdelbegin \DIFdel{).These rules
are shown }\DIFdelend \DIFaddbegin \DIFadd{, was presented in Sec.~\ref{sec:theorem} }\DIFaddend in Fig.~\ref{fig:const-type}. \DIFaddbegin \DIFadd{Here
we describe these rules further.
}

\DIFaddend The variable type rule
($\textsc{T-Var}$) simply checks if a given variable has the defined
type in $\Gamma$; the constant rule ($\textsc{T-Const}$) is slightly
more involved.  First, it ensures that the type annotation $\tau$ does
not contain any free variables. More importantly, it ensures that the
literal itself is well typed using an auxilliary typing relation
\DIFdelbegin \DIFdel{$\sigma \vdash n : \tau$, which is implicitly indexed by a given heap
$\heap$}\DIFdelend \DIFaddbegin \DIFadd{$\heap;\sigma \vdash n : \tau$}\DIFaddend .

If the literal's type is an integer, an unchecked pointer, or a null
pointer, it is well typed, as shown by the top three rules in
Fig.~\ref{fig:const-type}. However, if it is a checked pointer
$\tptr{\omega}{\cmode}$, we need to ensure that what it points to in
the heap is of the appropriate pointed-to type ($\omega$), and also
recursively ensure that any literal pointers reachable this way are
also well-typed. This is captured by the bottom rule in the figure,
which states that for every location $n+i$ in the pointers' range
$[n, n+\size(\omega))$, where $\size$ yields the size of its argument,
  then the value at the location $\heap(n+i)$ is also well-typed.
  However, as heap snapshots can contain cyclic structures (which
  would lead to infinite typing deriviations), we use a scope $\sigma$
  to assume that the original pointer is well-typed when checking the
  types of what it points to. The middle rule then accesses the scope
  to tie the knot and keep the derivation finite, just like in
  \citet{ruef18checkedc-incr}.

\DIFdelbegin %DIFDELCMD < \begin{figure}[h]
%DIFDELCMD <  {\small
%DIFDELCMD <  %%%
\DIFdelFL{\text{Type Rules for Constants and Variables:}
 }%DIFDELCMD < \begin{mathpar}
%DIFDELCMD <    \inferrule[T-Var]
%DIFDELCMD <        {%%%
\DIFdelFL{x : \tau \in \Gamma}%DIFDELCMD < }
%DIFDELCMD <        {%%%
\DIFdelFL{\Gamma;\Theta \vdash_m x : \tau}%DIFDELCMD < }
%DIFDELCMD <   

%DIFDELCMD <    \inferrule[T-Const]
%DIFDELCMD <        {%%%
\DIFdelFL{\fv(\tau) = \emptyset }%DIFDELCMD < \\ %%%
\DIFdelFL{\emptyset \vdash n : \tau}%DIFDELCMD < }
%DIFDELCMD <        {%%%
\DIFdelFL{\Gamma;\Theta\vdash_m }%DIFDELCMD < \evalue{n}{\tau} %%%
\DIFdelFL{: \tau}%DIFDELCMD < }
%DIFDELCMD <  \end{mathpar}
%DIFDELCMD <      

%DIFDELCMD <  %%%
\DIFdelFL{\text{Rules for Checking Constant Pointers In Heap:}
 }%DIFDELCMD < \begin{mathpar}
%DIFDELCMD <    \inferrule
%DIFDELCMD <        {}
%DIFDELCMD <        {%%%
\DIFdelFL{\sigma \vdash n : }%DIFDELCMD < \tint}
%DIFDELCMD <   

%DIFDELCMD <    \inferrule
%DIFDELCMD <        {}
%DIFDELCMD <        {%%%
\DIFdelFL{\sigma \vdash n : }%DIFDELCMD < \tptr{\omega}{\umode}}
%DIFDELCMD <   

%DIFDELCMD <    \inferrule
%DIFDELCMD <        {}
%DIFDELCMD <        {%%%
\DIFdelFL{\sigma \vdash 0 : }%DIFDELCMD < \tptr{\omega}{\cmode}}
%DIFDELCMD <   

%DIFDELCMD <    \inferrule
%DIFDELCMD <        {\evalue{n}{\tptr{\omega}{\cmode}}%%%
\DIFdelFL{\in \sigma}%DIFDELCMD < }
%DIFDELCMD <        {%%%
\DIFdelFL{\sigma \vdash n : }%DIFDELCMD < \tptr{\omega}{\cmode}}
%DIFDELCMD <   

%DIFDELCMD <    \inferrule
%DIFDELCMD <        {%%%
\DIFdelFL{\forall i \in }%DIFDELCMD < [%%%
\DIFdelFL{0,\size(\omega)) .
            \sigma \cup \{(n:}%DIFDELCMD < \tptr{\omega}{\cmode}%%%
\DIFdelFL{) \}\vdash }%DIFDELCMD < \heap%%%
\DIFdelFL{(n+i)}%DIFDELCMD < }
%DIFDELCMD <        {%%%
\DIFdelFL{\sigma \vdash n : }%DIFDELCMD < \tptr{\omega}{\cmode}}
%DIFDELCMD <  \end{mathpar}
%DIFDELCMD <  }
%DIFDELCMD <  %%%
%DIFDELCMD < \caption{%
{%DIFAUXCMD
\DIFdelFL{Type Rules for Checking Constants/Variables}}
 %DIFAUXCMD
%DIFDELCMD < \label{fig:const-type}
%DIFDELCMD <  \end{figure}
%DIFDELCMD < 

%DIFDELCMD < %%%
\DIFdelend \subsection{Other Semantic Rules}\label{sec:rem-semantics}

Fig.~\ref{fig:rem-semantics} shows the remaining semantic rules for
$\lang$. We explain a selected few rules in this subsection.


\begin{figure*}[t]
{\small
\begin{mathpar}

\inferrule [S-Var]{} {(\varphi,\heap,x)\longrightarrow (\varphi,\heap,\varphi(x))}

    \inferrule[S-DefArray]{\heap(n)=\evalue{n_a}{\tau_a} \\ 0 \in [n_l,n_h)}
    {(\varphi,\heap,\estar{\evalue{n}{\tntarrayptr{n_l}{n_h}{\tau}{\cmode}}}) \longrightarrow (\varphi,\heap,\evalue{n_a}{\tau})}


    \inferrule[S-DefArrayBound]{0 \not\in [n_l,n_h)}
     { (\varphi,\heap,\estar{\evalue{n}{\tallarrayptr{n_l}{n_h}{\tau}{c}}}) \longrightarrow (\varphi,\heap,\ebounds)}

    \inferrule[S-DefNTArrayBound]{0 \notin [n_l,n_h]}
    {(\varphi,\heap,\estar{\evalue{n}{\tntarrayptr{n_l}{n_h}{\tau}{\cmode}}}) \longrightarrow (\varphi,\heap,\ebounds)}


    \inferrule[S-Assign]{\heap(n)=\evalue{n_a}{\tau_a} }
      {(\varphi,\heap,\eassign{\evalue{n}{\tptr{\tau}{\cmode}}}{\evalue{n_1}{\tau_1}}) \longrightarrow (\varphi,\heap[n \mapsto \evalue{n_1}{\tau}],\evalue{n_1}{\tau})}

    \inferrule[S-AssignNull]{}
      {(\varphi,\heap,\eassign{\evalue{0}{\tptr{\omega}{\cmode}}}{\evalue{n_1}{\tau_1}}) \longrightarrow (\varphi,\heap,\enull)}

    \inferrule[S-AssignArrBound]{0 \not\in [n_l,n_h) }
      {(\varphi,\heap,\eassign{\evalue{n}{\tallarrayptr{n_l}{n_h}{\tau}{\cmode}}}{\evalue{n_1}{\tau_1}}) \longrightarrow (\varphi,\heap,\ebounds)}

  \inferrule[S-Malloc]{\varphi(\omega)=\omega_a \\ \mathtt{alloc}(\heap,\omega_a)=(n,\heap')}
   { (\varphi,\heap,\emalloc{\omega}) \longrightarrow (\varphi,\heap',\evalue{n}{\tptr{\omega_a}{\cmode}})}

  \inferrule[S-MallocBound]{\varphi(\omega)=\tallarray{n_l}{n_h}{\tau}\\ (n_l \neq 0 \vee n_h \le 0)}
    { (\varphi,\heap,\emalloc{\omega}) \longrightarrow (\varphi,\heap',\ebounds)}

    \inferrule[S-IfT]{n \neq 0 }
    {(\varphi,\heap,\eif{\evalue{n}{\tau}}{e_1}{e_2}) \longrightarrow (\varphi,\heap,e_1)}

    \inferrule[S-IfF]{}
    {(\varphi,\heap,\eif{\evalue{0}{\tau}}{e_1}{e_2}) \longrightarrow (\varphi,\heap,e_2)}

    \inferrule[S-Unchecked]{}
    {(\varphi,\heap,\eunchecked{\evalue{n}{\tau}} \longrightarrow (\varphi,\heap,\evalue{n}{\tau})}

    \DIFdelbeginFL %DIFDELCMD < \inferrule[S-Str]{
%DIFDELCMD <         0 \in [n_l,n_h]
%DIFDELCMD < \\ \heap(n+n_a) = 0 
%DIFDELCMD < \\ (\forall i. n \le i < n+n_a \Rightarrow (\exists n_i\;t_i. \heap(n+i) = \evalue{n_i}{\tau_i} \wedge n_i \neq 0))}
%DIFDELCMD <     %%%
\DIFdelendFL \DIFaddbeginFL \inferrule[S-Str]{
        0 \in [n_l,n_h]
\\ n_a \le n_h
\\ \heap(n+n_a) = 0 
\\ (\forall i. n \le i < n+n_a \Rightarrow (\exists n_i\;t_i. \heap(n+i) = \evalue{n_i}{\tau_i} \wedge n_i \neq 0))}
    \DIFaddendFL {(\varphi,\heap,\estrlen{\evalue{n}{\tarrayptr{n_l}{n_h}{\tau}{m}}}) \longrightarrow (\varphi,\heap,\evalue{n_a}{\tint})}

    \inferrule[S-StrBounds]{
        0 \notin [n_l,n_h]
}
    {(\varphi,\heap,\estrlen{\evalue{n}{\tarrayptr{n_l}{n_h}{\tau}{c}}}) \longrightarrow (\varphi,\heap,\ebounds)}

    \inferrule[S-StrNull]{}
    {(\varphi,\heap,\estrlen{\evalue{0}{\tarrayptr{n_l}{n_h}{\tau}{c}}}) \longrightarrow (\varphi,\heap,\enull)}

    \inferrule[S-Add]{n = n_1 + n_2}
    {(\varphi,\heap,\evalue{n_1}{\tint} \plus \evalue{n_2}{\tint}) \longrightarrow (\varphi,\heap, n)}

    \inferrule[S-AddArr]{n = n_1 + n_2\\ n_l' = n_l - n_2 \\ n_h' = n_h - n_2}
    {(\varphi,\heap,\evalue{n_1}{\tallarrayptr{n_l}{n_h}{\tau}{m}} \plus \evalue{n_2}{\tint}) \longrightarrow (\varphi,\heap, \evalue{n}{\tallarrayptr{n_l'}{n_h'}{\tau}{m}})}

n    \inferrule[S-AddArrNull]{}
    {(\varphi,\heap,\evalue{0}{\tallarrayptr{n_l}{n_h}{\tau}{c}} \plus \evalue{n_2}{\tint}) \longrightarrow (\varphi,\heap, \enull)}

\end{mathpar}

}
\caption{Remaining \lang Semantics Rules (extends Fig.~\ref{fig:semantics})}
\label{fig:rem-semantics}
\end{figure*}

Rule \textsc{S-Var} loads the value for $x$ in stack $\varphi$.
Rule \textsc{S-DefArray} dereferences an array pointer, which is similar to the Rule \textsc{\DIFdelbegin \DIFdel{S-DefArray}\DIFdelend \DIFaddbegin \DIFadd{S-DefNTArray}\DIFaddend } in Fig.~\ref{fig:semantics} \DIFaddbegin \DIFadd{(dealing with null-terminated array pointers)}\DIFaddend .
The only difference is that the range of $0$ is at $[n_l,n_h)$ not $[n_l,n_h]$, meaning that one cannot dereference the upper-bound position in an array.
Rules \textsc{DefArrayBound} and \textsc{DefNTArrayBound} describe an error case for a dereference operation.
If we are dereferencing an array/NT-array pointer and the mode is $\cmode$, $0$ must be in the range from $n_l$ to $n_h$ \DIFaddbegin \DIFadd{(meaning that the dereference is in-bound)}\DIFaddend ; if not, the system results in a $\ebounds$ error. Obviously, the dereference of an array/NT-array pointer also experiences a $\enull$ state transition if $n\le 0$.

Rules \textsc{S-Malloc} and \textsc{S-MallocBound} describe the $\emalloctext$ semantics. Given a valid type $\omega_a$ that contains no free variables, $\mathtt{alloc}$ function returns an address pointing at the first position of an allocated space whose size is equal to the size of $\omega_a$, and a new heap snapshot $\heap'$ that marks the allocated space for the new allocation. The $\emalloctext$ is transitioned to the address $n$ with the type ${\tptr{\omega_a}{\cmode}}$ and new updated heap. It is possible for $\emalloctext$ to transition to a $\ebounds$ error if the $\omega_a$ is an array/NT-array type $\tallarray{n_l}{n_h}{\tau}$, and either $n_l \neq 0$ or $n_h \le 0$. \DIFaddbegin \DIFadd{This can happen when the bound variable is evaluated to a bound constant that is not desired. 
}\DIFaddend 


\subsection{Subtyping for dependent types}
\label{app:le}

The subtyping relation given in Fig.~\ref{fig:checkc-subtype} involves
dependent bounds, i.e., bounds that may refer to variables. To decide
premises $b \leq b'$, we need a decision procedure that accounts for
the possible values of these variables. This process considers
$\Theta$, tracked by the typing judgment, and $\varphi$, the current
stack snapshot (when performing subtyping as part of the type
preservation proof). We

\begin{defi}[Inequality]

\begin{itemize}

\item $n \le m$ if $n$ is less than or equal to $m$.
\item $x+n \le x + m$ if $n$ is less than or equal to $m$.
\item All other cases result in $\efalse$.

\end{itemize}
\end{defi}

To capture bound variables in dependent types, the \checkedc subtyping
relation ($\sqsubseteq$) is parameterized by a restricted stack
snapshot $\varphi|_{\rho}$ and the predicate map $\Theta$, where
$\varphi$ is a stack and $\rho$ is a set of
variables. $\varphi|_{\rho}$ means to restrict the domain of $\varphi$
to the variable set $\rho$. Clearly, we have the relation:
$\varphi|_{\rho} \subseteq \varphi$. The meaning of $\sqsubseteq$
being parameterized by $\varphi|_{\rho}$ refers to that when we
compare two bounds $b \le b'$, we actually do
$\varphi|_{\rho}(b) \le \varphi|_{\rho}(b')$ by interpreting the
variables in $b$ and $b'$ with possible values in $\varphi|_{\rho}$.
Let's define a subset relation $\preceq$ for two restricted stack
snapshot $\varphi|_{\rho}$ and $\varphi'|_{\rho}$:

\begin{defi}[Subset of Stack Snapshots]
  Given two $\varphi|_{\rho}$ and $\varphi'|_{\rho}$,
  $\varphi|_{\rho} \preceq \varphi'|_{\rho}$, iff for $x\in\rho$ and
  $y$,
  $(x,y) \in \varphi|_{\rho} \Rightarrow (x,y) \in \varphi'|_{\rho}$.
\end{defi}

For every two restricted stack snapshots $\varphi|_{\rho}$ and
$\varphi'|_{\rho}$, such that
$\varphi|_{\rho} \preceq \varphi'|_{\rho}$, we have the following
theorem in \checkedc (proved in Coq):

\begin{thm}[Stack Snapshot Theorem]
  Given two types $\tau$ and $\tau'$, two restricted stack snapshots
  $\varphi|_{\rho}$ and $\varphi'|_{\rho}$, if
  $\varphi|_{\rho}\preceq \varphi'|_{\rho}$, and
  $\tau \sqsubseteq \tau'$ under the parameterization of
  $\varphi|_{\rho}$, then $\tau \sqsubseteq \tau'$ under the
  parameterization of $\varphi'|_{\rho}$.
\end{thm}

Clearly, for every $\varphi|_{\rho}$, we have
$\emptyset \preceq \varphi|_{\rho}$. The type checking stage is a
compile-time process, so $\varphi|_{\rho}$
is $\emptyset$ at the type checking stage. Stack snapshots are needed
for proving type preserving, as variables in bounds expressions are
evaluated away.


\DIFdelbegin \DIFdel{As mentioned in the main text, $\sqsubseteq$ is also parameterized by
$\Theta$, which provides the range of allowed values for a bound
variable; thus, more $\sqsubseteq$ relation is provable. For example,
in Fig.~\ref{fig:strncat-ex}, the }%DIFDELCMD < \code{strlen} %%%
\DIFdel{operation in line 4
turns the type of }%DIFDELCMD < \code{a} %%%
\DIFdel{to be $\tntarrayptr{0}{x}{\tint}{\cmode}$
and extends the upper bound to }%DIFDELCMD < \code{x}%%%
\DIFdel{. In the }%DIFDELCMD < \code{strlen} %%%
\DIFdel{type
rule, it also inserts a predicate }%DIFDELCMD < \code{x}%%%
\DIFdel{$\ge 0$ in $\Theta$; thus,
the cast operation in line 16 is valid because
$\tntarrayptr{0}{x}{\tint}{\cmode} \sqsubseteq
\tntarrayptr{0}{0}{\tint}{\cmode}$ is provable when we know
}%DIFDELCMD < \code{n}%%%
\DIFdel{$\ge 0$.
}%DIFDELCMD < 

%DIFDELCMD < %%%
\DIFdel{Note that if $\varphi$ and $\Theta$ are $\emptyset$, we do only the
syntactic $\le$ comparison; otherwise, we apply $\varphi$ to both
sides of $\sqsubseteq$, and then determine the $\le$ comparasion based
on a Boolean predicate decision procedure on top of $\Theta$. This
process allows us to type check both an input expression and the
intermediate expression after evaluating an expression. 
}%DIFDELCMD < 

%DIFDELCMD < \subsection{Other Type Rules}\label{rem-type}
%DIFDELCMD < 

%DIFDELCMD < %%%
\DIFdel{Here we show the type rules for other }%DIFDELCMD < \checkedc %%%
\DIFdel{operations in Fig.~\ref{fig:rem-type-system}.
}%DIFDELCMD < 

%DIFDELCMD < \begin{figure}[t]
%DIFDELCMD < %%%
\DIFdelendFL \DIFaddbeginFL \begin{figure}[h!]
\DIFaddendFL {\small
  \begin{mathpar}
    \inferrule[T-Def]
              {\Gamma;\Theta \vdash_m e : \tptr{\tau}{m'} \\
                m \leq m'}
              {\Gamma;\Theta \vdash_m \estar{e} : \tau}

    \inferrule[T-Mac]
              {}
              {\Gamma; \Theta \vdash_m \emalloc{\omega} : \tptr{\omega}{\cmode}}

    \inferrule[T-Add]
              {\Gamma; \Theta \vdash_m e_1 : \tint \\
                \Gamma; \Theta \vdash_m e_2 : \tint}
              {\Gamma; \Theta \vdash_m (e_1 \plus e_2) : \tint }

    \inferrule[T-Ind] 
              {\Gamma; \Theta \vdash_m e_1 : \tptr{\tallarrayb{\bvar}{\tau}}{m'} \\
                \Gamma; \Theta \vdash_m e_2 : \tint \\
                m \leq m'}              
              {\Gamma; \Theta \vdash_m \estar{(\ebinop{e_1}{e_2})} : \tau}

    \inferrule[T-Assign]
              {\Gamma; \Theta \vdash_m e_1 : \tptr{\tau}{m'} \\
                \Gamma; \Theta \vdash_m e_2 : \tau' \\
                \tau'\sqsubseteq \tau \\
                m \leq m'}
              {\Gamma; \Theta \vdash_m \eassign{e_1}{e_2} : \tau}

   \inferrule[T-IndAssign]
              {\Gamma; \Theta \vdash_m e_1 : \tptr{\tallarrayb{\bvar}{\tau}}{m'}\\
                \Gamma; \Theta \vdash_m e_2 : \tint \\
                \Gamma; \Theta \vdash_m e_3 : \tau' \\
                \tau'\sqsubseteq \tau \\
                m \leq m'}
              {\Gamma; \defscope \vdash_m \eassign{(e_1 \plus e_2)}{e_3} : \tau}

  \DIFdelbeginFL %DIFDELCMD < \inferrule[T-Unchecked]
%DIFDELCMD <               {%%%
\DIFdelFL{\Gamma;\Theta \vdash_u e : \tau}%DIFDELCMD < }
%DIFDELCMD <               {%%%
\DIFdelFL{\Gamma;\Theta \vdash_m }%DIFDELCMD < \eunchecked{e} %%%
\DIFdelFL{: \tau}%DIFDELCMD < }
%DIFDELCMD <   %%%
\DIFdelendFL \end{mathpar}
}
\caption{Remaining \lang Type Rules (extends Fig.~\ref{fig:type-system-1})}
\label{fig:rem-type-system}
\end{figure}

\DIFaddbegin \DIFadd{As mentioned in the main text, $\sqsubseteq$ is also parameterized by
$\Theta$, which provides the range of allowed values for a bound
variable; thus, more $\sqsubseteq$ relation is provable. For example,
in Fig.~\ref{fig:strcat-ex}, the }\code{strlen} \DIFadd{operation in line 4
turns the type of }\code{dst} \DIFadd{to be $\tntarrayptr{0}{x}{\tint}{\cmode}$
and extends the upper bound to }\code{x}\DIFadd{. In the }\code{strlen} \DIFadd{type
rule, it also inserts a predicate }\code{x}\DIFadd{$\ge 0$ in $\Theta$; thus,
the cast operation in line 16 is valid because
$\tntarrayptr{0}{x}{\tint}{\cmode} \sqsubseteq
\tntarrayptr{0}{0}{\tint}{\cmode}$ is provable when we know
}\code{x}\DIFadd{$\ge 0$.
}


\DIFadd{Note that if $\varphi$ and $\Theta$ are $\emptyset$, we do only the
syntactic $\le$ comparison; otherwise, we apply $\varphi$ to both
sides of $\sqsubseteq$, and then determine the $\le$ comparasion based
on a Boolean predicate decision procedure on top of $\Theta$. This
process allows us to type check both an input expression and the
intermediate expression after evaluating an expression. 
}

\subsection{Other Type Rules}\label{rem-type}

\DIFadd{Here we show the type rules for other }\checkedc \DIFadd{operations in Fig.~\ref{fig:rem-type-system}.
}\DIFaddend Rule \textsc{T-Def} is for dereferencing a non-array pointer. 
The statement $m \leq m'$ \DIFdelbegin \DIFdel{relates the unchecked region for a term with
its sub-terms. We require that if the sub-term has an unchecked region, so does the whole term}\DIFdelend \DIFaddbegin \DIFadd{ensures that no unchecked pointers are used in checked regions}\DIFaddend .
Rule \textsc{T-Mac} deals with
$\emalloctext$ operations. There is a well-formedness check to require
that the possible bound variables in $\omega$ must be in the domain of
$\Gamma$ (see Fig.~\ref{fig:wftypesandbounds}). \DIFaddbegin \DIFadd{This is similar to the well-formedness assumption of the type environment (Definition~\ref{type-wellformed}) }\DIFaddend Rule \textsc{T-Add} deals with binary operations whose sub-terms are integer expressions, while rule \textsc{T-Ind} serves the case for pointer arithmetic. For simplicity, in the \checkedc formalization, we do not allow arbitrary pointer arithmetic. The only pointer arithmetic operations allowed are the forms shown in rules \textsc{T-Ind} and \textsc{T-IndAssign} in Fig.~\ref{fig:rem-type-system}. Rule \textsc{T-Assign} \DIFdelbegin \DIFdel{is for assigning }\DIFdelend \DIFaddbegin \DIFadd{assigns }\DIFaddend a value to a non-array pointer location. The predicate $\tau'\sqsubseteq \tau$ requires that the value being assigned is a subtype of the pointer type.
The \textsc{T-IndAssign} rule is an extended assignment operation for handling assignments for array/NT-array pointers with pointer arithmetic. Rule \textsc{T-Unchecked} type checks \code{unchecked} blocks.

\subsection{Struct Pointers}\label{appx:struct}

\checkedc has \kw{struct} types and \kw{struct} pointers. Fig.~\ref{fig:checkc-struct} contains the syntax of \kw{struct} types as well as new subtyping relations built on the \kw{struct} values.
For a \kw{struct} typed value, \checkedc has a special operation for it, which is $\eamper{e}{f}$. This operation indexes the $f$-th position \kw{struct}~$T$ item, if the expression $e$ is evaluated to a \kw{struct} pointer $\tptr{\tstruct{T}}{m}$. Rule \textsc{T-Struct} in Fig.~\ref{fig:checkc-struct} describes its typing behavior.
Rules \textsc{S-StructChecked} and \textsc{S-StructUnChecked} describe the semantic behaviors of $\eamper{e}{f}$ on a given \kw{struct} \code{checked}/\code{unchecked} pointers, while rule \textsc{S-StructNull} describes a \code{checked} \kw{struct} null-pointer case.
In our Coq/Redex formalization, we include the \kw{struct} values and the operation $\eamper{e}{f}$. We omit it in the main text due to the paper length limitation.

\begin{figure}
{\small
$\begin{array}{l}
\text{  Struct Syntax: }\\[0.5em]
  \begin{array}{ll}
 \mathtt{Type} & \tstruct{T}
\\[0.2em]
     \text{Structdefs} & D \; \in \; T \rightharpoonup fs \\[0.2em]
      \text{Fields} & fs \; ::= \; \tau~\mathtt{f} \mid \tau~\mathtt{f}; fs 
    \end{array}\\[2em]
\text{  Struct Subtype: }\\[0.5em]
\begin{array}{l}
    D(T) = fs \wedge fs(0) = \tnat \Rightarrow  \tptr{\tstruct{T}}{m} \sqsubseteq \tptr{\tnat}{m}\\[0.5em]
    D(T) = fs \wedge fs(0) = \tnat \wedge 0 \le b_l \wedge b_h \le 1 \\[0.2em]
 \qquad\qquad \Rightarrow 
       \tptr{\tstruct{T}}{m} \sqsubseteq \tarrayptr{b_l}{b_h}{\tnat}{m}
    \end{array}
\\[3em]
\text{  Struct Type Rule: }\\[0.5em]
    \end{array}
$

{
\begin{mathpar}
  \inferrule [T-Struct]
  {\Gamma; \Theta \vdash_m e :  {\tptr{\tstruct{T}}{m}} \\
    D(T) = fs \\ fs(f)=\tau_f}
  {\Gamma; \Theta \vdash_m \eamper{e}{f} : \tptr{\tau_f}{m}}

\end{mathpar}
}
{
$\begin{array}{l}
\text{Struct Semantics: }
\end{array}
$
}
{
\begin{mathpar}
  \inferrule [S-StructChecked]
  {n > 0 \\ D(T) = fs \\ fs(f)=\tau_a \\ n_a=\mathtt{index}(fs,f)}
  {(\varphi,\heap,\eamper{\evalue{n}{\tptr{\tstruct{T}}{\cmode}}}{f}) \longrightarrow (\varphi,\heap,\evalue{n_a}{\tptr{\tau_a}{\cmode}})}

  \inferrule [S-StructNull]
  {n = 0}
  {(\varphi,\heap,\eamper{\evalue{n}{\tptr{\tstruct{T}}{\cmode}}}{f}) \longrightarrow (\varphi,\heap,\enull)}

  \inferrule [S-StructUnChecked]
  {D(T) = fs \\ fs(f)=\tau_a \\ n_a=\mathtt{index}(fs,f)}
  {(\varphi,\heap,\eamper{\evalue{n}{\tptr{\tstruct{T}}{\umode}}}{f}) \longrightarrow (\varphi,\heap,\evalue{n_a}{\tptr{\tau_a}{\umode}})}

\end{mathpar}
}
}
  \caption{\lang Struct Definitions}
  \label{fig:checkc-struct}
\end{figure}

\begin{figure}[t]
{\small
  \begin{mathpar}

    \inferrule[]
    {}
    {\Gamma \vdash n}

    \inferrule[]
    {x:\tint \in \Gamma}
    {\Gamma \vdash x + n}

    \inferrule[]
    {\Gamma \vdash b_l\\
    \Gamma \vdash b_h}
  {\Gamma \vdash (b_l,b_h)}

  \inferrule[]
  {}
  {\Gamma \vdash \tint}

  \inferrule[]
  {\Gamma \vdash \bvar \\
  \Gamma \vdash \tau}
  {\Gamma \vdash \tptr{\tallarrayb{\bvar}{\tau}}{m}}

  \inferrule[]
  {\Gamma \vdash \tau}
  {\Gamma \vdash \tptr{\tau}{m}}

  \inferrule[]
  {T \in D}
  {\Gamma \vdash \tptr{\tstruct{T}}{m}}
  \end{mathpar}
}
 \caption{Well-formedness for types and bounds}
\label{fig:wftypesandbounds}
\end{figure}





\begin{figure}[t]
{\small
  \begin{mathpar}
    \inferrule[]
    {\Gamma \vdash \overline{x}:\overline{\tau} \\
      \Gamma[\overline{x} \mapsto \overline{\tau}] \vdash \tau \\
    \Gamma[\overline{x} \mapsto \overline{\tau}]; \Theta  \vdash_{\cmode} e : \tau}
    {\Gamma \vdash \tau\;(\overline{x}:\overline{\tau})\;e}

    \inferrule[]
    {}
    {\Gamma \vdash \cdot}

    \inferrule[]
    {\Gamma \vdash \tau \\
    \Gamma[x \mapsto \tau] \vdash \overline{x}:\overline{\tau}}
    {\Gamma \vdash x:\tau, \overline{x}:\overline{\tau}}
  \end{mathpar}
}
 \caption{Well-formedness for functions}
\label{fig:wffunctions}
\end{figure}


\begin{figure}[t]
{\small
  \begin{mathpar}
    \inferrule[]
    {\Gamma \vdash \tau}
    {\Gamma \vdash \tau~\mathtt{f} }

    \inferrule[]
    {\Gamma \vdash \tau\\
     \Gamma \vdash fs}
    {\Gamma \vdash \tau~\mathtt{f}; fs }

  \end{mathpar}
}
 \caption{Well-formedness for structs}
\label{fig:wfstructs}

{\small
  \begin{mathpar}

    \inferrule[]
    {\Gamma[\overline{x} \mapsto \overline{\tau}]; \emptyset  \vdash
      e \gg \dot e : \tau}
    {\Gamma \vdash \tau\;(\overline{x}:\overline{\tau})\;e \gg
      (\overline{x})\;\dot e}
  \end{mathpar}
}
 \caption{Compilation rules for functions}
\label{fig:compilefunctions}
\end{figure}

\subsection{The Compilation Rules}\label{appx:comp1}
Fig.~\ref{fig:syntaxerased} and Fig.~\ref{fig:semanticserased} shows
the syntax for $\elang$, the target language for compilation. We syntactically
restrict the expressions to be in A-normal form \DIFdelbegin \DIFdel{because that is the
type of expression our compiler produces. }\DIFdelend \DIFaddbegin \DIFadd{to simplify the
presentation of the compilation rules. In the Redex model, we
occasionally break this constraint to speed up the performance of
random testing by removing unnecessary let bindings.
}\DIFaddend To allow explicit runtime
checks, we include $\ebounds$ and $\enull$ as part of $\elang$
expressions which, once evaluated, result in an corresponding error state. $\eassignstack{x}{\dot a}$ is a new syntactic form that
modifies the stack variable $x$ with the result of $\dot a$. It is
essential for bounds widening. $\leq$ and $-$ are introduced
to operate on bounds and decide whether we need to halt with a bounds error
or widen a null-terminated string.

\begin{figure}[h]
{\small
  \[\begin{array}{llcl}
      \text{Atoms}       & \dot a & ::= & n \mid x \\

      \text{C-Expressions} & \dot c & ::= & \dot a \mid \estrlen{\dot a}  \mid \emalloc {\dot  a}  \mid \ecall{f} {\overline{\dot a}}  \\
                         & & \mid &  \mid  \dot a \circ \dot a \mid \estar{\dot a} \\
                         & & \mid & \eassign{\dot a}{\dot a} \mid \eassignstack{x}{\dot a}  \mid \eif{\dot a}{\dot e}{\dot e} \\
                         & & \mid & \ebounds \mid \enull \\
      \text{Expressions}  & \dot e & ::= & \dot c \mid \elet{x}{\dot c}{\dot e}\\
      \text{Binops} & \circ & ::= & + \mid - \mid \leq  \\
      \text{Closure} & \dot C & ::= & \hole \mid \elet{x}{\dot a}{\dot C} \\
       & & \mid & \eif{\dot a}{\dot e}{\dot C} \mid \eif{\dot a}{\dot    C}{\dot e} \\
      \text{Bounds Map} & \rho & \in & \texttt{Var} \rightharpoonup \texttt{Var} \times \texttt{Var}
  \end{array}
  \]
}
  \caption{\elang{} Syntax}
  \label{fig:syntaxerased}
{\small
  \[\begin{array}{lll}
    \dot \mu & ::= & n \mid \bot \\
    \dot c & ::= & \ldots  \mid \eret{x}{\dot \mu}{\dot e} \\
    \dot H & \in & \mathbb{Z} \rightharpoonup \mathbb{Z} \\
    \dot r & ::= & \dot e \mid \enull \mid \ebounds \\
    \dot E & ::= & \hole \mid  \elet{x}{\dot E}{\dot e}  \mid \eret{x}{i}{\dot E} \\
             & \mid & \eif{\dot E}{\dot e}{\dot e} \mid \estrlen{\dot E} \\
             & \mid & \emalloc{\dot E} \mid \ecall{f}{\overline{\dot
                      E}} \mid \dot E \circ \dot a \mid n \circ \dot E \\
             & \mid & \estar{\dot E} \mid \eassign{\dot E}{\dot a}
                      \mid \eassign{n}{\dot E} \mid
                      \eassignstack{x}{\dot E} \\
      \overline{\dot E } & ::= & \dot E \mid n,\overline{\dot E} \mid
                                 \overline{\dot E}, \dot a

  \end{array} \]
}
  \caption{\elang Semantic Defs}
  \label{fig:semanticserased}
\end{figure}


$\elang$ does not include any annotations. We remove structs from
$\elang$ because we can always statically convert expressions of the form
$\eamper{n:\tau}{f}$ into $n + n_f$, where $n_f$ is the statically
determined offset of $f$ within the struct. We ellide the semantics of
$\elang$ because it is self-evident and mirrors the semantics
$\lang$. The difference is that in $\elang$, only $\ebounds$ and
$\enull$ can step into an error state. All failed dereferences and
assignments would result in a stuck state and therefore we rely on the
compiler to explicitly insert checks for checked pointers.


Fig.~\ref{fig:compilation} and Fig.~\ref{fig:compilation2}
 shows the rules for the compilation judgment for expressions,
\[\Gamma;\rho \vdash e \gg \dot C, \dot a\]
The judgment is presented differently from the one in
Sec.~\ref{sec:compilation}, which was simplified for presentation purposes. First,
we remove $\Theta$ and $m$ because these
parameters are only used for checking and have no
impact on compilation. Second, the judgment includes two
outputs, a closure $\dot C$ and an atom expression $\dot a$, instead of
a single $\elang$ expression $\dot e$. $\dot C$ can be intuitively understood as a
partially constructed program or context. Whereas $\dot E$ is used for
evaluation, $\dot C$
is used purely as a device for compilation. As an example,
when compiling $(1 : \tint) \plus (2 : \tint)$, 
we would first create a fresh variable $x$, and then produce two outputs:
\[    \dot C = \elet{x}{1 \plus 2}{\hole}\]
\[    \dot a = x\]
To obtain the compiled expression $\dot e$, we plug $\dot a$ into
$\dot C$ using the usual notation $\dot C[\dot a]$. We can also use $\dot C$ to represent runtime checks, which
usually take the form $\elet{x}{\dot c}{\hole}$, where $\dot c$
contains the check whose evaluation must not trigger $\ebounds$ or $\enull$ for the program to
continue (see Fig.~\ref{fig:compilationhelpers} for the metafunctions that create
those checks). 

This unconventional output format enables us to separate the
evaluation of the term and the computation that relies on the term's
evaluated result. Since effects and reduction (except for variables) happen only
within closures, we can precisely control the order in which effects
and evaluation happen by composing the contexts in a specific order.
Given two closures $\dot C_1$
and $\dot C_2$, we write $\dot C_1[\dot C_2]$ to denote the meta
operation of plugging $\dot C_2$ into $\dot C_1$. We also use
$\dot C_{a;b;c}$ as a shorthand for $\dot C_a[\dot C_b[\dot C_c]]$. In
the \textsc{C-Ind} rule,
we first evaluate the expressions that correspond to $e_1$ and $e_2$
through $\dot C_1$ and $\dot C_2$, and then perform a null check and
an addition through $\dot C_n$ and $\dot C_3$. Finally, we dereference
the result through $\dot C_4$ before returning the pair $\dot C_4,\dot
x_4$, propagating the flexibility to the compilation rule that recursively
calls \textsc{C-Ind}.

Fig.~\ref{fig:compilationhelpers} shows the metafunctions that create
closures representing dynamic checks. These functions first examine
whether the pointer is a checked. If the pointer is unchecked, an empty closure $\hole$
will be returned, because there is no need to perform a check. For bounds
checking, there is a special case for NT-array pointers, where the
bounds are retrived from the \DIFdelbegin \DIFdel{ghost }\DIFdelend \DIFaddbegin \DIFadd{\textcolor{purple}{ghost} }\DIFaddend variables (found by
looking up $\rho$) on the stack  rather than
using the bounds specified in the type annotation. This is how we
achieve the same precise runtime behavior as $\lang$ in our compiled expressions.


Fig.~\ref{fig:compilationhelpers2} shows the metafunctions related to
bounds widening. $\vdash_{extend}$ takes $\rho$,
a checked NT-array pointer variable $x$, and its bounds $(b_l,b_h)$ as inputs, and returns an
extended $\rho'$ that maps $x$ to two fresh variables $x_l$, $x_h$,
together with a closure $\dot C$ that initializes $x_l$ and $x_h$ to
$b_l$ and $b_h$ respectively. This function is used in the
\textsc{C-Let} rule to extend $\rho$ before compiling the body of the
$\elettext$ binding. The updated $\rho'$ can be used for generating
precise bounds checks, and for inserting expressions that can potentially
widen the upper bounds, as seen in the $\vdash_{widenstr}$
metafunction used in the \textsc{C-Str} compilation rule.

\begin{figure*}[t]
{\small
  \begin{mathpar}
    \inferrule[]
    { x_l, x_h = \fresh \\
      \rho' = \rho[x \mapsto (x_l, x_h)]\\
    \dot C = \elet{x_l}{b_l}{\elet{x_h}{b_h}{\hole}}}
  {\cextend{\rho}{x}{\tntarrayptr{b_l}{b_h}{\tau}{c}}{\dot C, \rho'}\\}


  \inferrule[]
  {x_l,x_h = \rho(x) \\
    x_w = \fresh \\
  \dot C = \elet{x_w}{\eif{x_h}{0}{\eassignstack{x_h}{1}}}{\hole}}
{\ewidenderef{\rho}{x}{\tptr{\tntarrayb{(b_l,b_h)}{\tau}}{c}}{\dot C}}


\inferrule[]
{e \notin dom(\rho)}
{\ewidenstrlen{\rho}{e}{\dot a}{\tptr{\tntarrayb{\bvar}{\tau}}{m}}{\hole}}

\inferrule[]
{x_l,x_h = \rho(e) \\
  x_a = \fresh \\
  \dot C = \elet{x_a}{\eif{\dot a \leq x_h}{0}{\eassignstack{x_h}{\dot a}}}{\hole}}
{\ewidenstrlen{\rho}{e}{\dot a}{\tptr{\tntarrayb{\bvar}{\tau}}{\cmode}}{\dot C}}



  \end{mathpar}

}
 \caption{Metafunctions for widening}
\label{fig:compilationhelpers2}
\end{figure*}



\begin{figure*}[h]
{\small
  \begin{mathpar}
    \inferrule[]
    {x = \fresh \\
      \dot C = \elet{x}{\eif{\dot a}{0}{\enull}}{\hole}}
    {\echecknull{\dot a}{c}{\dot C}}

    \inferrule[]
    {}
    {\echecknull{\dot a}{u}{\hole}} \\

    \inferrule[]
    {}
    {\echeckbounds{\rho}{e}{\tptr{\tallarrayb{\bvar}{\tau}}{u}}{\dot a}{\hole}} 

    \inferrule[]
    { x_l,x_h = \rho(e) \\
      x_{cl},x_{ch} = \fresh\\
      \dot C_{cl} = \elet{x_{cl}}{\eif{x_l \leq \dot a}{0}{\ebounds}}{\hole}\\
      \dot C_{ch} = \elet{x_{ch}}{\eif{\dot a \leq x_h}{0}{\ebounds}}{\hole}
    }
    {\echeckbounds{\rho}{e}{\tptr{\tallarrayb{\bvar}{\tau}}{c}}{\dot a}{\dot C_{cl;ch}}}

    \inferrule[]
    { e \notin dom(\rho) \\
      x_{l}, x_{h}, x_{cl},x_{ch} = \fresh\\
      \dot C_l = \elet{x_l}{b_l}{\hole}\\
      \dot C_h = \elet{x_h}{b_h}{\hole}  \\    
      \dot C_{cl} = \elet{x_{cl}}{\eif{x_l \leq \dot a}{0}{\ebounds}}{\hole}\\
      \dot C_{ch} = \elet{x_{ch}}{\eif{\dot a \leq x_h}{0}{\ebounds}}{\hole}
    }
    {\echeckbounds{\rho}{e}{\tntarrayptr{b_l}{b_h}{\tau}{c}}{\dot a}{\dot C_{l;h;cl;ch}}}

    \inferrule[]
    { e \notin dom(\rho) \\
      x_{l}, x_{h}, x_{cl},x_{ch} = \fresh\\
      \dot C_l = \elet{x_l}{b_l}{\hole}\\
      \dot C_h = \elet{x_h}{b_h}{\hole}  \\    
      \dot C_{cl} = \elet{x_{cl}}{\eif{x_l \leq \dot a}{0}{\ebounds}}{\hole}\\
      \dot C_{ch} = \elet{x_{ch}}{\eif{x_h \leq \dot a}{\ebounds}{0}}{\hole}
    }
    {\echeckbounds{\rho}{e}{\tarrayptr{b_l}{b_h}{\tau}{c}}{\dot a}{\dot C_{l;h;cl;ch}}}


    \inferrule[]
    {}
    {\echeckboundsw{\rho}{e}{\tptr{\tallarrayb{\bvar}{\tau}}{u}}{\dot a}{\hole}} 

    \inferrule[]
    { x_l,x_h = \rho(e) \\
      x_{cl},x_{ch} = \fresh\\
      \dot C_{cl} = \elet{x_{cl}}{\eif{x_l \leq \dot a}{0}{\ebounds}}{\hole}\\
      \dot C_{ch} = \elet{x_{ch}}{\eif{\dot a \leq x_h}{0}{\ebounds}}{\hole}
    }
    {\echeckboundsw{\rho}{e}{\tptr{\tallarrayb{\bvar}{\tau}}{c}}{\dot a}{\dot C_{cl;ch}}}


    \inferrule[]
    { e \notin dom(\rho) \\
      x_{l}, x_{h}, x_{cl},x_{ch} = \fresh\\
      \dot C_l = \elet{x_l}{b_l}{\hole}\\
      \dot C_h = \elet{x_h}{b_h}{\hole}  \\    
      \dot C_{cl} = \elet{x_{cl}}{\eif{x_l \leq \dot a}{0}{\ebounds}}{\hole}\\
      \dot C_{ch} = \elet{x_{ch}}{\eif{x_h \leq \dot a}{\ebounds}{0}}{\hole}
    }
    {\echeckboundsw{\rho}{e}{\tallarrayptr{b_l}{b_h}{\tau}{c}}{\dot a}{\dot C_{l;h;cl;ch}}}

\inferrule[]
{e \notin dom(\rho) \\
  x_l,x_l',x_h,x_h' = \fresh \\
  \dot C_1 = \elet{x_l}{b_l}{\elet{x_h}{b_h}{\hole}}\\
  \dot C_2 = \elet{x_l'}{b_l'}{\elet{x_h'}{b_h'}{\hole}}\\
  \dot C_3 = \eif{x_l' \leq x_l}{\hole}{\ebounds} \\
  \dot C_4 = \eif{x_h \leq x_h'}{\hole}{\ebounds}
}
{\echeckboundsdyn{\rho}{e}{\tptr{\tallarrayb{(b_l,b_h)}{\tau}}{m}}{\tptr{\tallarrayb{(b_l',b_h')}{\tau}}{m}}{\dot C_{1;2;3;4}}}

\inferrule[]
{x_l',x_h' =\rho(e) \\
  x_l,x_h = \fresh \\
  \dot C_1 = \elet{x_l}{b_l}{\elet{x_h}{b_h}{\hole}}\\
  \dot C_2 = \eif{x_l' \leq x_l}{\hole}{\ebounds} \\
  \dot C_3 = \eif{x_h \leq x_h'}{\hole}{\ebounds}
}
{\echeckboundsdyn{\rho}{e}{\tptr{\tallarrayb{(b_l,b_h)}{\tau}}{m}}{\tptr{\tallarrayb{(b_l',b_h')}{\tau}}{m}}{\dot C_{1;2;3}}}
  \end{mathpar}
}
\caption{Metafunctions for dynamic checks}
\label{fig:compilationhelpers}
\end{figure*}

















\begin{figure*}[t]
{\small
  \begin{mathpar}

    \inferrule[C-Const]
      {}
      {\Gamma;\rho\vdash \evalue{n}{\tau} \gg \hole, n : \tau}


    \inferrule[C-Var]
      {x : \tau \in \Gamma}
      {\Gamma;\rho \vdash x \gg \hole, x : \tau}

      
    \inferrule[C-Cast]
              {\Gamma;\rho \vdash e \gg  \dot C , \dot a : \tau'}
              {\Gamma;\rho \vdash \ecast{\tau}{e} \gg \dot C, \dot a  : \tau}

      \inferrule[C-DynCast]
      {\Gamma;\rho \vdash e \gg \dot C_1, \dot a : \tptr{\tallarrayb{\bvar'}{\tau}}{m} \\
      \echeckboundsdyn{\rho}{e}{\tptr{\tallarrayb{\bvar}{\tau}}{m}}{\tptr{\tallarrayb{\bvar'}{\tau}}{m}}{\dot C_{b}}}
      {\Gamma;\rho \vdash \edyncast{\tptr{\tallarrayb{\bvar}{\tau}}{m}}{e}
            \gg \dot C_{1;b}, \dot a : \tptr{\tallarrayb{\bvar}{\tau}}{m}}


      \inferrule[C-Str]
      {\Gamma; \rho \vdash e \gg \dot C_1, \dot a_1 :  \tptr{\tntarrayb{\bvar}{\tau_a}}{m} \\
        \echecknull{\dot a_1}{m}{\dot C_{n}} \\
        \echeckbounds{\rho}{\dot a_1}{\tptr{\tntarrayb{\bvar}{\tau_a}}{m}}{0}{\dot C_{b}} \\
        x_2 = \fresh \\
          \dot C_2 = \elet{x_2}{\estrlen{\dot a_1}}{\hole} \\
      \ewidenstrlen{\rho}{e}{\dot a_1}{\tptr{\tntarrayb{\bvar}{\tau_a}}{m}}{\dot C_{w}} } 
                {\Gamma;\rho \vdash \estrlen{e} \gg \dot C_{1;n;b;2;w}, x_2 : \tint}


      \inferrule[C-LetStr]
      {\Gamma(y) = \tntarrayptr{b_l}{b_h}{\tau_a}{\cmode} \\ x \not\in \fv(\tau) \\
        \Gamma; \rho \vdash \estrlen{y} \gg \dot C_1, \dot a_1 : \tint\\
        \dot C_2 = \elet{x}{\dot a_1}{\hole} \\
        \Gamma[x\mapsto \tint,y\mapsto [\tntarrayptr{b_l}{x}{\tau_a}{\cmode}]];\rho \vdash e_3 \gg \dot C_3, \dot a_3 : \tau}
{\Gamma;\rho \vdash \elet{x}{\estrlen{y}}{e} \gg \dot C_{1;2;3},\dot a_3 : \tau}


      \inferrule[C-If ]
      {\Gamma; \rho \vdash e \gg \dot C_1, \dot a_1 : \tau \\
        \Gamma; \rho \vdash e_1 \gg \dot C_2, \dot a_2 : \tau_2 \\
        \Gamma; \rho \vdash e_3 \gg \dot C_3, \dot a_3 : \tau_3 \\
        x_4 = \fresh \\
        \dot C_4 = \elet{x_4}{\eif{\dot a_1}{\dot C_2[\dot a_2]}{\dot C_3[\dot a_3]}}{\hole}
      }
        {\Gamma; \rho \vdash \eif{e_1}{e_2}{e_3} \gg \dot C\DIFdelbeginFL \DIFdelFL{_4}\DIFdelendFL \DIFaddbeginFL \DIFaddFL{_{1;4}}\DIFaddendFL , x_4 : \tau_2 \sqcup \tau_3}



        \inferrule[C-IfNT]
        {\Gamma; \rho \vdash x : \tptr{\tntarrayb{(b_l,b_h)}{\tau}}{c} \\
          b_h = 0 \Rightarrow \Gamma' = \Gamma[x \mapsto \tptr{\tntarrayb{(b_l,1)}{\tau}}{c}] \\
          b_h \neq 0 \Rightarrow \Gamma' = \Gamma \\
          \Gamma; \rho \vdash \estar{x} \gg \dot C_1, \dot a_1 : \tau_1\\
          \Gamma'; \rho \vdash e_2 \gg \dot C_2, \dot a_2 : \tau_2\\
          \Gamma;\rho \vdash e_3 \gg \dot C_3, \dot a_3 : \tau_3 \\
        \ewidenderef{\rho}{x}{\tptr{\tntarrayb{(b_l,b_h)}{\tau}}{c}}{\dot C_{w}} \\
        x_4 = \fresh \\
        \dot C_4 = \elet{x_4}{\eif{\dot a_1}{\dot C_{2;w}[\dot a_2]}{\dot C_3[\dot a_3]}}{\hole}}
        {\Gamma;\rho \vdash \eif{\estar{x}}{e_1}{e_2} \gg \DIFdelbeginFL \DIFdelFL{x_4, }\DIFdelendFL \dot C\DIFaddbeginFL \DIFaddFL{_{1;4}, x}\DIFaddendFL _4 : \tau_1 \sqcup \tau_2}

   \inferrule[C-Let]
    { (x\in \fv(\tau') \Rightarrow e_1 \in Bound) \\
        \Gamma;\rho \vdash e_1 \gg \dot C_1, \dot a_1 : \tau_1 \\ 
        \cextend{\rho}{x}{\tau_1}{\dot C_2,\rho'}\\
        \dot C_3 = \elet{x}{\dot a_1}{\hole}\\
        \Gamma[x\mapsto \tau];\rho' \vdash e_4 \gg \dot C_4, \dot a_4  : \tau_4}
    {\Gamma;\rho' \vdash \elet{x}{e_1}{e_4} \gg \dot C_{1;2;3;4},\dot a_4 : \tau_4[\tau_1 = \tint \Rightarrow x \mapsto e_1]}


  \inferrule[C-Ret]
    {\Gamma(x)\neq \bot \\
      \Gamma;\rho \vdash e \gg \dot C_1, \dot a_1 : \tau \\
      x_2 = \fresh \\
      \mu \gg \dot \mu \\
    \dot C_2 = \elet{x_2}{\eret{x}{\dot \mu}{\dot C_1[\dot a_1]}}{\hole}}
  {\Gamma;\rho \vdash \eret{x}{\mu}{e} \gg \dot C_2, x_2 : \tau}


    \inferrule[C-Fun]
    {\Xi(f) = \tau\;(\overline{x}:\overline{\tau})\;e \\
(\forall e_i\in\overline{e}\;\;\tau_i\in\overline{\tau}\;.\; \Gamma; \rho \vdash {e_i} \gg \dot C_i, \dot a_i  : \\ \tau_i' \wedge
      \tau_i' \sqsubseteq 
      \tau_i[\overline{e} / \overline{x}]) \\
      x_f = \fresh \\
      \dot C_f = \elet{x_f}{f(\overline{a})}{\hole}}
    {\Gamma; \rho \vdash f(\overline{e}) \gg \overline{\dot C}[\dot C_f] , x_f  : \tau[\overline{e} / \overline{x}]}


  \inferrule[C-Def]
  {\Gamma;\rho \vdash e_1 \gg \dot C_1, \dot a_1 : \tptr{\tau}{m} \\
    \echecknull{\dot a_1}{m}{\dot C_{n}}\\
    x_2 = \fresh \\
    \dot C_2 = \elet{x_2}{\estar{\dot a_1}}{\hole}
   }
   {\Gamma;\rho \vdash \estar{e_1} \gg \dot C_{1;n;2}, x_2 : \tau}

   \inferrule[C-DefArr]
   {\Gamma;\rho \vdash e_1 \gg \dot C_1, \dot a_1 : \tallarrayptr{b_l}{b_h}{\tau}{m} \\
    \echecknull{\dot a_1}{m}{\dot C_{n}}\\
    \echeckbounds{\rho}{e_1}{\tallarrayptr{b_l}{b_h}{\tau}{m}}{0}{\dot C_{b}}\\
    x_2 = \fresh \\
    \dot C_2 = \elet{x_2}{\estar{\dot a_1}}{\hole}}
   {\Gamma;\rho \vdash \estar{e_1} \gg \dot C_{1;n;b;2},x_2 : \tau} 


    \inferrule[C-Mac]
    {\dot C_{1}, \dot a_1 = \esizeof{\omega} \\
      x_2 = \fresh \\
    \dot C_2 = \elet{x_2}{\emalloc{\dot a_1}}{\hole}}
     {\Gamma; \rho \vdash \emalloc{\omega} \gg \dot C_{1;2}, x_2 : \tptr{\omega}{\cmode}}

  \end{mathpar}
}
\caption{Compilation}
\label{fig:compilation}
\end{figure*}


\begin{figure*}[t]
{\small
  \begin{mathpar}
    \inferrule[C-Add]
              {\Gamma; \rho \vdash e_1 \gg \dot C_1, \dot a_1 : \tint \\
                \Gamma; \rho \vdash e_2 \gg \dot C_2, \dot a_2 : \tint\\
                x_3 = \fresh \\
              \dot C_3 = \elet{x_3}{\dot a_1 \plus \dot a_2}{\hole}}
              {\Gamma; \rho \vdash \dot C_3, x_3 : \tint }

   \inferrule[C-Ind] 
              {\Gamma; \rho \vdash e_1 \gg \dot C_1, \dot a_1 : \tptr{\tallarrayb{\bvar}{\tau}}{m} \\
                \Gamma; \rho \vdash e_2 \gg \dot C_2, \dot a_2 : \tint \\
                \echecknull{\dot a_1}{m}{\dot C_{n}}\\
                \echeckbounds{\rho}{e_1}{\tptr{\tallarrayb{\bvar}{\tau}}{m}}{\dot a_2}{\dot C_{b}} \\
                x_3, x_4 = \fresh\\
                \dot C_3 = \elet{x_3}{\dot a_1 \plus \dot a_2}{\hole}\\
                \dot C_4 = \elet{x_4}{\estar{x_3}}{\hole}
                }
                {\Gamma; \rho \vdash \estar{(\ebinop{e_1}{e_2})} \gg \dot C_{1;2;n;3;b;4} , x_4: \tau}




  \inferrule[C-Assign]
  {\Gamma; \rho \vdash e_1 \gg \dot C_1, \dot a_1 : \tptr{\tau}{m'} \\
    \echecknull{\dot a_1}{m}{\dot C_{n}}\\
    \Gamma; \rho \vdash e_2 \gg \dot C_2, \dot a_2 : \tau' \\
    \tau'\sqsubseteq \tau \\
    x_3 = \fresh \\
    \dot C_3 = \elet{x_3}{\eassign{\dot a_1}{\dot a_2}}{\hole} \\
  }
  {\Gamma; \rho \vdash \eassign{e_1}{e_2} \gg \dot C_{1;2;n;3}, x_3 : \tau}



  \inferrule[C-AssignArr]
  {\Gamma; \rho \vdash e_1 \gg \dot C_1, \dot a_1 : \tptr{\tallarrayb{\bvar}{\tau}}{m'}\\
    \echecknull{\dot a_1}{m}{\dot C_{n}}\\
    \echeckboundsw{\rho}{e_1}{\tallarrayptr{b_l}{b_h}{\tau}{m}}{0}{\dot C_{b}}\\
    \Gamma; \rho \vdash e_2 \gg \dot C_2, \dot a_2 : \tau' \\
    x_3 = \fresh \\
    \dot C_3 = \elet{x_3}{\eassign{\dot a_1}{\dot a_2}}{\hole} \\
    \tau'\sqsubseteq \tau}
  {\Gamma; \rho \vdash \eassign{e_1}{e_2} \gg \dot C_{1;2;n;b;3},x_3 : \tau}




    \inferrule[C-IndAssign]
    {\Gamma; \rho \vdash e_1 \gg \dot C_1, \dot a_1 : \tptr{\tallarrayb{\bvar}{\tau}}{m} \\
      \Gamma; \rho \vdash e_2 \gg \dot C_2, \dot a_2 : \tint \\
      \echecknull{\dot a_1}{m}{\dot C_{n}}\\
      \echeckboundsw{\rho}{e_1}{\tptr{\tallarrayb{\bvar}{\tau}}{m}}{\dot a_2}{\dot C_{b}} \\
      \Gamma; \rho \vdash e_3 \gg \dot C_3, \dot a_3 : \tau' \\
      x_4, x_5 = \fresh \\
      \dot C_4 = \elet{x_4}{\dot a_1 \plus \dot a_2}{\hole}\\
      \dot C_5 = \elet{x_5}{\eassign{x_4}{x_3}{\hole}}
      \tau'\sqsubseteq \tau}
    {\Gamma; \rho \vdash \eassign{(e_1 \plus e_2)}{e_3} \gg \dot C_{1;2;n;3;4;b;5} : \tau}


    \inferrule [C-Struct]
    {\Gamma; \rho \vdash e_1 \gg \dot C_1, \dot a_1  :  {\tptr{\tstruct{T}}{m}} \\
      D(T) = \tau_0~f_0\ldots; \tau_j~f; ...  \\
      \echecknull{\dot a_1}{m}{\dot C_{n}}\\
      x_2 = \fresh\\
    \dot C_2 = \elet{x_2}{\dot a_1 \plus \dot j}{\hole}}
    {\Gamma; \rho \vdash \eamper{e_1}{f} \gg \dot C_2, x_2  : \tptr{\tau_f}{m}}

    \inferrule[C-Unchecked]
              {\Gamma;\rho \vdash e \gg \dot C, \dot a : \tau}
              {\Gamma;\rho \vdash \eunchecked{e} \gg \dot C, \dot a : \tau}

  \end{mathpar}







}
\caption{Compilation (continued)}
\label{fig:compilation2}
\end{figure*} 
\DIFaddbegin 



 \fi
\DIFaddend 

\end{document}
