\section{Background and Motivation}
This section presents the necessary background and motivation for our work.
%\section{Overview and Transcendence}\label{sec:overview}
%This section describes \checkedc{} and new features \systemname{} provides.

\subsection{Memory Safety}
This property ensures that all memory accesses a program makes to valid areas containing the program's data~\cite{payer2019software}.
Languages that guarantee (or do not) this property are called memory-safe (or memory-unsafe) languages.~\eg Java is a memory-safe language, whereas C/C++ is not.
There are two main classes of memory safety violations: spatial and temporal.
\emph{Spatial violations} occur when a program dereferences a pointer that points outside of the associated object.~\eg buffer overread, underread, array out-of-bounds access, null-ptr dereference, etc.
\emph{Temporal violations} occur when a program dereferences a pointer that points to an invalid object which was previously object.~\eg use-after-free, double-free, etc.

\subsection{Program Partioning}
\label{subsec:background:programpart}
Program partitioning~\cite{rul2009towards} is a well-known technique for dividing a program into multiple isolated parts or partitions.
There has been considerable work~\cite{tan2017principles, brumley2004privtrans, bittau2008wedge, lind2017glamdring, liu2017ptrsplit} in the area.
Most of these techniques are~\emph{data-centric}~\cite{lind2017glamdring, liu2017ptrsplit}, wherein program data drives the partitioning.
Specifically, given sensitive data in a program, all functions accessing sensitive data will be considered part of the trusted partition, and all other functions will be in the untrusted partition.
For instance, in the following code~\code{key} is marked as sensitive and functions that access it,~\ie{}~\code{initkey} and~\code{encrypt} are considered to be part of trusted parition and the other function,~\ie{}~\code{main} will be in the untrusted partition.
\begin{minted}[xleftmargin=25pt, mathescape, linenos, escapeinside=||, fontsize=\scriptsize{}]{c}
char __attribute__((annotate("sensitive"))) *key;

void initkey(int sz) {
 ...
 for (i=0; i<sz; i++) key[i]= ...;
}

void encrypt(char *ptxt, int sz) {
 ..
 for (i=0; i<sz; i++)
  ctxt[i]=ptxt[i] ^ key[i];
 ..
}

int main() {
 ..
 initkey(strlen(txt));
 encrypt(txt, strlen(txt));
 ... 
}
\end{minted}

As we can see, partitioning is achieved easily in the existing techniques by identifying which functions access sensitive data.
These partitions can be separated in various ways,~\eg{} as different processes communicating through~\ac{RPC}~\cite{nelson1981remote}, parent and child processes communicating through shared memory, etc.

The main novelty of existing techniques is using various program analysis and dynamic instrumentation methods to facilitate transparent communication between functions in trusted and untrusted partitions.
Because of their focus on inter-partition interactions, the existing techniques are specialized for the target isolation mechanism. For instance,~\ptrsplit{}~\cite{liu2017ptrsplit} technique assumes that partitions are hosted as separate processes and data is exchanged through marshaling,~\eg{} sending data pointed by~\code{ptxt} and~\code{sz} during calls to~\code{encrypt} (\ie line 18 in the above example) and synchronizing the data back to~\code{ctxt} on return.
Any other isolation mechanism or data exchange (\eg shared memory) cannot be supported as the partitioning technique is specialized for marshaling by using~\ac{PDG} and tracking bounds information.
Similarly,~\glamdring~\cite{lind2017glamdring} is specialized for partitioning using SGX-enclaves~\cite{costan2016intel}.

\subsection{Need for Selective Fault Isolation}
The existing partitioning techniques focus on sensitive data use-case -- where the main goal is to protect the integrity and confidentiality of the sensitive data.
Consequently, they try to achieve complete~\acf{SFI},~\ie all executions, data, or faults within a partition do not affect other partitions.
This extreme isolation incurs significant performance overhead (37\% - 163\%)~\cite{lind2017glamdring, liu2017ptrsplit}.
Some isolation mechanisms (\eg Intel SGX) may not be available on all systems.
Such extreme isolation may not be needed or heavyweight for practical security use cases.

As shown by the recent study from Microsoft~\cite{microsoftmemsafe}, 70\% of the vulnerabilities still occur due to spatial safety violations.
Several works~\cite{meng2021bran, du2019leopard, ding2022velvet, situ2021vulnerable} show that certain functions are more prone to have a certain class of vulnerabilities than others.
Moreover, certain vulnerabilities may be impossible to occur in a given function. For instance, a function that cannot invoke (directly or transitively) any heap operations (\eg{} malloc/free) cannot contain temporal violations,~\eg use-after-free.
Instead of complete isolation, we need~\emph{\acf{SeFI}} from a program partition.
Formally, we say that a partition is $\phi$-\ac{SeFI} if and only if any violation of the property $\phi$ is contained with the partition and does not affect other partition(s).
For instance,~\emph{spatial safety-\ac{SeFI}} from a partition provides isolation against spatial safety violations in the partition.

\subsection{\checkedc}
\label{subsec:checkedc}
\label{subsec:nosafetyagsintuncheckedcode}
Recently,~\citet{Elliott2018} and~\citet{li22checkedc} introduced and formalized \checkedc, an
open-source extension to C,
to ensure a programâ€™s spatial safety by introducing new pointer types,~\ie checked pointer types.
Which are represented as system-level memory words without ``fattening'' metadata~\cite{duck2016heap}, 
and ensuring backward compatibility,~\ie developers can use checked and
regular (unchecked or wild) pointers within the same program.

\noindent
\myparagraph{Checked Pointer Types}
\checkedc{} introduces three varieties of \emph{checked pointer}:
\begin{itemize}
\item \code{_Ptr<}$T$\code{>} ($\ptr$) types a pointer that is either null or
  points to a single object of type $T$.
\item \code{_Array_ptr<}$T$\code{>} ($\arr$) types a pointer that is either null
  or points to an array of $T$ objects. The array width is defined
  by a \emph{bounds} expression, discussed below.
\item \code{_NT_Array_ptr<}$T$\code{>} ($\ntarr$) is like
  \code{_Array_ptr<}$T$\code{>} except that the bounds expression
  defines the \emph{minimum} array width---additional objects may
  be available past the upper bound, up to a null terminator.
\end{itemize}
Both $\arr$ and $\ntarr$ pointers have an associated bounds which defines the
range of memory referenced by the pointer.
The three different ways to declare bounds and the corresponding memory range is:
\begin{footnotesize}
\begin{tabular}{ll}
\arrT{|$T$|} \inlinecode{p: count(|$n$|)}
  &
$[\inlinecode{p}, \inlinecode{p}+\inlinecode{sizeof}(T) \times n) $ \\
%$[\inlinecode{p}, )$ \\
\arrT{|$T$|} \inlinecode{p: byte_count(|$b$|)}

  &
    $[\code{p}, \code{p}+b)$ \\


\arrT{|$T$|} \inlinecode{p: bounds(|$x, y$|)}

  &
    $[x, y)    $\\  
\end{tabular}
\end{footnotesize}
The bounds can be declared for $\ntarr$ as well, but the memory range can extend further to the right,
until a~\code{NULL} terminator is reached (\ie \code{NULL} is not within the bounds).

\noindent
\myparagraph{Ensuring Spatial Memory Safety}
The \checkedc compiler instruments loads and stores of checked
pointers to confirm the pointer is non-null, and additionally the access to $\arr$ and $\ntarr$ pointers is within
their specified bounds.
For example, in the code \inlinecode{if (n>0) a[n-1] =} $...$ the write
is via address $\alpha = \inlinecode{a + sizeof(int)}\!\times\!\code{(n-1)}$. 
If the bounds of \code{a} are \code{count(u)}, the
inserted check confirms
$\inlinecode{a} \leq \alpha < \inlinecode{a + sizeof(int)} \!\times\!
\inlinecode{u}$ prior to dereference.
Failed checks throw an exception.
Oftentimes, inserted checks can be optimized away by LLVM resulting in almost no runtime overhead~\cite{duanrefactoring}.

\myparagraph{Backward Compatibility}
\checkedc is backward compatible with legacy C as all legacy code will type-check and compile.
However, the compiler adds the aforementioned spatial safety checks to only checked pointers.
The spatial safety guarantee is partial when the code is not fully ported.
%Specifically, only code that appears in~\emph{checked code regions}, is guaranteed to be spatially safe.

\myparagraph{No Safety Against Unchecked Pointers}
A partially annotated program can still enjoy spatial safety only if checked pointers do not communicate with any unchecked ones. For instance, in the example below, there are no spatial safety violations in the function~\code{func} as it uses only checked pointers.
However, the other unconverted code regions (or unsafe regions) can affect pointers in safe regions and violate certain assumptions leading to vulnerabilities, as demonstrated by cross-language attacks~\cite{mergendahlcross}.

Although the blameless proof exists~\cite{ruef2019achieving, li22checkedc} for~\checkedc, it does not state that spatial safety violations cannot happen in checked regions but rather states that checked regions~\emph{cannot be blamed for any spatial safety violations}.
Consider the following example:
\begin{minted}[xleftmargin=25pt, mathescape, linenos, escapeinside=||, fontsize=\scriptsize{}]{c}
// code with checked c annotations
int func(array_ptr<char> p : count(5)) {
|\textcolor{red}{\faChainBroken}|..p[4]..
}
// unchecked (wild) code
...
str = "he";
...
func(|\textcolor{red}{\faBug}|assume_bounds_cast<char>(str, 5)); 
\end{minted}
Here, the checked function~\inlinecode{func} expects a pointer to a buffer of five elements, but the unchecked region code invokes the function (Line 9) with a buffer of 2 elements.
This results in a spatial safety violation (\textcolor{red}{\faChainBroken}) in the checked function, but of course, the blame or the root cause is in the unchecked function (\textcolor{red}{\faBug}).
Furthermore, since checked and unchecked functions execute in the same address space, spatial memory corruptions (\eg buffer overflow) in unchecked functions (or regions) can take down the complete program despite
having checked regions.
We need~\emph{an isolation mechanism to ensure that code executed as part of unchecked functions does not violate the safety guarantees in checked functions}.


% SFI: mechanisms and its use cases.

% Checked C

% Motivation: vulnerabilities.

\iffalse
\subsection{\checkedc}
\label{subsec:checkedc}
% 
\checkedc{} development began in 2015 by Microsoft Research, but it was forked
in late 2021 and is now actively managed by the Secure Software
Development Project (SSDP). Details can be found in a prior
overview~\cite{Elliott2018} and the formalism~\cite{li22checkedc}.

\noindent
\myparagraph{Checked Pointer Types}
\checkedc{} introduces three varieties of \emph{checked pointer}:
\begin{itemize}
\item \code{_Ptr<}$T$\code{>} ($\ptr$) types a pointer that is either null or
  points to a single object of type $T$.
\item \code{_Array_ptr<}$T$\code{>} ($\arr$) types a pointer that is either null
  or points to an array of $T$ objects. The array width is defined
  by a \emph{bounds} expression, discussed below.
\item \code{_NT_Array_ptr<}$T$\code{>} ($\ntarr$) is like
  \code{_Array_ptr<}$T$\code{>} except that the bounds expression
  defines the \emph{minimum} array width---additional objects may
  be available past the upper bound, up to a null terminator.
\end{itemize}
Both $\arr$ and $\ntarr$ pointers have an associated bounds which defines the
range of memory referenced by the pointer.
The three different ways to declare bounds and the corresponding memory range is:
\begin{footnotesize}
\begin{tabular}{ll}
\arrT{|$T$|} \inlinecode{p: count(|$n$|)}
  &
$[\inlinecode{p}, \inlinecode{p}+\inlinecode{sizeof}(T) \times n) $ \\
%$[\inlinecode{p}, )$ \\
\arrT{|$T$|} \inlinecode{p: byte_count(|$b$|)}

  &
    $[\code{p}, \code{p}+b)$ \\


\arrT{|$T$|} \inlinecode{p: bounds(|$x, y$|)}

  &
    $[x, y)    $\\  
\end{tabular}
\end{footnotesize}
The bounds can be declared for $\ntarr$ as well, but the memory range can extend further to the right,
until a~\code{NULL} terminator is reached (\ie \code{NULL} is not within the bounds).

\noindent
\myparagraph{Ensuring Spatial Memory Safety}
The \checkedc compiler instruments loads and stores of checked
pointers to confirm the pointer is non-null, and additionally the access to $\arr$ and $\ntarr$ pointers is within
their specified bounds.
For example, in the code \inlinecode{if (n>0) a[n-1] =} $...$ the write
is via address $\alpha = \inlinecode{a + sizeof(int)}\!\times\!\code{(n-1)}$. 
If the bounds of \code{a} are \code{count(u)}, the
inserted check confirms
$\inlinecode{a} \leq \alpha < \inlinecode{a + sizeof(int)} \!\times\!
\inlinecode{u}$ prior to dereference.
Failed checks throw an exception.
Oftentimes, inserted checks can be optimized away by LLVM resulting in almost no runtime overhead~\cite{duanrefactoring}.

%\liyi{why we need the following? I suggest we can cut. }
%Oftentimes, inserted checks can be optimized away by LLVM~\cite{duanrefactoring}.
%For instance, Dual~\etal~\cite{duanrefactoring} found essentially no
%overhead when running Checked C-converted portions of the FreeBSD kernel.
%Consider the above code to be enclosed in another condition, such as,~\inlinecode{if (n<u) if (n>0) a[n-1] =}.
%In such cases, the inserted check can be
%removed as the outer condition $\inlinecode{n<u}$ already ensures that the
%dereference is within bounds.
%Dual~\etal~\cite{duanrefactoring} found essentially no
%overhead when running Checked C-converted portions of the FreeBSD kernel.

\noindent
\myparagraph{Backward Compatibility}
\checkedc is backward compatible with legacy C as all legacy code will type-check and compile.
However, the compiler adds the aforementioned spatial safety checks to only checked pointers.
The spatial safety guarantee is partial when the code is not fully ported.
Specifically, only code that appears in \emph{checked
  code regions} (\cregion), is guaranteed to be spatially safe.
$\cmode$ regions can be designated at the level of files, functions, or individual code blocks using the
\code{checked} keyword.\footnote{You can also designate~\emph{unchecked} regions (\ucregion) within checked ones.}
 Within $\cmode$ regions, both legacy pointers and
certain unsafe idioms (\eg \emph{variadic} function calls) are disallowed.

\myparagraph{Converting C to \checkedc}
It is not possible to fully automate the conversion of C code to~\checkedc due to the requirement for semantic reasoning and other modifications such as refactoring.
We provide more details on this in~\apdx{app:convertctocc}.

%%
%The safety guarantees of Checked C come with certain restrictions. For instance,
%as shown below, Checked C programs cannot use address-taken variables in a
%bounds expression as the bounds relations may not hold because of possible
%modifications through pointers.
%% 
%\begin{minted}[xleftmargin=30pt, mathescape, escapeinside=||, fontsize=\footnotesize]{c}
%...
%_Array_ptr<int> p : count (n) = NULL;
%|\textcolor{red}{\faTimes}|..,&n,.
%\end{minted}
%% 
%Consequently, converting existing C programs to Checked C might require
%refactoring,~\eg eliminate~\inlinecode{&n} from the program above without
%changing its functionality.
%% 
%This might require considerable effort~\cite{duanrefactoring} depending on the
%program's complexity.
%% 
%Recently, Machiry~\etal developed~\threec~\cite{machiry2022c} that tries to
%automatically convert a program to Checked C by adding appropriate pointer
%annotations.
%However, as described in \threec, completely automated conversion
%is \emph{infeasible}, and it requires the developer to convert some code regions
%manually.  

\subsection{No Safety Against $\umode$ Regions}
\label{subsec:nosafetyagsintuncheckedcode}
\checkedc provides spatial safety guarantees for completely converted programs,~\ie programs that uses~\emph{only} checked types and no regular pointer types.
A partially annotated program can still enjoy spatial safety only if checked pointers do not communicate with any unchecked ones. For instance, in the example below, there are no spatial safety violations in the function~\code{func} as it uses only checked pointers.
However, the other unconverted code regions (or unsafe regions) can affect pointers in safe regions and violate certain assumptions leading to vulnerabilities, as demonstrated by cross-language attacks~\cite{mergendahlcross}.

%The backward compatibility of~\checkedc helps a partially annotated program to enjoy spatial memory safety on those regions using only Checked pointers (\ie checked or safe regions).
%But, these unconverted code regions (or unsafe regions) can affect pointers in safe regions and violate certain assumptions leading to vulnerabilities, as demonstrated by cross-language attacks~\cite{mergendahlcross}. \lc{I'm confused, does the partially checked program "enjoy spatial memory safety" or not?}
Although the blameless proof exists~\cite{ruef2019achieving, li22checkedc} for~\checkedc, it does not state that spatial safety violations cannot happen in $\cmode$ regions but rather states that $\cmode$ regions~\emph{cannot be blamed for any spatial safety violations}.
Consider the following example:
\begin{minted}[xleftmargin=25pt, mathescape, linenos, escapeinside=||, fontsize=\footnotesize{}]{c}
// c region code
int func(array_ptr<char> p : count(5)) {
|\textcolor{red}{\faChainBroken}|..p[4]..
}
// u region code
...
str = "he";
...
func(|\textcolor{red}{\faBug}|assume_bounds_cast<char>(str, 5)); 
\end{minted}
Here, the $\cmode$ region function~\inlinecode{func} expects a pointer to a buffer of five elements, but the $\umode$ region code
invokes the function (Line 9) with a buffer of 2 elements.
This results in a spatial safety violation (\textcolor{red}{\faChainBroken}) in the $\cmode$ region, but of course, the blame or the root cause is in the $\umode$ region (\textcolor{red}{\faBug}).
Furthermore, since $\cmode$ and $\umode$ regions execute in the same address space, spatial memory corruptions (\eg buffer overflow) in $\umode$ regions can take down the complete program despite having $\cmode$ regions.
We need~\emph{an isolation mechanism to ensure that code executed as part of $\umode$  regions does not violate the safety guarantees in $\cmode$ regions}.

\subsection{Program Partitioning}
\label{subsec:background:programpart}
Program partitioning~\cite{rul2009towards} is a well-known technique to divide a program into multiple isolated parts or partitions.
There has been considerable work~\cite{tan2017principles, brumley2004privtrans, bittau2008wedge, lind2017glamdring, liu2017ptrsplit} in the area.
Most of these techniques are~\emph{data-centric}~\cite{lind2017glamdring, liu2017ptrsplit}, wherein program data drives the partitioning.
Specifically, given sensitive data in a program, the goal is to partition functions into two parts or partitions based on whether a function can access the sensitive data.
The performance overhead of these approaches is dominated by marshaling costs and depends on the usage of sensitive data.
The overhead of state-of-the-art approaches, such as Glamdring~\cite{lind2017glamdring} and  PtrSplit~
\cite{liu2017ptrsplit}, is prohibitive and varies from 37\%-163\%.
\fi
\iffalse

\subsection{Ensuring Memory Safety}


%A bounds expression used with the latter two pointer types has three
%forms:
%\begin{itemize}
%\item \code{count(}$e$\code{)} where $e$ defines the array's
%  length. Thus, if pointer $p$ has bounds \code{count(n)} then the
%  accessible memory is in the range $[p,p+$\code{n}$]$. Bounds
%  expression $e$ must be side-effect free and may only refer to
%  variables whose addresses are not taken, or adjacent \code{struct}
%  fields.
%\item \code{byte_count(}$e$\code{)} is like \code{count}, but
%  expresses arithmetic using bytes, no objects; i.e.,
%  \code{count(}$e$\code{)} used for \code{array_ptr<}$T$\code{>} is
%  equivalent to \code{byte_count(}$e\times\texttt{sizeof}(T)$\code{)}
%\item \code{bounds(}$e_l$,$e_h$\code{)} where $e_l$ and $e_h$ are
%  pointers that bound the accessible region $[e_l,e_h)$ (the
%  expressions are similarly restricted). Bounds
%  \code{count(}$e$\code{)} is shorthand for
%  \code{bounds(}$p, p + e$\code{)}. This most general form of bounds
%  expression is useful for supporting pointer arithmetic.
%\end{itemize}
%
%\begin{footnotesize}
%\begin{tabular}{ll}
%\arrT{|$T$|} \inlinecode{p: count(|$n$|)}
%  &
%$[\inlinecode{p}, \inlinecode{p}+\inlinecode{sizeof}(T) \times n) $ \\
%%$[\inlinecode{p}, )$ \\
%\arrT{|$T$|} \inlinecode{p: byte_count(|$b$|)}
%
%  &
%    $[\code{p}, \code{p}+b)$ \\
%
%
%\arrT{|$T$|} \inlinecode{p: bounds(|$x, y$|)}
%
%  &
%    $[x, y)    $\\  
%\end{tabular}
%\end{footnotesize}
%
%  Dropping the bounds expression on an \code{nt_array_ptr} is equivalent
%  to the bounds being \code{count(0)}.

The \checkedc compiler will instrument loads and stores of checked
pointers to confirm the pointer is non-null, and the access is within
the specified bounds. For pointers $p$ of type
\code{nt_array_ptr<}$T$\code{>}, such a check could spuriously fail if
the index is past $p$'s specified upper bound, but before the null
terminator. To address this problem, Checked C supports \emph{bounds
  widening}.
If $p$'s bounds expression is \code{bounds}$(e_l$,$e_h)$ a program may read from (but not
write to) $e_h$; when the compiler notices that a non-null character
is read at the upper bound, it will extend that bound to $e_h+1$.
% pp\liyi{solved: II.B.: LaTeX issue, your inline monospaced code snippets generate a space on
%   the following line (i.e. "a program may read from (but not write to)" is not
%   aligned with the left boundary of the paragraph).}

\myparagraph{Spatial Safety and Backward Compatibility}
%
\checkedc is backward compatible with legacy C in the sense that all legacy code
will type-check and compile. However, only code that appears in \emph{checked
  code regions}, which we call \emph{checked code}, is spatially safe. Checked
regions can be designated at the level of files, functions, or individual code
blocks, the first with a \code{#pragma} and the latter two using the
\code{checked} keyword.\footnote{You can also designate \emph{unchecked} regions
  within checked ones.}  Within checked regions, both legacy pointers and
certain unsafe idioms (e.g., \emph{variadic} function calls) are disallowed. The
code in Fig.~\ref{fig:checkedc-example} satisfies these conditions and will
type-check in a checked region.

How should we approach code that has both checked and legacy components?
\citet{li22checkedc} proved, for a simple formalization of \checkedc, that
\emph{checked code cannot be blamed}: Any spatial safety violation is caused by
the execution of unchecked code.
%
\mz{You might want to add that spatial safety violation is still there with the
  amalgamation of both checked and unchecked code which gave rise to the
  motivation of \systemname.
}
% 
% 

\myparagraph{Converting C to \checkedc}
%
The safety guarantees of Checked C come with certain restrictions. For instance,
as shown below, Checked C programs cannot use address-taken variables in a
bounds expression as the bounds relations may not hold because of possible
modifications through pointers.
% 
\begin{minted}[xleftmargin=30pt, mathescape, escapeinside=||, fontsize=\footnotesize]{c}
...
_Array_ptr<int> p : count (n) = NULL;
|\textcolor{red}{\faTimes}|..,&n,.
\end{minted}
% 
Consequently, converting existing C programs to Checked C might require
refactoring, e.g., eliminate~\inlinecode{&n} from the program above without
changing its functionality.
% 
This might require considerable effort~\cite{duanrefactoring} depending on the
program's complexity.
% 
Recently, Machiry et al. developed~\threec~\cite{machiry2022c} that tries to
automatically convert a program to Checked C by adding appropriate pointer
annotations.  However, as described in \threec, completely automated conversion
is \emph{infeasible}, and it requires the developer to convert some code regions
manually.  
% 
Although the backward compatibility of Checked C helps a partially annotated
program to enjoy spatial memory safety on those regions using only Checked
pointers (i.e., checked, or safe regions), \mz{then what?}.

\begin{figure}[t]
{\small
  \begin{lstlisting}[xleftmargin=4 mm]
//in checked region

int compare_1(nt_array_ptr<char> x: count (0),
  nt_array_ptr<char> y : count (0)) { 
  int len_x = strlen(x);
  int len_y = strlen(y);
  return sum(x,len_x) < sum(y,len_y);
  }
...

int stringsort(
 nt_array_ptr<nt_array_ptr<char>> s : count (n),
 ptr<(int)(nt_array_ptr<char>,
  nt_array_ptr<char>)> cmp, int n) {
  int i, j, gap;
  int didswap;
 
  for(gap = n / 2; gap > 0; gap /= 2) {
    {
    do  {
        didswap = 0;
        for(i = 0; i < n - gap; i++)
           {
             j = i + gap;
             if((*cmp)(s[i], s[j]) > 0)
             {
                int len = strlen(s[i]);
                nt_array_ptr<char> 
                  tmp : count (len) = s[i];
                s[i] = s[j];
                s[j] = tmp;
                didswap = 1;
             }
           }
        } while(didswap);
    }
  }

  return 0;
}
  \end{lstlisting}
}
\caption{Checked stringsort Code}
\label{fig:checkedc-example-1}
\end{figure}

\begin{figure}[t]
{\small
  \begin{lstlisting}[xleftmargin=4 mm]
//in checked region, tainted version
int tainted_compare_1(
  nt_array_tptr<char> x : count (0),
  nt_array_tptr<char> y : count (0)) {
 checked (x,y) {
  int len_x = strlen(x);
  int len_y = strlen(y);
  nt_array_ptr<char> tx : count (len_x)
   = malloc(nt_array<char>, len_x);
  nt_array_ptr<char> ty : count (len_y)
   = malloc(nt_array<char>, len_y);
  safe_memcpy(tx,x,len_x);
  safe_memcpy(ty,y,len_y);
  return compare_1(tx,ty);
 }
}
...

//calling the function turns
//an unchecked region to a checked region.
int tainted_stringsort(nt_array_tptr
     <nt_array_tptr<char>> s : count (n),
 tptr<(int)(nt_array_tptr<char>,
  nt_array_tptr<char>)> cmp, int n) {
 checked (s,cmp,n) {
  int i;
  nt_array_ptr<nt_array_ptr<char>> p : count (n)
    = malloc(nt_array<nt_array_ptr<char>>, n);
  for(i = 0; i < n; i++) {
    int len = strlen s[i];
    nt_array_ptr<char> tmp : count (len)
      = new malloc(nt_array<char>, len);
    safe_memcpy(tmp,s[i],len);
    p[i] = tmp;
  }
  ptr<(int)(nt_array_ptr<char> : count (0),
  nt_array_ptr<char> : count (0))>
    cfun = find_check(cmp);
  
  return stringsort(p,cfun);
 }
}
  \end{lstlisting}
}
\caption{Tainted stringsort Code}
\label{fig:checkedc-example-2}
\end{figure}

\begin{figure}[t]
{\small
  \begin{lstlisting}[xleftmargin=4 mm]
//in unchecked region
int f(char ** s, int (*cmp)(char *,char *),
  int (*sort)(char **, int (*)(char *,char *),
               int), int n) {
...

  int i = sort(s,cmp,n);
  free(s[10]);
...
}

int g(int (*cmp)(char *,char *)) {
...
  int real_addr = derandomize(cmp);
...
}

int main(int n) {
  nt_array_ptr<nt_array_ptr<char>> p : count(n)
    = malloc(nt_array<nt_array_ptr<char>>, n);

  nt_array_tptr<nt_array_tptr<char>>
     tp : count(n) =
       tmalloc(nt_array<nt_array_tptr<char>>, n);
...
  safe_memcpy(tp, p, n);

  unchecked {
    if (BAD) // a flag to call different funs.
      //input checked pointers
      f(p, compare_1, stringsort); 
    else 
      //input tainted pointers
      f(tp, tainted_compare_1, tainted_stringsort);
  }

  if (!BAD) safe_memcpy(p, tp, n);
  p[10] = "crash?";
  
  unchecked {
    if (BAD) g(compare_1)
      else g(tainted_compare_1);
  }

  return 0;
}
  \end{lstlisting}
}
\caption{Tainted Pointer Usage in Calling Unchecked Fun}
\label{fig:checkedc-example-3}
\end{figure}

\subsection{\systemname Transcendence}

Here, we discuss three key new features in \systemname with examples.

\myparagraph{Maintaining Non-crashing}
Previously, the main guarantee of \checkedc \cite{li22checkedc} was the blame theorem.
The sources of crashing in \checkedc{} are (1) \mzr{crashes in unchecked regions}
and (2) the misuse of checked pointers in unchecked regions.
% 
For example, at \Cref{fig:checkedc-example-3} line 31, we passed a checked
null-terminated array (NT-array) pointer into an unchecked function \code{f}.
% 
At line 8, depending on the NT-array size, \code{free(s[10])} might crash.
% 
\mzu{Even if it does not crash, line 38 is doomed because of the \code{free} call.}
% 
\mz{                            %
  % 
  That's not true:
  %
  Line 38 assigns the address of a constant char array to \code{p[10]} which
  could be valid since \code{p} is not yet freed.
  % 
}
%
\mz{I changed a lot in this paragraph. Please compare with the previous commit.}
% 
Enlightened by program partitioning mechanism, \mzr{we address the crashes
  caused by spatial safety violation by sandboxing} the unchecked code regions
and utilize the \checkedc{} type system to rule out checked pointers from any
unchecked regions.
%
\mzr{ % 
  % 
  Besides, we incorporate a new form of pointer, \emph{tainted pointer}, into
  our existing \checkedc{} system to allow the interaction between checked and
  unchecked code regions.
  %
  A tainted pointer can be used in both checked and unchecked region; but it can
  only point to \emph{unchecked} heap memory so that the integrity of checked
  region would not be compromised by writes issued by unchecked code.
  %
  Hence to pass a piece of data from a checked region to an unchecked one using
  a tainted pointer, instead of exposing the address directly, the user would
  need to copy it from checked region to the unchecked heap and create a tainted
  pointer to refer to the copy.
% 
}
% 
For example, we copy the checked pointer data to the tainted pointer \code{tp}
at \Cref{fig:checkedc-example-3} line 26,
and input the tainted pointer to the unchecked function at line 34.
At line 8, even if statement might crash, since tainted pointers are stored
in the sandboxed heap, it can be recovered.
\mzu{
  % 
  At line 37, the use of a tainted pointer in a checked region
  requires a verification on it.
  % 
  This is managed by inserting additional checks
  and creating exception handling before the use by the \systemname compiler.
  % 
}
\mz{
  Might as well state separately that dynamic checks are instructmented upon
  dereferncing a tainted pointer in checked region.  
}
% 
Thus, the checked pointer \code{p} is safely used at line 38.
% 

% 
%\mz{The example itself is a bit confusing.
  %
%  There are a few simplifications can be made here:
  % 
%  (1) introduce a macro: \code{#define nt_ptr nt_array_ptr} to make the example
%  less verbose;
  % 
%  (2) split untangle BAD and GOOD code into 2 fragments, listed side-by-side.
  %
%  (3) use more descriptive function name instead of \code{f}, \code{g}
%}
% 

% 
In \systemname{}, we prove the non-crashing theorem: any well-typed
\systemname{} program program can \emph{never crash} due to spatial safety
violations, \mzr{i.e., spatial safety violation can be caught at runtime.}
% 

%
\mz{``catching a SSV at runtime'' may sound more appealing and more of
  an application?
  %
  Assume audience here are still general; they could prefer more application
  over high-level ideas?
}
% 

% 
\myparagraph{\mzs{Formalism}\mzr{Formalizing} Function Pointers}
% 
In C, manipulating function pointers is a major way of implementing high order
functions as well as accessing data stored in structs.  In previous works,
\checkedc{} assumed all function calls are called by name to a global map.
\mz{Global map can be confusing.}
% 
In \systemname{}, we \mzr{extend the existing formalism with} \mzs{formalize}
function pointers and prove that the type soundness \systemname{} is preserved.
% 

%
\mz{I'm trying to make it simpler. Let's rename \code{compare_1} to
  \code{cmp_sum}. I assume the minumun knowledge of C for readers so that they
  know sum of string is by the ASCII encoding. }
% 
\Cref{fig:checkedc-example-1} defines a string sorting algorithm depending on
the input function pointer \code{cmp} \mzr{as a string comparator}
\mzs{that provides the generic order for strings}; and,
\mzr{                           %
  %
  \code{cmp_sum} is an example of \code{cmp} function that compares strings by
  the sum of all characters in each of them.
  % 
} %
\mzs{                           %
  % 
  \code{compare_1} is an example \code{cmp} function that adds the
  ASCII numbers of characters in the two strings and compare the results.
  % 
} %
%

% 
In addition, function pointers enable the callback mechanism, i.e., a server
sends a function pointer to a client in an unchecked region, and allows the
client to access some server resources by calling back the pointer \mzr{on
  demand}.  This is a common usage between a web-browser and untrusted
third-party libraries.  The function call in \Cref{fig:checkedc-example-3} line
34 is one such usage.
% 
\mz{It sounds good.
  % 
  But, we might as well avoid using server/client here.
  % 
  They could potentially divert our motivation from memory-oriented to a network
  related one or even sync-vs-async discussion.
  %
}
% 


%
\mzr{                           %
  % 
  Simply adding function pointer type into the existing is not enough.
  % 
  Continuing with the example in \Cref{fig:checkedc-example-1}, we could notice
  that the type of the argument \code{cmp} in \code{stringsort} is not exactly
  the same with the signature of \code{cmp_sum}: \code{cmp} has type
  \code{ptr<(int)(nt_array_ptr<char>, nt_array_ptr<char>)>} which takes two
  NT-array pointers with arbitrary size and outputs an integer, but
  \code{cmp_sum} \ldots \uline{ (Wait, what's the exact difference?) We may need to
    make it clear here}.
  %
  To make function pointers usable, we also define a subtyping relation in
  \systemname{} that permits function pointer subsumption.
  %
  In this example, the type of \code{cmp_sum} is automatically casted to the
  type of \code{cmp}. 
  % 
  In general, if function pointer $x$
  has type $* (tl \to t)$, and $y$ has $* (tl' \to t')$, in order to use $x$ as
  $y$, $tl'$ should be a subtype of $tl$ and $t$ subtypes to $t'$.
}
% 

% 
\mzs{
  % 
  We also utilize \systemname{} subtyping relation to permit function pointer
  static auto-casting.  Function pointer type information might contain array
  pointer bound information, for which it is inconvenient to coincide the
  defined types for a function implementation and the function pointer type.
  For example, the \code{cmp} argument in \code{stringsort}}
% 
(\Cref{fig:checkedc-example-1})
% 
\mzs{
  % 
  has type
  \code{ptr<(int)(nt_array_ptr<char>, nt_array_ptr<char>)>}, meaning that the
  function takes two NT-array pointers with arbitrary size and outputs an
  integer.  The function pointer to {\code{compare_1}} has type
  \code{ptr<(int)(nt_array_ptr<char> : count (0), nt_array_ptr<char> : count (0)
    )>.}
  % 
}
% 
\mzs{                           %
  To use {\code{compare_1}} in \code{stringsort}, the
  type is auto-cast to the \code{cmp}'s type.  In general, if function pointer $x$
  has type $* (tl \to t)$, and $y$ has $* (tl' \to t')$, in order to use $x$ as
  $y$, $tl'$ should be a subtype of $tl$ and $t$ subtypes to $t'$.
  % 
}
  % 
% 
\mz{This could make the subtyping sound more natural.}
% 

% 
\myparagraph{Not Exposing Checked Pointer Addresses}
% 
The non-crashing guarantee in \systemname{} bans the checked pointer
manipulation in unchecked code regions. \mzu{Thus, there is no reason to permit
checked pointer variable assignments in unchecked regions; especially, this
might expose a checked pointer address to untrusted parties.}  For example, the
call to function $g$ at \Cref{fig:checkedc-example-3} line 41 lives in an
unchecked region, and $g$ might use some mechanisms, such as derandomizing ASLR
\cite{shacham-aslr}, to achieve the checked pointer address.  Thus, it enables a
third party to access any checked heap and function data by simple pointer
arithmetic.
% 
\mz{
  Is it rather a consequence of forbidding checked pointer manipulation?
}
% 

% 
We prevent any unchecked regions from acknowledging checked pointer variables to
avoid the checked pointer address leak.  In addition, to facilitate checked
function callbacks, the \systemname{} compiler compiles every checked function
with an additional tainted shell function.  Users are required to serve
unchecked regions with the tainted shell pointer instead of the original checked
function pointer.  For example, \code{tainted_compare_1} and
\code{tainted_stringsort} in \Cref{fig:checkedc-example-2} are the tainted
shells of the checked functions \code{compare_1} and \code{stringsort},
respectively.  In the tainted shells, \mzr{the parameter types} \mzs{arguments}
are the tainted \mzr{counterparts of} \mzs{versions of the
  corresponding arguments in} the \mzr{original} checked functions.
% 
Inside the shell body, \mzr{the compiler} \mzs{we} \mzu{creates checked pointer
  copies of the tainted arguments, and call the checked functions}.  \mz{This
  part is unclear. What are you trying to copy? Copying pointers doesn't make
  differences: pointers are just memory address. It's copying data that really
  helps. }
% 
In addition, once the checked function returns, if the output is a checked
pointer, we copy its data to a new tainted pointer and return it \mzr{so that
  the tainted caller only observes a tainted pointer that points to data in
  unchecked heap. This prevents checked pointer address exposure.}
  \Cref{fig:checkedc-example-3} line 42 is an example of \mzr{passing a tainted
    shell pointer as an argument to the function issued from an unchecked
    region} \mzs{serving the function call living in an unchecked region with a
    tainted shell pointer argument \code{tainted_compare_1}}.  Even if $g$
  derandomizes its address (line 14), the shell address \mzs{is} in the sandbox
  \mzs{and} has no harm \mzs{, and} \mzr{because} calling the shell never
  \mzr{leaks} \mzs{exposes} any checked pointer information outside of the
  shell.
% 

% 
Conceptually, the shell is run in a checked region.  Essentially, a tainted
shell is a safe closure that contains a checked block.  Once the closure is
called, the system \mzr{switches into the checked mode} \mzs{is turned to a
  checked region}.  For example, \Cref{fig:checkedc-example-2} line 25 surrounds
the tainted shell body with a $\echeckedtext$ block indicating that we
\mzu{context-switch} \mz{potential term abuse; ``switch'' would suffice} from
the unchecked to checked code region; thus, the checked function call at
\Cref{fig:checkedc-example-2} line 14 is safe, even if it is called by $g$ in
\Cref{fig:checkedc-example-3}, because it lives in the checked region.  In the
\systemname{} formalism, we formalize a \textit{checked} block on top of the
existing unchecked regions, and the transition of a tainted shell call creates a
checked block containing the shell body.  We also make sure that no
arguments\mzr{, as well as the output, }in \mzr{any} \mzs{these} tainted shell
contains any checked pointers\mzs{, as well as no output is of a checked type}.
%

\mz{Shell vs. Wrapper? Shell reminds me of bash. }
\fi


% \paragraph*{\textbf{NT-array Pointer Formalization}} NT-array pointers point to NT-arrays whose endings are determined by a null (\code{'\0'}). The length of a NT-array is usually not fixed. The two uses of NT-array pointers in \checkedc are branching and \code{strlen} operations. \code{if (*x) }$e_1$\code{ else }$e_2$ branches to $e_1$/$e_2$ depending one the \code{x}'s data, while \code{strlen(x)} computes the length of the NT-array pointed to by \code{x}.
% \liyi{move to formal and later section.}
  
% \paragraph*{\textbf{Dependent Functions}} \checkedc allows users to declare dependent functions.  Fig.~\ref{fig:checkedc-example} shows an example usage of dependent functions. The integer argument \code{x} is used to specify the bounds of the two NT-array pointers. It means that when we call the \code{memcpy} function, the upper-bounds of the two NT-array pointers must be no less than \code{x}. If the programmer makes the mistake of writing \lstinline{i <= x} in the for loop, the runtime checks will ensure that the indexing of\lstinline|x| in either \code{a} or \code{b} results in an error.
% Because of the dependent function features, we are able to utilize the fact that the two remaining length of the NT-array pointers are greater than \code{x}, so that the \code{for} is guaranteed to execute properly.

% \ignore{
% \liyi{Good information about pointer types here:
% https://github.com/microsoft/checkedc/wiki/New-pointer-and-array-types}




% This code creates an array pointer of length $10$, and reads the pointer $(x+y)$. 
% If the integer value $y$ is greater than $10$, executing the program in C results in undefined behavior. 
% In \checkedc, however, we links every pointer in a program with their bound information statically, and inserts checks to dynamically verify if the usage of the pointer violates the spatial safety. For example, In compiling the above fragment, we inserts the bound's check for $x$ in the read operation $(x+y)$, and if $y$ results in a value $11$, the execution of the read operation $(x+y)$ results in an dynamic error. 

% There are many existing language development trying to guarantee the C spatial safety property through different approaches. For example, Cyclone \cite{Jim2002} and Cerberus \cite{cerberus} are the fat pointer approaches for guaranteeing the spatial safety and eliminating undefined behaviors in C. Rust \cite{Rust2016}, on the other hand, tries to restrict the possible way of writing programs to guarantee such property statically.
% The problem of these two approaches are effectiveness of executing programs and user practicality of writing programs. The fat-pointer approach completely relies on dynamic checks to guarantee the safety properties but it might pay a huge price on execution efficiency. In our experiment (Sec.~\ref{sec:evaluation}), we found that the execution of fat pointer approaches cost the speed a 50\% overhead. 
% On the other hand, Rust uses a static approach by restricting the usage of pointers to guarantee the properties, which results in a user UN-friendly system.  
% The development of \checkedc is an investigation on keeping the balance between execution efficiency and user-friendly systems. We develop a system to utilize static type systems to allow the \checkedc compiler to insert dynamic checks to guarantee the safety property. The efficiency of \checkedc is in the same level of Rust while we maintain a user-friendly system and inherited most of the operation features from C.

% Another feature of \checkedc is the division of the checked and unchecked blocks. When users try to rewrite their C programs into \checkedc programs, they can develop the code incrementally by rewriting sub-parts of their programs to \checkedc code fragments and placing them as the checked blocks, while keeping the rest C programs as unchecked C programs. \checkedc guarantees that if there is any safety violation, this comes from the unchecked blocks (the blame theory). 

% Here is the contributions of the paper. First, we develop the code formalization of \checkedc and show that the type system in \checkedc is type-sound and satisfies the blame theory with respect to the \checkedc semantics. Specifically, we formalize null-terminated array pointers. To our best knowledge, this is the first work defining such feature in C-related languages. 
% Second, in formalizing the \checkedc language, we investigate the balance between program execution efficiency and user practicality. We re-investigate the \checkedc type system with subtyping relations to make it more efficient and user-friendly.
% Second, we also develop random testing tools in Redex \cite{pltredex} to test the \checkedc compiler and make sure it is properly developed. We are able to find and reproduce many bugs/faults in the \checkedc compiler \liyi{numbers?}. The random testing tool is able to generate tens of thousands of programs to properly validate the \checkedc compiler. Third, we also spent a great amount of work in developing experiments to compare \checkedc and other existing C-like languages that guarantee the spatial safety and eliminating undefined behaviors. We found that \checkedc keeps the best balance between execution efficiency and user practicality.
% }

