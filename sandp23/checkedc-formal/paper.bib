@article{compcert,
        title = {Formal Verification of a Realistic Compiler},
        volume = {52},
        issn = {0001-0782},
        url = {http://doi.acm.org/10.1145/1538788.1538814},
        doi = {10/c9sb7q},
        language = {en},
        number = {7},
        urldate = {2019-09-30},
        journal = {Communications of the ACM},
        author = {Leroy, Xavier},
        month = jul,
        year = {2009},
        pages = {107--115}
}

@misc{mpx,
 key = {MPX},
 title = {Intel Memory Protection Extensions (MPX)},
 howpublished = {\url{https://software.intel.com/en-us/isa-extensions/intel-mpx}},
 year = 2018
}

@InProceedings{tobinhochstadt_et_al:LIPIcs:2017:7120,
  author =	{Sam Tobin-Hochstadt and Matthias Felleisen and Robert Findler and Matthew Flatt and Ben Greenman and Andrew M. Kent and Vincent St-Amour and T. Stephen Strickland and Asumu Takikawa},
  title =	{{Migratory Typing: Ten Years Later}},
  booktitle =	{2nd Summit on Advances in Programming Languages (SNAPL 2017)},
  pages =	{17:1--17:17},
  year =	{2017},
  volume =	{71},
}

@misc{checkedc-tech-report,
 author = {Liyi Li and Yiyun Liu and Deena Postol and Leonidas Lampropoulos and David Van Horn and Michael Hicks},
 title = {{A Formal Model of Checked C} (Extended Version)},
 howpublished = {\url{https://arxiv.org/abs/2201.13394}},
 year = {2022},
 urldate = {2022-01-31}
}

@article{wright94syntactic,
  author = {Andrew K. Wright and Matthias Felleisen},
  title = {A syntactic approach to type soundness},
  journal = {Information and computation},
  volume = 115,
  number = 1,
  year = 1994
}

@article{milner78polymorphism,
  author = {Robin Milner},
  year = 1978,
  title = {A theory of type polymorphism in programming},
  journal = {J. Comput. System Sci.},
  volume = 17,
  number = 3
}  

@inproceedings{Matsakis:2014:RL:2663171.2663188,
 author = {Matsakis, Nicholas D. and Klock,II, Felix S.},
 title = {The Rust Language},
 booktitle = {ACM SIGAda Annual Conference on High Integrity Language Technology},
 year = {2014},
}

@article{Jung:2017:RSF:3177123.3158154,
 author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
 title = {RustBelt: Securing the Foundations of the Rust Programming Language},
 journal = {Proc. ACM Program. Lang.},
 volume = {2},
 number = {POPL},
 year = {2017},
}

@article{Greenman:2018:STS:3243631.3236766,
 author = {Greenman, Ben and Felleisen, Matthias},
 title = {A Spectrum of Type Soundness and Performance},
 journal = {Proc. ACM Program. Lang.},
 issue_date = {September 2018},
 volume = {2},
 number = {ICFP},
 year = {2018},
}

@inproceedings{Takikawa:2016:SGT:2837614.2837630,
 author = {Takikawa, Asumu and Feltey, Daniel and Greenman, Ben and New, Max S. and Vitek, Jan and Felleisen, Matthias},
 title = {Is Sound Gradual Typing Dead?},
 booktitle = {POPL},
 year = {2016},
} 

@misc{checkedc,
  author = {David Tarditi},
  title = {{Extending C with Bounds Safety and Improved Type Safety}},
  year = 2021,
  url = {https://github.com/secure-sw-dev/checkedc/},
  urldate = {2021-01-26}
}

@article{Refinementlh,
author = {Vazou, Niki and Seidel, Eric L. and Jhala, Ranjit and Vytiniotis, Dimitrios and Peyton-Jones, Simon},
title = {{Refinement Types for Haskell}},
year = {2014},
issue_date = {September 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/2692915.2628161},
doi = {10.1145/2692915.2628161},
abstract = {SMT-based checking of refinement types for call-by-value languages is a well-studied
subject. Unfortunately, the classical translation of refinement types to verification
conditions is unsound under lazy evaluation. When checking an expression, such systems
implicitly assume that all the free variables in the expression are bound to values.
This property is trivially guaranteed by eager, but does not hold under lazy, evaluation.
Thus, to be sound and precise, a refinement type system for Haskell and the corresponding
verification conditions must take into account which subset of binders actually reduces
to values. We present a stratified type system that labels binders as potentially
diverging or not, and that (circularly) uses refinement types to verify the labeling.
We have implemented our system in LIQUIDHASKELL and present an experimental evaluation
of our approach on more than 10,000 lines of widely used Haskell libraries. We show
that LIQUIDHASKELL is able to prove 96% of all recursive functions terminating, while
requiring a modest 1.7 lines of termination-annotations per 100 lines of code.},
journal = {SIGPLAN Not.},
month = aug,
pages = {269–282},
numpages = {14}
}

@article{LiquidHaskell,
   title={{An Introduction to Liquid Haskell}},
   volume={237},
   ISSN={2075-2180},
   url={http://dx.doi.org/10.4204/EPTCS.237.5},
   DOI={10.4204/eptcs.237.5},
   journal={Electronic Proceedings in Theoretical Computer Science},
   publisher={Open Publishing Association},
   author={Peña, Ricardo},
   year={2017},
   month={Jan},
   pages={68–80}
}

@misc{c2rust,
  key = {c2rust},
  title = {{C} to Rust translation, refactoring, and cross-checking},
  howpublished = {\url{https://c2rust.com/}},
  year = 2018
}

@INPROCEEDINGS{elliott18checkedc,
  TITLE = {{Checked {C}: Making {C} Safe by Extension}},
  AUTHOR = {Archibald Samuel Elliott and Andrew Ruef and Michael Hicks and David Tarditi},
  BOOKTITLE = {Proceedings of the IEEE Conference on Secure Development (SecDev)},
  MONTH = SEP,
  YEAR = 2018
}

@INPROCEEDINGS{gil18hole,
  TITLE = {There’s a Hole in the Bottom of the {C}: On the Effectiveness of Allocation Protection},
  AUTHOR = {Ronald Gil and Hamed Okhravi and Howard Shrobe},
  BOOKTITLE = {Proceedings of the IEEE Conference on Secure Development (SecDev)},
  MONTH = SEP,
  YEAR = 2018
}

@misc{c2rust,
  key = {c2rust},
  title = {{C} to Rust translation, refactoring, and cross-checking},
  howpublished = {\url{https://c2rust.com/}},
  year = 2018
}

@inproceedings{siek06,
  author = {Jeremy G. Siek and Walid Taha},
  title = {Gradual Typing for Functional Languages},
  booktitle = {Workshop on Scheme and Functional Programming},
  year = 2006
}

@inproceedings{matthews07,
 author = {Matthews, Jacob and Findler, Robert Bruce},
 title = {Operational Semantics for Multi-language Programs},
 booktitle = {POPL},
 year = {2007},
}

@inproceedings{wadler09,
 author = {Wadler, Philip and Findler, Robert Bruce},
 title = {Well-Typed Programs Can'T Be Blamed},
 booktitle = {ESOP},
 year = {2009},
} 

@article{Austin1994Ptrdist,
 author = {Austin, Todd M. and Breach, Scott E. and Sohi, Gurindar S.},
 title = {Efficient Detection of All Pointer and Array Access Errors},
 journal = {SIGPLAN Not.},
 issue_date = {June 1994},
 volume = {29},
 number = {6},
 month = jun,
 year = {1994},
}

@article{necula2005ccured,
  title={{CCured: type-safe retrofitting of legacy software}},
  author={Necula, George C and Condit, Jeremy and Harren, Matthew and McPeak, Scott and Weimer, Westley},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={27},
  number={3},
  pages={477--526},
  year={2005},
}

@article{Rogers1995Olden,
 author = {Rogers, Anne and Carlisle, Martin C. and Reppy, John H. and Hendren, Laurie J.},
 title = {Supporting Dynamic Data Structures on Distributed-memory Machines},
 journal = {ACM Trans. Program. Lang. Syst.},
 issue_date = {March 1995},
 volume = {17},
 number = {2},
 month = mar,
 year = {1995},
 pages = {233--263},
 numpages = {31},
}

@book{sangiorgi2011advanced,
  title={Advanced topics in bisimulation and coinduction},
  author={Sangiorgi, Davide and Rutten, Jan},
  volume={52},
  year={2011},
  publisher={Cambridge University Press}
}

@InProceedings{ruef18checkedc-incr,
author="Ruef, Andrew
and Lampropoulos, Leonidas
and Sweet, Ian
and Tarditi, David
and Hicks, Michael",
editor="Nielson, Flemming
and Sands, David",
title={{Achieving Safety Incrementally with Checked C}},
booktitle="Principles of Security and Trust",
year="2019",
publisher="Springer International Publishing",
address="Cham",
pages="76--98",
abstract="Checked C is a new effort working toward a memory-safe C. Its design is distinguished from that of prior efforts by truly being an extension of C: Every C program is also a Checked C program. Thus, one may make incremental safety improvements to existing codebases while retaining backward compatibility. This paper makes two contributions. First, to help developers convert existing C code to use so-called checked (i.e., safe) pointers, we have developed a preliminary, automated porting tool. Notably, this tool takes advantage of the flexibility of Checked C's design: The tool need not perfectly classify every pointer, as required of prior all-or-nothing efforts. Rather, it can make a best effort to convert more pointers accurately, without letting inaccuracies inhibit compilation. However, such partial conversion raises the question: If safety violations can still occur, what sort of advantage does using Checked C provide? We draw inspiration from research on migratory typing to make our second contribution: We prove a blame property that renders so-called checked regions blameless of any run-time failure. We formalize this property for a core calculus and mechanize the proof in Coq.",
isbn="978-3-030-17138-4"
}

@article{10.1145/2980983.2908081,
author = {Memarian, Kayvan and Matthiesen, Justus and Lingard, James and Nienhuis, Kyndylan and Chisnall, David and Watson, Robert N. M. and Sewell, Peter},
title = {{Into the Depths of C: Elaborating the de Facto Standards}},
year = {2016},
issue_date = {June 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/2980983.2908081},
doi = {10.1145/2980983.2908081},
abstract = { C remains central to our computing infrastructure. It is notionally defined by ISO
standards, but in reality the properties of C assumed by systems code and those implemented
by compilers have diverged, both from the ISO standards and from each other, and none
of these are clearly understood. We make two contributions to help improve this error-prone
situation. First, we describe an in-depth analysis of the design space for the semantics
of pointers and memory in C as it is used in practice. We articulate many specific
questions, build a suite of semantic test cases, gather experimental data from multiple
implementations, and survey what C experts believe about the de facto standards. We
identify questions where there is a consensus (either following ISO or differing)
and where there are conflicts. We apply all this to an experimental C implemented
above capability hardware. Second, we describe a formal model, Cerberus, for large
parts of C. Cerberus is parameterised on its memory model; it is linkable either with
a candidate de facto memory object model, under construction, or with an operational
C11 concurrency model; it is defined by elaboration to a much simpler Core language
for accessibility, and it is executable as a test oracle on small examples. This should
provide a solid basis for discussion of what mainstream C is now: what programmers
and analysis tools can assume and what compilers aim to implement. Ultimately we hope
it will be a step towards clear, consistent, and accepted semantics for the various
use-cases of C. },
journal = {SIGPLAN Not.},
month = jun,
pages = {1–15},
numpages = {15},
keywords = {C}
}

@inproceedings{DBLP:conf/ictac/LiG21,
  author    = {Liyi Li and
               Elsa L. Gunter},
  editor    = {Antonio Cerone and
               Peter Csaba {\"{O}}lveczky},
  title     = {A Complete Semantics of {\textdollar}{\textbackslash}mathbb \{K\}{\textdollar}
               and Its Translation to Isabelle},
  booktitle = {Theoretical Aspects of Computing - {ICTAC} 2021 - 18th International
               Colloquium, Virtual Event, Nur-Sultan, Kazakhstan, September 8-10,
               2021, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {12819},
  pages     = {152--171},
  publisher = {Springer},
  year      = {2021},
  url       = {https://doi.org/10.1007/978-3-030-85315-0\_10},
  doi       = {10.1007/978-3-030-85315-0\_10},
  timestamp = {Wed, 25 Aug 2021 09:47:08 +0200},
  biburl    = {https://dblp.org/rec/conf/ictac/LiG21.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{Zhao:2012:FLI:2103621.2103709,
 author = {Zhao, Jianzhou and Nagarakatte, Santosh and Martin, Milo M.K. and Zdancewic, Steve},
 title = {{Formalizing the LLVM Intermediate Representation for Verified Program Transformations}},
 journal = {SIGPLAN Not.},
 issue_date = {January 2012},
 volume = {47},
 number = {1},
 month = jan,
 year = {2012},
 issn = {0362-1340},
 pages = {427--440},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/2103621.2103709},
 doi = {10.1145/2103621.2103709},
 acmid = {2103709},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Coq, LLVM, memory safety},
} 

@article{Lee:2017:TUB:3140587.3062343,
 author = {Lee, Juneyoung and Kim, Yoonseung and Song, Youngju and Hur, Chung-Kil and Das, Sanjoy and Majnemer, David and Regehr, John and Lopes, Nuno P.},
 title = {{Taming Undefined Behavior in LLVM}},
 journal = {SIGPLAN Not.},
 issue_date = {June 2017},
 volume = {52},
 number = {6},
 month = jun,
 year = {2017},
 issn = {0362-1340},
 pages = {633--647},
 numpages = {15},
 url = {http://doi.acm.org/10.1145/3140587.3062343},
 doi = {10.1145/3140587.3062343},
 acmid = {3062343},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {compilers, intermediate representations, undefined behavior},
} 

@article{10.1145/1543135.1542504,
author = {Nagarakatte, Santosh and Zhao, Jianzhou and Martin, Milo M.K. and Zdancewic, Steve},
title = {{SoftBound: Highly Compatible and Complete Spatial Memory Safety for c}},
year = {2009},
issue_date = {June 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {44},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/1543135.1542504},
doi = {10.1145/1543135.1542504},
abstract = {The serious bugs and security vulnerabilities facilitated by C/C++'s lack of bounds
checking are well known, yet C and C++ remain in widespread use. Unfortunately, C's
arbitrary pointer arithmetic, conflation of pointers and arrays, and programmer-visible
memory layout make retrofitting C/C++ with spatial safety guarantees extremely challenging.
Existing approaches suffer from incompleteness, have high runtime overhead, or require
non-trivial changes to the C source code. Thus far, these deficiencies have prevented
widespread adoption of such techniques.This paper proposes SoftBound, a compile-time
transformation for enforcing spatial safety of C. Inspired by HardBound, a previously
proposed hardware-assisted approach, SoftBound similarly records base and bound information
for every pointer as disjoint metadata. This decoupling enables SoftBound to provide
spatial safety without requiring changes to C source code. Unlike HardBound, SoftBound
is a software-only approach and performs metadata manipulation only when loading or
storing pointer values. A formal proof shows that this is sufficient to provide spatial
safety even in the presence of arbitrary casts. SoftBound's full checking mode provides
complete spatial violation detection with 67% runtime overhead on average. To further
reduce overheads, SoftBound has a store-only checking mode that successfully detects
all the security vulnerabilities in a test suite at the cost of only 22% runtime overhead
on average.},
journal = {SIGPLAN Not.},
month = jun,
pages = {245–258},
numpages = {14},
keywords = {spatial memory safety, buffer overflows, c}
}

@article{10.1145/1837855.1806657,
author = {Nagarakatte, Santosh and Zhao, Jianzhou and Martin, Milo M.K. and Zdancewic, Steve},
title = {CETS: Compiler Enforced Temporal Safety for C},
year = {2010},
issue_date = {August 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {8},
issn = {0362-1340},
url = {https://doi.org/10.1145/1837855.1806657},
doi = {10.1145/1837855.1806657},
abstract = {Temporal memory safety errors, such as dangling pointer dereferences and double frees,
are a prevalent source of software bugs in unmanaged languages such as C. Existing
schemes that attempt to retrofit temporal safety for such languages have high runtime
overheads and/or are incomplete, thereby limiting their effectiveness as debugging
aids. This paper presents CETS, a compile-time transformation for detecting all violations
of temporal safety in C programs. Inspired by existing approaches, CETS maintains
a unique identifier with each object, associates this metadata with the pointers in
a disjoint metadata space to retain memory layout compatibility, and checks that the
object is still allocated on pointer dereferences. A formal proof shows that this
is sufficient to provide temporal safety even in the presence of arbitrary casts if
the program contains no spatial safety violations. Our CETS prototype employs both
temporal check removal optimizations and traditional compiler optimizations to achieve
a runtime overhead of just 48% on average. When combined with a spatial-checking system,
the average overall overhead is 116% for complete memory safety},
journal = {SIGPLAN Not.},
month = jun,
pages = {31–40},
numpages = {10},
keywords = {dangling pointers, memory safety, c, temporal errors}
}

@article{10.1145/2813885.2737979,
author = {Hathhorn, Chris and Ellison, Chucky and Ro\c{s}u, Grigore},
title = {{Defining the Undefinedness of C}},
year = {2015},
issue_date = {June 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/2813885.2737979},
doi = {10.1145/2813885.2737979},
abstract = { We present a ``negative'' semantics of the C11 language---a semantics that does not
just give meaning to correct programs, but also rejects undefined programs. We investigate
undefined behavior in C and discuss the techniques and special considerations needed
for formally specifying it. We have used these techniques to modify and extend a semantics
of C into one that captures undefined behavior. The amount of semantic infrastructure
and effort required to achieve this was unexpectedly high, in the end nearly doubling
the size of the original semantics. From our semantics, we have automatically extracted
an undefinedness checker, which we evaluate against other popular analysis tools,
using our own test suite in addition to a third-party test suite. Our checker is capable
of detecting examples of all 77 categories of core language undefinedness appearing
in the C11 standard, more than any other tool we considered. Based on this evaluation,
we argue that our work is the most comprehensive and complete semantic treatment of
undefined behavior in C, and thus of the C language itself. },
journal = {SIGPLAN Not.},
month = jun,
pages = {336–345},
numpages = {10},
keywords = {C11, K Framework, Programming language semantics, Undefined behavior}
}

@inproceedings{ellison-rosu-2012-popl,
 author = {Ellison, Chucky and Rosu, Grigore},
 title = {{An Executable Formal Semantics of C with Applications}},
 booktitle = {Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
 series = {POPL '12},
 year = {2012},
 isbn = {978-1-4503-1083-3},
 location = {Philadelphia, PA, USA},
 pages = {533--544},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/2103656.2103719},
 doi = {10.1145/2103656.2103719},
 acmid = {2103719},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {C, k, semantics},
}


@article{Memarian:2019:ECS:3302515.3290380,
 author = {Memarian, Kayvan and Gomes, Victor B. F. and Davis, Brooks and Kell, Stephen and Richardson, Alexander and Watson, Robert N. M. and Sewell, Peter},
 title = {{Exploring C Semantics and Pointer Provenance}},
 journal = {Proc. ACM Program. Lang.},
 issue_date = {January 2019},
 volume = {3},
 number = {POPL},
 month = jan,
 year = {2019},
 issn = {2475-1421},
 pages = {67:1--67:32},
 articleno = {67},
 numpages = {32},
 url = {http://doi.acm.org/10.1145/3290380},
 doi = {10.1145/3290380},
 acmid = {3290380},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {C},
} 

@article{Lee:2018:RHO:3288538.3276495,
 author = {Lee, Juneyoung and Hur, Chung-Kil and Jung, Ralf and Liu, Zhengyang and Regehr, John and Lopes, Nuno P.},
 title = {{Reconciling High-level Optimizations and Low-level Code in LLVM}},
 journal = {Proc. ACM Program. Lang.},
 issue_date = {November 2018},
 volume = {2},
 number = {OOPSLA},
 month = oct,
 year = {2018},
 issn = {2475-1421},
 pages = {125:1--125:28},
 articleno = {125},
 numpages = {28},
 url = {http://doi.acm.org/10.1145/3276495},
 doi = {10.1145/3276495},
 acmid = {3276495},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {IR Memory Model, LLVM},
} 

@article{Kang:2015:FCM:2813885.2738005,
 author = {Kang, Jeehoon and Hur, Chung-Kil and Mansky, William and Garbuzov, Dmitri and Zdancewic, Steve and Vafeiadis, Viktor},
 title = {{A Formal C Memory Model Supporting Integer-pointer Casts}},
 journal = {SIGPLAN Not.},
 issue_date = {June 2015},
 volume = {50},
 number = {6},
 month = jun,
 year = {2015},
 issn = {0362-1340},
 pages = {326--335},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/2813885.2738005},
 doi = {10.1145/2813885.2738005},
 acmid = {2738005},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {C Memory Model, Compiler, Integer-Pointer Cast, Optimization, Verification},
} 


@techreport{leroy:hal-00703441,
  TITLE = {{The CompCert Memory Model, Version 2}},
  AUTHOR = {Leroy, Xavier and Appel, Andrew W. and Blazy, Sandrine and Stewart, Gordon},
  URL = {https://hal.inria.fr/hal-00703441},
  TYPE = {Research Report},
  NUMBER = {RR-7987},
  PAGES = {26},
  INSTITUTION = {{INRIA}},
  YEAR = {2012},
  MONTH = Jun,
  KEYWORDS = {Memory models ; formal semantics ; verified compilation ; CompCert},
  PDF = {https://hal.inria.fr/hal-00703441/file/RR-7987.pdf},
  HAL_ID = {hal-00703441},
  HAL_VERSION = {v1},
}

@inproceedings{PalkaAST11,
 author = {Pa{\l}ka, Micha{\l} H. and Claessen, Koen and Russo, Alejandro and Hughes, John},
 title = {{Testing an Optimising Compiler by Generating Random Lambda Terms}},
 booktitle = {Proceedings of the 6th International Workshop on Automation of Software Test},
 shortbooktitle = {AST},
 series = {AST '11},
 year = {2011},
 isbn = {978-1-4503-0592-1},
 location = {Waikiki, Honolulu, HI, USA},
 pages = {91--97},
 numpages = {7},
 url = {http://doi.acm.org/10.1145/1982595.1982615},
 doi = {10.1145/1982595.1982615},
 acmid = {1982615},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {random testing, software testing},
 } 

@inproceedings{lambdajs,
author = {Guha, Arjun and Saftoiu, Claudiu and Krishnamurthi, Shriram},
title = {{The Essence of Javascript}},
year = {2010},
isbn = {3642141064},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Proceedings of the 24th European Conference on Object-Oriented Programming},
pages = {126–150},
numpages = {25},
location = {Maribor, Slovenia},
series = {ECOOP'10}
}

@article{merigoux2021catala,
  title={{Catala: A Programming Language for the Law}},
  author={Merigoux, Denis and Chataing, Nicolas and Protzenko, Jonathan},
  journal={arXiv preprint arXiv:2103.03198},
  year={2021}
}
