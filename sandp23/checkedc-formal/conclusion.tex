\section{Conclusion and Future Work}
\label{sec:conclude}

This paper presented \CoreChkC, a formalization of an extended core of
the Checked C language which aims to provide spatial memory
safety. \CoreChkC models dynamically sized and
null-terminated arrays with dependently typed bounds that can
additionally be widened at runtime. We prove, in Coq, the key safety
property of Checked C for our formalization, {\em blame}: if a mix of
checked and unchecked code gives rise to a spatial memory safety
violation, then this violation originated in an unchecked part of the
code. We also show how programs written in \CoreChkC (whose
semantics leverage fat pointers) can be compiled to \elang (which does
not) while preserving their behavior. We developed a version of \lang
written in PLT Redex, and used a custom term generator in conjunction with Redex's
randomized testing framework to give confidence that compilation is
correct. We also used this framework to cross-check \lang
against the \checkedc compiler, finding multiple inconsistencies
in the process. 

As future work, we wish to extend \CoreChkC to model more of Checked
C, with our Redex-based testing framework guiding the process. The
most interesting Checked C feature not yet modeled is \emph{interop
  types} (itypes), which are used to simplify interactions with
unchecked code via function calls. A function whose
parameters are itypes can be passed checked or unchecked pointers
depending on whether the caller is in a checked region. This feature
allows for a more modular C-to-Checked C porting process, but complicates reasoning
about blame. A more ambitious next step would be to extend an existing
formally verified framework for C, such as CompCert~\cite{compcert} or VeLLVM
\cite{Zhao:2012:FLI:2103621.2103709}, with Checked C features, towards
producing a verified-correct Checked C compiler. We believe that
\lang's Coq and Redex models lay the foundation for such a step, but
substantial engineering work remains.
